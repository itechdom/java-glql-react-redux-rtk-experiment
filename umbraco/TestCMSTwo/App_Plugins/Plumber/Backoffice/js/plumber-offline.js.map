{"version":3,"names":[],"mappings":"","sources":["plumber-offline.js"],"sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ComponentsModule = void 0;\r\nconst action_1 = require(\"./action-workflow/action\");\r\nconst changedescription_1 = require(\"./changedescription/changedescription\");\r\nconst chart_1 = require(\"./chart/chart\");\r\nconst comments_1 = require(\"./comments/comments\");\r\nconst config_1 = require(\"./config/config\");\r\nconst contenttypeflow_1 = require(\"./contenttypeflow/contenttypeflow\");\r\nconst instances_1 = require(\"./instances/instances\");\r\nconst progress_1 = require(\"./progress/progress\");\r\nconst submit_1 = require(\"./submit-workflow/submit\");\r\nconst tasklist_1 = require(\"./tasklist/tasklist\");\r\nconst tasks_1 = require(\"./tasks/tasks\");\r\nconst workflowdiff_1 = require(\"./diff/workflowdiff\");\r\nconst scheduling_1 = require(\"./scheduling/scheduling\");\r\nconst applies_to_1 = require(\"./applies-to/applies-to\");\r\nconst datepicker_1 = require(\"./datepicker/datepicker\");\r\nconst history_1 = require(\"./history/history\");\r\nconst grouppicker_1 = require(\"./grouppicker/grouppicker\");\r\nconst pagesize_1 = require(\"./pagesize/pagesize\");\r\nconst filterpicker_1 = require(\"./filterpicker/filterpicker\");\r\nconst dayrange_1 = require(\"./dayrange/dayrange\");\r\nexports.ComponentsModule = angular\r\n    .module('plumber.components', [])\r\n    .component(action_1.WorkflowActionComponent.name, action_1.WorkflowActionComponent)\r\n    .component(changedescription_1.ChangeDescriptionComponent.name, changedescription_1.ChangeDescriptionComponent)\r\n    .component(chart_1.ChartComponent.name, chart_1.ChartComponent)\r\n    .component(comments_1.CommentsComponent.name, comments_1.CommentsComponent)\r\n    .component(config_1.ConfigComponent.name, config_1.ConfigComponent)\r\n    .component(contenttypeflow_1.ContentTypeFlowComponent.name, contenttypeflow_1.ContentTypeFlowComponent)\r\n    .component(instances_1.WorkflowInstancesComponent.name, instances_1.WorkflowInstancesComponent)\r\n    .component(progress_1.ProgressComponent.name, progress_1.ProgressComponent)\r\n    .component(submit_1.SubmitWorkflowComponent.name, submit_1.SubmitWorkflowComponent)\r\n    .component(tasklist_1.TaskListComponent.name, tasklist_1.TaskListComponent)\r\n    .component(tasks_1.TasksComponent.name, tasks_1.TasksComponent)\r\n    .component(workflowdiff_1.WorkflowDiffComponent.name, workflowdiff_1.WorkflowDiffComponent)\r\n    .component(scheduling_1.SchedulingComponent.name, scheduling_1.SchedulingComponent)\r\n    .component(applies_to_1.AppliesToComponent.name, applies_to_1.AppliesToComponent)\r\n    .component(datepicker_1.DatepickerComponent.name, datepicker_1.DatepickerComponent)\r\n    .component(history_1.HistoryComponent.name, history_1.HistoryComponent)\r\n    .component(grouppicker_1.WorkflowGroupPickerComponent.name, grouppicker_1.WorkflowGroupPickerComponent)\r\n    .component(pagesize_1.PageSizeComponent.name, pagesize_1.PageSizeComponent)\r\n    .component(filterpicker_1.FilterPickerComponent.name, filterpicker_1.FilterPickerComponent)\r\n    .component(dayrange_1.DayRangeComponent.name, dayrange_1.DayRangeComponent)\r\n    .name;\r\n\n},{\"./action-workflow/action\":2,\"./applies-to/applies-to\":3,\"./changedescription/changedescription\":4,\"./chart/chart\":5,\"./comments/comments\":6,\"./config/config\":7,\"./contenttypeflow/contenttypeflow\":8,\"./datepicker/datepicker\":9,\"./dayrange/dayrange\":10,\"./diff/workflowdiff\":11,\"./filterpicker/filterpicker\":12,\"./grouppicker/grouppicker\":13,\"./history/history\":14,\"./instances/instances\":15,\"./pagesize/pagesize\":16,\"./progress/progress\":17,\"./scheduling/scheduling\":18,\"./submit-workflow/submit\":19,\"./tasklist/tasklist\":20,\"./tasks/tasks\":21}],2:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WorkflowActionComponent = void 0;\r\nconst constants_1 = require(\"../../js/constants\");\r\nclass WorkflowAction {\r\n    constructor($scope, $rootScope, $window, $location, navigationService, localizationService, plmbrActionsService, plmbrStateFactory) {\r\n        this.$rootScope = $rootScope;\r\n        this.$window = $window;\r\n        this.$location = $location;\r\n        this.navigationService = navigationService;\r\n        this.buttonState = {\r\n            approve: 'init',\r\n            resubmit: 'init',\r\n            reject: 'init',\r\n            cancel: 'init',\r\n        };\r\n        this.comment = '';\r\n        this.commentMaxLength = 250;\r\n        this.currentAction = '';\r\n        this.invalidComment = false;\r\n        this.$onInit = () => {\r\n            this.setButtonSuffix();\r\n        };\r\n        /**\r\n         * If the app controller modifies state, we'll hear about it here, and update the view if required\r\n         * @param {any} changes\r\n         */\r\n        this.$onChanges = changes => {\r\n            if (changes.state && changes.state.currentValue.nodeId === this.state.nodeId) {\r\n                this.state = changes.state.currentValue;\r\n                this.setActivePermissions();\r\n                this.setButtonSuffix();\r\n                this.comment = null;\r\n            }\r\n        };\r\n        this.setButtonSuffix = () => {\r\n            if (!this.state || this.state.canAction) {\r\n                this.btnSuffix = '';\r\n                return;\r\n            }\r\n            this.btnSuffix = this.state.isAdmin && !this.state.canAction && !this.state.canResubmit ? this.asAdminStr : '';\r\n            if (this.state.currentTask) {\r\n                this.btnSuffix = this.state.currentTask.taskStatus === 2 && this.state.canResubmit ? '' : this.btnSuffix;\r\n            }\r\n        };\r\n        this.actionsService = plmbrActionsService;\r\n        this.stateFactory = plmbrStateFactory;\r\n        this.onButtonStateChanged = $rootScope.$on(constants_1.constants.events.buttonStateChanged, (_, data) => {\r\n            if (this.state && data.id === this.state.nodeId) {\r\n                this.buttonState[this.currentAction] = data.state;\r\n            }\r\n        });\r\n        localizationService.localizeMany(['workflow_action', 'workflow_asAdmin',])\r\n            .then((resp) => {\r\n            let [action, asAdmin] = resp;\r\n            this.actionStr = action;\r\n            this.asAdminStr = `(${asAdmin})`;\r\n            this.setButtonSuffix();\r\n        });\r\n        $scope.$on('$destroy', () => {\r\n            this.onButtonStateChanged();\r\n            this.listen ? this.listen() : {};\r\n        });\r\n    }\r\n    setActivePermissions() {\r\n        const key = this.state.currentTask.node.new && this.state.permissions.new.length ? 'new' : this.state.permissions.active;\r\n        this.activePermissions = this.state.permissions[key];\r\n    }\r\n    preview() {\r\n        // Build the correct path so both /#/ and #/ work.\r\n        // get the culture from mculture if nothing on state\r\n        let query = `id=${this.state.nodeId}`;\r\n        if (this.state.currentTask.variantCode && this.state.currentTask.variantCode !== '*') {\r\n            query += `#?culture=${this.state.currentTask.variantCode}`;\r\n        }\r\n        const redirect = Umbraco.Sys.ServerVariables.umbracoSettings.umbracoPath + '/preview/?' + query;\r\n        // Chromes popup blocker will kick in if a window is opened\r\n        // without the initial scoped request. This trick will fix that.\r\n        const previewWindow = this.$window.open('preview/?init=true', 'umbpreview');\r\n        if (previewWindow) {\r\n            previewWindow.location.href = redirect;\r\n        }\r\n    }\r\n    action(actionName) {\r\n        this.currentAction = actionName;\r\n        this.actionsService.action(this.state.currentTask, this.comment, actionName, this.state.offline);\r\n        this.comment = null;\r\n    }\r\n    goToNode() {\r\n        this.navigationService.changeSection('content');\r\n        this.$location.path(`/content/content/edit/${this.state.nodeId}`);\r\n        this.$rootScope.$emit(constants_1.constants.events.goToNode);\r\n    }\r\n    /**\r\n     * If the instance has status === error, the error message is on the author comment\r\n     * wrapped in square brackets. This extracts it.\r\n     * @returns {string} c\r\n     */\r\n    extractErrorFromComment() {\r\n        const c = this.state.currentTask.comment || '';\r\n        return c.substring(c.indexOf('[') + 1, c.length - 1);\r\n    }\r\n}\r\nexports.WorkflowActionComponent = {\r\n    name: 'workflowAction',\r\n    transclude: true,\r\n    templateUrl: 'src/plumber/backoffice/components/action-workflow/action.html',\r\n    bindings: {\r\n        state: '<',\r\n        instance: '<',\r\n        dashboard: '<',\r\n    },\r\n    controller: WorkflowAction\r\n};\r\n\n},{\"../../js/constants\":22}],3:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AppliesToComponent = void 0;\r\nclass AppliesTo {\r\n    constructor(localizationService) {\r\n        this.localizationService = localizationService;\r\n        this.$onInit = () => {\r\n            this.localizationService.localizeMany(['workflow_publishOnly', 'workflow_publishAndUnpublish', 'workflow_unpublishDisabled', 'workflow_appliesTo'])\r\n                .then(resp => {\r\n                this.publishOnly = resp[0];\r\n                this.publishAndUnpublish = resp[1];\r\n                this.unpublishDisabled = resp[2];\r\n                this.appliesTo = resp[3];\r\n            });\r\n        };\r\n    }\r\n}\r\nconst template = `\r\n    <div ng-disabled=\"$ctrl.disabled\" class=\"mt-2\">\r\n        <label class=\"control-label mb-0\" for=\"appliesTo\">{{ $ctrl.appliesTo }}</label>\r\n        <div>\r\n            <umb-radiobutton value=\"0\"\r\n                             name=\"appliesTo_0\"\r\n                             text=\"{{ $ctrl.publishAndUnpublish }}\"\r\n                             model=\"$ctrl.model\">\r\n            </umb-radiobutton>\r\n            <umb-radiobutton value=\"1\"\r\n                             name=\"appliesTo_1\"\r\n                             text=\"{{ $ctrl.publishOnly }}\"\r\n                             model=\"$ctrl.model\">\r\n            </umb-radiobutton>\r\n        </div>\r\n        <small ng-if=\"$ctrl.disabled\" class=\"mt-1\" style=\"display:inline-block\">\r\n            {{ $ctrl.unpublishDisabled }}\r\n        </small>\r\n    </div>`;\r\nexports.AppliesToComponent = {\r\n    name: 'appliesTo',\r\n    transclude: true,\r\n    bindings: {\r\n        model: '=',\r\n        disabled: '<',\r\n    },\r\n    template: template,\r\n    controller: AppliesTo\r\n};\r\n\n},{}],4:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ChangeDescriptionComponent = void 0;\r\nclass WorkflowChangeDescription {\r\n    constructor($q, assetsService, editorService, overlayService, plmbrGroupsResource, localizationService) {\r\n        this.editorService = editorService;\r\n        this.overlayService = overlayService;\r\n        this.plmbrGroupsResource = plmbrGroupsResource;\r\n        this.showDiffBtn = false;\r\n        this.$onChanges = changes => {\r\n            if (changes.state && changes.state.currentVersion) {\r\n                this.item = this.state.currentTask;\r\n            }\r\n        };\r\n        this.viewsPath = Umbraco.Sys.ServerVariables.Plumber.viewsPath;\r\n        const license = Umbraco.Sys.ServerVariables.Plumber.license;\r\n        this.unlicensed = !license || license.isTrial && !license.isImpersonating;\r\n        const promises = [\r\n            assetsService.loadJs('/umbraco/lib/jsdiff/diff.js'),\r\n            localizationService.localizeMany(['workflow_showDiff', 'workflow_viewAttachment', 'workflow_showDiff']),\r\n        ];\r\n        $q.all(promises).then(resp => {\r\n            let strings = [];\r\n            [this.loaded, strings] = resp;\r\n            this.showDiffStr = strings[0];\r\n            this.viewAttachmentBtnStr = strings[1];\r\n            this.showDiffBtnStr = strings[2];\r\n        });\r\n    }\r\n    $onInit() {\r\n        this.item = this.state ? this.state.currentTask : this.item;\r\n        this.showDiffBtn = !this.unlicensed && this.item.node.exists && !['cancelled', 'errored'].includes(this.item.cssStatus || '');\r\n        this.language = Umbraco.Sys.ServerVariables.Plumber.languageCount > 1 ? this.item.variantName : Umbraco.Sys.ServerVariables.Plumber.defaultCultureName;\r\n    }\r\n    showDiff() {\r\n        const diffOVerlay = {\r\n            view: `${this.viewsPath}overlays/workflow.diff.overlay.html`,\r\n            size: 'medium',\r\n            guid: this.getInstanceGuid(),\r\n            hideDescription: true,\r\n            title: `${this.showDiffStr}: ${this.item.node.name}`,\r\n            close: () => this.editorService.close()\r\n        };\r\n        this.editorService.open(diffOVerlay);\r\n    }\r\n    /**\r\n     * Only called on active tasks, so safe to check state as it will exist\r\n     * */\r\n    showGroupDetails() {\r\n        var _a, _b;\r\n        const overlayModel = {\r\n            view: `${Umbraco.Sys.ServerVariables.Plumber.viewsPath}overlays/groupdetail.overlay.html`,\r\n            submitButtonLabelKey: 'workflow_editGroup',\r\n            submitButtonStyle: 'primary',\r\n            hideSubmitButton: !((_a = this.state) === null || _a === void 0 ? void 0 : _a.isAdmin),\r\n            group: this.item.userGroup,\r\n            title: (_b = this.item.userGroup) === null || _b === void 0 ? void 0 : _b.name,\r\n            submit: model => {\r\n                this.overlayService.close();\r\n                this.plmbrGroupsResource.editGroup(model.group.groupId);\r\n            },\r\n            close: () => this.overlayService.close()\r\n        };\r\n        this.overlayService.open(overlayModel);\r\n    }\r\n    /**\r\n     * Since the component can receive either a task or instance, need to check the correct property for the guid\r\n     * */\r\n    getInstanceGuid() {\r\n        return this.item.hasOwnProperty('instanceGuid') ? this.item['instanceGuid'] : this.item['instance'].guid;\r\n    }\r\n}\r\nexports.ChangeDescriptionComponent = {\r\n    name: 'workflowChangeDescription',\r\n    transclude: true,\r\n    templateUrl: 'src/plumber/backoffice/components/changedescription/changedescription.html',\r\n    bindings: {\r\n        state: '<',\r\n        item: '<',\r\n    },\r\n    controller: WorkflowChangeDescription\r\n};\r\n\n},{}],5:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ChartComponent = void 0;\r\nclass WorkflowChart {\r\n    constructor($window, dateHelper, plmbrWorkflowResource) {\r\n        this.$window = $window;\r\n        this.dateHelper = dateHelper;\r\n        this.now = moment.utc().endOf('day');\r\n        this.totalApproved = 0;\r\n        this.totalCancelled = 0;\r\n        this.totalErrored = 0;\r\n        this.totalPending = 0;\r\n        this.loaded = false;\r\n        this.colorMap = {\r\n            approved: '#2bc37c',\r\n            pending: '#3544b1',\r\n            cancelled: '#eaddd5',\r\n            errored: '#ee5f5b',\r\n        };\r\n        this.$onChanges = change => {\r\n            var _a;\r\n            if ((_a = change.range) === null || _a === void 0 ? void 0 : _a.currentValue) {\r\n                this.getForRange();\r\n            }\r\n        };\r\n        this.emptySeries = (length) => Array.from({ length }, (_, i) => ({ x: this.earliest.clone().add(i, 'd'), y: 0 }));\r\n        this.buildChartSeries = items => {\r\n            this.showStatsBox = items.length > 0;\r\n            const validNames = ['Pending', 'Approved', 'Cancelled', 'Errored'];\r\n            const series = [];\r\n            const seriesNames = [];\r\n            this.earliest = this.now.clone().subtract(this.range - 1, 'd');\r\n            const pendingItems = this.emptySeries(this.range);\r\n            const approvedItems = this.emptySeries(this.range);\r\n            const cancelledItems = this.emptySeries(this.range);\r\n            const erroredItems = this.emptySeries(this.range);\r\n            const o = {\r\n                label: 'Pending',\r\n                borderColor: this.colorMap.pending,\r\n                backgroundColor: this.colorMap.pending,\r\n                data: pendingItems,\r\n                type: 'line',\r\n                fill: false\r\n            };\r\n            this.seconds = {\r\n                min: 0,\r\n                max: 0,\r\n                total: 0,\r\n            };\r\n            series.push(o);\r\n            seriesNames.push('Pending');\r\n            items.forEach(v => {\r\n                let statusName = (this.groupId ? v.statusName : v.status).split(' ')[0]; // `Pending Approval` becomes `Pending`\r\n                let cssStatus = v.cssStatus;\r\n                let completedDate = moment(v.completedDate ? v.completedDate.replace('Z', '') : null);\r\n                const createdDateKey = this.groupId ? 'requestedOn' : 'createdDate';\r\n                let createdDate = moment(v[createdDateKey].replace('Z', ''));\r\n                // rejected items are counted as pending\r\n                cssStatus = cssStatus === 'rejected' ? 'pendingapproval' : cssStatus;\r\n                statusName = statusName === 'Rejected' ? 'Pending' : statusName;\r\n                let seconds = (v.completedDate ? completedDate : moment()).diff(createdDate, 'seconds');\r\n                this.seconds.total += seconds;\r\n                this.seconds.max = Math.max(seconds, this.seconds.max);\r\n                this.seconds.min = Math.min(seconds, this.seconds.min);\r\n                if (!seriesNames.includes(statusName) && validNames.includes(statusName)) {\r\n                    const o = {\r\n                        label: statusName,\r\n                        borderColor: this.colorMap[cssStatus],\r\n                        backgroundColor: this.colorMap[cssStatus],\r\n                        data: cssStatus === 'approved' ? approvedItems : cssStatus === 'errored' ? erroredItems : cancelledItems\r\n                    };\r\n                    series.push(o);\r\n                    seriesNames.push(statusName);\r\n                }\r\n                const completedIndex = pendingItems.findIndex(item => item.x.dayOfYear() === completedDate.dayOfYear());\r\n                const createdIndex = pendingItems.findIndex(item => item.x.dayOfYear() === createdDate.dayOfYear());\r\n                pendingItems[createdIndex !== -1 ? createdIndex : 0].y += 1;\r\n                if (completedIndex !== -1) {\r\n                    pendingItems[completedIndex].y -= 1;\r\n                    if (cssStatus === 'approved') {\r\n                        this.totalApproved += 1;\r\n                        approvedItems[completedIndex].y += 1;\r\n                    }\r\n                    else if (cssStatus === 'cancelled') {\r\n                        this.totalCancelled += 1;\r\n                        cancelledItems[completedIndex].y += 1;\r\n                    }\r\n                    else if (cssStatus === 'errored') {\r\n                        this.totalErrored += 1;\r\n                        erroredItems[completedIndex].y += 1;\r\n                    }\r\n                    else if (cssStatus === 'pendingapproval') {\r\n                        this.totalPending += 1;\r\n                    }\r\n                }\r\n                else if (cssStatus === 'pendingapproval') {\r\n                    this.totalPending += 1;\r\n                }\r\n            });\r\n            // accumulate pending items\r\n            let pendingItemsData = series.find(x => x.label === 'Pending');\r\n            if (pendingItemsData) {\r\n                pendingItemsData.data.forEach((_, i) => {\r\n                    if (i > 0 && pendingItemsData) {\r\n                        pendingItemsData.data[i].y += pendingItemsData.data[i - 1].y;\r\n                    }\r\n                });\r\n            }\r\n            this.series = series;\r\n            this.averageSeconds = moment.duration(this.seconds.total / items.length, 'seconds');\r\n            this.maxSeconds = moment.duration(this.seconds.max, 'seconds');\r\n            this.minSeconds = moment.duration(this.seconds.min, 'seconds');\r\n            // finally, init the chart\r\n            this.drawChart();\r\n        };\r\n        this.getForRange = () => {\r\n            if (this.range > 0) {\r\n                this.totalApproved = 0;\r\n                this.totalCancelled = 0;\r\n                this.totalPending = 0;\r\n                this.totalErrored = 0;\r\n                this.seconds = {\r\n                    min: 0,\r\n                    max: 0,\r\n                    total: 0,\r\n                };\r\n                this.loaded = false;\r\n                // one less than range since current date is included\r\n                // if a group id exists, the endpoint is different\r\n                (this.groupId ?\r\n                    this.workflowResource.getAllTasksForGroupForRange(this.groupId, this.range - 1) :\r\n                    this.workflowResource.getAllInstancesForRange(this.range - 1))\r\n                    .then(resp => this.buildChartSeries(resp.items));\r\n            }\r\n        };\r\n        this.getActivity = filter => {\r\n            let statusValues = [\r\n                { key: 'Pending approval', value: '3' },\r\n                { key: 'Approved', value: '1' },\r\n                { key: 'Cancelled', value: '5' },\r\n                { key: 'Errored', value: '6' }\r\n            ];\r\n            const f = statusValues.find(x => x.key === filter);\r\n            const o = {\r\n                status: []\r\n            };\r\n            if (f) {\r\n                // if filtering pending, include rejected and resubmitted\r\n                if (filter !== 'Pending approval') {\r\n                    o.status = [f.value];\r\n                }\r\n                else {\r\n                    o.status = [3, 2, 7];\r\n                }\r\n            }\r\n            // if the key is NOT pending, filter by items completed inside the current range\r\n            if (filter !== 'Pending approval') {\r\n                let from = this.dateHelper.convertToServerStringTime(this.earliest, Umbraco.Sys.ServerVariables.application.serverTimeOffset);\r\n                o.completedFrom = from;\r\n            }\r\n            this.workflowResource.setActivityFilter(o);\r\n            this.$window.location = Umbraco.Sys.ServerVariables.umbracoSettings.umbracoPath +\r\n                '/#/workflow/history/overview';\r\n        };\r\n        this.drawChart = () => {\r\n            Chart.defaults.scale.gridLines.display = false;\r\n            Chart.defaults.scale.ticks.beginAtZero = true;\r\n            const chart = document.getElementById('chart');\r\n            if (!chart)\r\n                return;\r\n            const ctx = chart.getContext('2d');\r\n            if (this.chart && this.chart.destroy)\r\n                this.chart.destroy();\r\n            this.chart = new Chart(ctx, {\r\n                type: 'bar',\r\n                data: {\r\n                    labels: this.emptySeries(this.range).map(x => x.x.format('D MMM')),\r\n                    datasets: this.series\r\n                },\r\n                options: {\r\n                    scales: {\r\n                        yAxes: [\r\n                            {\r\n                                ticks: {\r\n                                    stepSize: 1,\r\n                                    maxTicksLimit: 5\r\n                                }\r\n                            }\r\n                        ],\r\n                        xAxes: [\r\n                            {\r\n                                time: {\r\n                                    stepSize: 4\r\n                                }\r\n                            }\r\n                        ]\r\n                    }\r\n                }\r\n            });\r\n            this.loaded = true;\r\n        };\r\n        this.workflowResource = plmbrWorkflowResource;\r\n    }\r\n}\r\nexports.ChartComponent = {\r\n    name: 'workflowChart',\r\n    transclude: true,\r\n    templateUrl: 'src/plumber/backoffice/components/chart/chart.html',\r\n    controller: WorkflowChart,\r\n    bindings: {\r\n        groupId: '<',\r\n        range: '<',\r\n    }\r\n};\r\n\n},{}],6:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.CommentsComponent = void 0;\r\nconst constants_1 = require(\"../../js/constants\");\r\nclass WorkflowComments {\r\n    constructor(localizationService, $sce, $rootScope) {\r\n        this.localizationService = localizationService;\r\n        this.$sce = $sce;\r\n        this.defaultMaxLength = 250;\r\n        this.maxLengthStr = '';\r\n        this.remainingStr = '';\r\n        this.$onInit = () => {\r\n            this.maxLength = this.maxLength || this.defaultMaxLength;\r\n            this.localizationService.localizeMany([this.labelKey || 'workflow_addComment', this.templateKey || '', 'workflow_commentRemaining', 'workflow_commentMaxLength'])\r\n                .then((resp) => {\r\n                this.labelStr = resp[0];\r\n                const template = resp[1];\r\n                this.remainingStr = resp[2];\r\n                this.maxLengthStr = resp[3].replace('%0%', this.maxLength.toString());\r\n                if (!template.startsWith('[') && !template.endsWith(']')) {\r\n                    this.comment = this.$sce.trustAsHtml(template);\r\n                    this.limitChars(template.length);\r\n                }\r\n                else {\r\n                    this.limitChars();\r\n                }\r\n            });\r\n        };\r\n        this.$onDestroy = () => {\r\n            this.onActioned();\r\n        };\r\n        /**\r\n         * Optionally provide a numeric value to set the initial counter\r\n         * Used when setting a template as the escaped string doesn't set the model\r\n         * until it is modified, but does have a length\r\n         * @param length\r\n         */\r\n        this.limitChars = (length) => {\r\n            var _a;\r\n            length = length || ((_a = this.comment) === null || _a === void 0 ? void 0 : _a.length);\r\n            if (length > this.maxLength) {\r\n                this.info = this.maxLengthStr;\r\n                this.comment = this.comment.substr(0, this.maxLength);\r\n                this.invalid = true;\r\n            }\r\n            else {\r\n                this.info = this.remainingStr.replace('%0%', (this.maxLength - (length || 0)).toString());\r\n                this.invalid = !length;\r\n            }\r\n        };\r\n        this.onActioned = $rootScope.$on(constants_1.constants.events.workflowActioned, () => {\r\n            this.limitChars();\r\n        });\r\n    }\r\n}\r\nconst template = `\r\n    <div class=\"umb-el-wrap\">\r\n        <label class=\"control-label\" for=\"workflowComment\">\r\n            {{ $ctrl.labelStr }}\r\n            <small ng-bind=\"$ctrl.info\"></small>\r\n        </label>\r\n        <div class=\"controls\">\r\n            <textarea\r\n                id=\"workflowComment\"\r\n                ng-model=\"$ctrl.comment\"\r\n                ng-change=\"$ctrl.limitChars()\"\r\n                no-dirty-check\r\n                umb-auto-focus\r\n                rows=\"5\"                     \r\n                class=\"umb-property-editor umb-textarea\"></textarea>\r\n        </div>\r\n    </div>`;\r\nexports.CommentsComponent = {\r\n    name: 'workflowComments',\r\n    transclude: true,\r\n    bindings: {\r\n        comment: '=',\r\n        maxLength: '<',\r\n        invalid: '=',\r\n        templateKey: '<',\r\n        labelKey: '<'\r\n    },\r\n    template: template,\r\n    controller: WorkflowComments\r\n};\r\n\n},{\"../../js/constants\":22}],7:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ConfigComponent = void 0;\r\nconst constants_1 = require(\"../../js/constants\");\r\nclass WorkflowConfig {\r\n    constructor($scope, $rootScope, $element, $location, editorService, plmbrGroupsResource, plmbrWorkflowResource) {\r\n        this.$scope = $scope;\r\n        this.$rootScope = $rootScope;\r\n        this.$element = $element;\r\n        this.$location = $location;\r\n        this.editorService = editorService;\r\n        this.sortOptions = {\r\n            axis: 'y',\r\n            containment: 'parent',\r\n            distance: 10,\r\n            opacity: 0.7,\r\n            tolerance: 'pointer',\r\n            scroll: true,\r\n            zIndex: 6000,\r\n            stop: () => { },\r\n        };\r\n        /**\r\n         * */\r\n        this.checkActiveType = () => {\r\n            this.activeType =\r\n                this.approvalPath.length || this.useNewNodePath ? 'content' :\r\n                    this.contentTypeApprovalPath.length ? 'type' :\r\n                        this.inherited.length ? 'inherited' : null;\r\n        };\r\n        this.workflowGroupsResource = plmbrGroupsResource;\r\n        this.workflowResource = plmbrWorkflowResource;\r\n        this.inherited = [];\r\n        this.approvalPath = [];\r\n        this.contentTypeApprovalPath = [];\r\n        this.sortOptions.stop = () => {\r\n            this.$scope.contentFlowForm.$setDirty();\r\n        };\r\n    }\r\n    /**\r\n     * Process the approvalPath object, then save it\r\n     */\r\n    save() {\r\n        // ensure everything being saved has the correct variant and appliesTo value\r\n        // need to make sure this doesn't break anything when the original path was inherited\r\n        // also ensures the permission is set correctly as the sort order may have changed\r\n        this.approvalPath.forEach((v, i) => {\r\n            v.variant = this.variant;\r\n            v.type = +this.appliesTo;\r\n            v.permission = i;\r\n        });\r\n        this.workflowResource.saveNodeConfig(this.node.id, this.approvalPath, this.variant, +this.appliesTo)\r\n            .then(() => {\r\n            this.$scope.contentFlowForm.$setPristine();\r\n            this.$element.inheritedData('$formController').$setPristine();\r\n            this.$rootScope.$emit(constants_1.constants.events.configSaved, { id: this.node.id });\r\n        });\r\n    }\r\n    /**\r\n     * */\r\n    openGroupOverlay() {\r\n        const model = {\r\n            view: Umbraco.Sys.ServerVariables.Plumber.viewsPath + '/overlays/grouppicker.overlay.html',\r\n            size: constants_1.constants.sizes.s,\r\n            title: 'Add workflow approval group/s',\r\n            approvalPath: this.approvalPath,\r\n            submit: (result) => {\r\n                result.selection.forEach(group => {\r\n                    this.add(group);\r\n                });\r\n                this.editorService.close();\r\n            },\r\n            close: () => this.editorService.close(),\r\n        };\r\n        this.editorService.open(model);\r\n    }\r\n    groupName(name, idx) {\r\n        return this.workflowGroupsResource.generateNameWithStage(name, idx);\r\n    }\r\n    editGroup(group) {\r\n        this.workflowGroupsResource.editGroup(group.groupId);\r\n    }\r\n    /**\r\n     * */\r\n    removeAll() {\r\n        this.approvalPath = [];\r\n        this.checkActiveType();\r\n        this.save();\r\n    }\r\n    /**\r\n     * Adds a stage to the approval flow\r\n     */\r\n    add(group) {\r\n        this.$scope.contentFlowForm.$setDirty();\r\n        this.approvalPath.push({\r\n            groupName: group.name,\r\n            nodeId: this.node.id,\r\n            permission: this.approvalPath.length,\r\n            groupId: group.groupId\r\n        });\r\n        this.checkActiveType();\r\n    }\r\n    /**\r\n     * Removes a stage from the approval flow\r\n     * @param {any} $event\r\n     * @param {any} item\r\n     */\r\n    remove(group) {\r\n        this.$scope.contentFlowForm.$setDirty();\r\n        const idx = this.approvalPath.findIndex(x => x.groupId === group.groupId);\r\n        this.approvalPath.splice(idx, 1);\r\n        this.approvalPath.forEach((v, i) => v.permission = i);\r\n        this.checkActiveType();\r\n        if (this.approvalPath.length === 0) {\r\n            this.save();\r\n        }\r\n    }\r\n    $onInit() {\r\n        const activeVariant = this.node.variants.find(x => x.active);\r\n        const isCreate = this.$location.search().create === 'true';\r\n        const variant = !isCreate && (activeVariant === null || activeVariant === void 0 ? void 0 : activeVariant.language) ? activeVariant.language.culture : this.$location.search().cculture;\r\n        this.variant = variant || Umbraco.Sys.ServerVariables.Plumber.defaultCulture;\r\n        this.useNewNodePath = !(activeVariant === null || activeVariant === void 0 ? void 0 : activeVariant.publishDate) && this.state.permissions.new.length > 0;\r\n        this.approvalPath = this.state.permissions.node;\r\n        this.contentTypeApprovalPath = this.state.permissions.contentType;\r\n        this.inherited = this.state.permissions.inherited;\r\n        this.newNodePath = this.state.permissions.new;\r\n        // set the applies to checkbox to match the node-level approvals (all will have the same value)\r\n        // if no node level, check if unpublish is required - if it is, type is publish+unpubish, else publish only\r\n        this.appliesTo = (this.approvalPath.length ? this.approvalPath[0].type : this.state.requireUnpublish ? 0 : 1).toString();\r\n        this.checkActiveType();\r\n        this.path = isCreate ? '-1' : this.node.path;\r\n    }\r\n}\r\nexports.ConfigComponent = {\r\n    name: 'workflowConfig',\r\n    transclude: true,\r\n    templateUrl: 'src/plumber/backoffice/components/config/config.html',\r\n    bindings: {\r\n        node: '<',\r\n        state: '<'\r\n    },\r\n    controller: WorkflowConfig\r\n};\r\n\n},{\"../../js/constants\":22}],8:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ContentTypeFlowComponent = void 0;\r\nconst constants_1 = require(\"../../js/constants\");\r\nclass WorkflowContentTypeFlow {\r\n    constructor(languageResource, plmbrGroupsResource, editorService) {\r\n        this.languageResource = languageResource;\r\n        this.editorService = editorService;\r\n        this.init = () => {\r\n            var _a;\r\n            if (this.model.type) {\r\n                this.model.type.variant = (_a = this.languages.find(x => x.isDefault)) === null || _a === void 0 ? void 0 : _a.culture;\r\n                this.variantChanged();\r\n                this.typeChanged();\r\n                this.model.type.permissions.forEach((p) => {\r\n                    if (p.condition) {\r\n                        // reopening the overlay has the already-split condition, so don't try doing it again...\r\n                        p.condition = typeof p.condition === 'string' ? p.condition.split(',') : p.condition;\r\n                        p.condition.forEach(c => {\r\n                            if (c) {\r\n                                this.conditions.push({\r\n                                    groupName: p.groupName,\r\n                                    groupId: p.groupId,\r\n                                    condition: c,\r\n                                    variant: p.variant\r\n                                });\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n                // binding to radiobutton requires a string value, sad face.\r\n                this.model.appliesTo = this.model.type.permissions[0].type.toString();\r\n            }\r\n            else {\r\n                this.isAdd = true;\r\n                this.model.appliesTo = \"0\";\r\n            }\r\n        };\r\n        /**\r\n         *\r\n         */\r\n        this.variantChanged = () => {\r\n            let variantPermissions = this.model.type.permissions.filter(p => p.variant === this.model.type.variant);\r\n            this.variantPermissionsCount = (variantPermissions ? variantPermissions : this.model.type.permissions.filter(p => p.variant === '*')).length;\r\n        };\r\n        /**\r\n         * */\r\n        this.typeChanged = () => {\r\n            var _a;\r\n            this.properties = this.model.type.properties;\r\n            this.model.type.variant = (_a = this.languages.find(x => x.isDefault)) === null || _a === void 0 ? void 0 : _a.culture;\r\n            this.variantChanged();\r\n        };\r\n        /**\r\n         *\r\n         */\r\n        this.addCondition = () => this.conditions.push({\r\n            variant: this.model.type.variant\r\n        });\r\n        /**\r\n         *\r\n         * @param {object} $event the click event\r\n         * @param {int} index the index of the condition\r\n         * @param {string} condition the condition value\r\n         */\r\n        this.removeCondition = ($event, index, condition) => {\r\n            $event.stopPropagation();\r\n            this.conditions.splice(index, 1);\r\n            this.model.type.permissions.forEach((p) => {\r\n                var _a;\r\n                if (p.contentTypeId === this.model.type.id\r\n                    && typeof p.condition === 'object'\r\n                    && ((_a = p.condition) === null || _a === void 0 ? void 0 : _a.some(x => x === condition))\r\n                    && p.variant === this.model.type.variant) {\r\n                    p.condition.splice(p.condition.indexOf(condition), 1);\r\n                }\r\n            });\r\n        };\r\n        /**\r\n         *\r\n         * @param {int} groupId id of the group assigned to the condition\r\n         * @param {string} condition rule representing the workflow stage condition\r\n         * @param {object} oldValue the previous condition\r\n         */\r\n        this.setCondition = (groupId, condition, currentValue) => {\r\n            const permission = this.model.type.permissions.find((p) => p.contentTypeId === this.model.type.id &&\r\n                p.variant === this.model.type.variant &&\r\n                p.groupId === groupId);\r\n            if (permission.condition) {\r\n                const existingIndex = permission.condition.indexOf(currentValue);\r\n                if (existingIndex > -1) {\r\n                    permission.condition[existingIndex] = condition;\r\n                }\r\n                else {\r\n                    permission.condition.push(condition);\r\n                }\r\n            }\r\n            else {\r\n                permission.condition = [condition];\r\n            }\r\n        };\r\n        /**\r\n         *\r\n         */\r\n        this.add = (group) => {\r\n            // when adding a new config, type will not exist.\r\n            if (!this.model.type) {\r\n                this.model.type = {\r\n                    variant: Umbraco.Sys.ServerVariables.Plumber.defaultCulture\r\n                };\r\n            }\r\n            this.model.type.permissions.push({\r\n                contentTypeId: this.model.type.id,\r\n                permission: this.model.type.permissions.filter((p) => p.variant === this.model.type.variant).length,\r\n                groupId: group.groupId,\r\n                groupName: group.name,\r\n                variant: this.model.type.variant\r\n            });\r\n            this.variantChanged();\r\n        };\r\n        /**\r\n         *\r\n         * @param {object} $event click\r\n         * @param {object} item a permissions item\r\n         */\r\n        this.remove = (item) => {\r\n            this.model.type.permissions.splice(this.model.type.permissions.indexOf(item), 1);\r\n            // also remove any conditions - can't do in the existing method as params are different.\r\n            if (this.conditions.length > 0) {\r\n                this.conditions = this.conditions.filter(c => c.groupId !== item.groupId);\r\n            }\r\n            this.variantChanged();\r\n        };\r\n        this.$onInit = () => {\r\n            this.languageResource.getAll()\r\n                .then(languages => {\r\n                this.languages = languages;\r\n                this.init();\r\n            });\r\n        };\r\n        this.workflowGroupsResource = plmbrGroupsResource;\r\n        this.properties = [];\r\n        this.conditions = [];\r\n        this.sortOptions = {\r\n            axis: 'y',\r\n            cursor: 'move',\r\n            handle: '.sort-handle',\r\n            stop: (e, ui) => {\r\n                const permissions = this.model.type.permissions.filter(p => p.variant === this.model.type.variant);\r\n                permissions.forEach((p, i) => {\r\n                    p.permission = i;\r\n                });\r\n            }\r\n        };\r\n    }\r\n    /**\r\n * */\r\n    openGroupOverlay() {\r\n        const model = {\r\n            view: Umbraco.Sys.ServerVariables.Plumber.viewsPath + '/overlays/grouppicker.overlay.html',\r\n            size: constants_1.constants.sizes.s,\r\n            title: 'Add workflow approval group/s',\r\n            approvalPath: this.model.type.permissions,\r\n            submit: (result) => {\r\n                result.selection.forEach(group => {\r\n                    this.add(group);\r\n                });\r\n                this.editorService.close();\r\n            },\r\n            close: () => this.editorService.close(),\r\n        };\r\n        this.editorService.open(model);\r\n    }\r\n    groupName(name, idx) {\r\n        return this.workflowGroupsResource.generateNameWithStage(name, idx);\r\n    }\r\n    editGroup(group) {\r\n        this.workflowGroupsResource.editGroup(group.groupId);\r\n    }\r\n}\r\nexports.ContentTypeFlowComponent = {\r\n    name: 'workflowContentTypeFlow',\r\n    transclude: true,\r\n    templateUrl: 'src/plumber/backoffice/components/contenttypeflow/contenttypeflow.html',\r\n    bindings: {\r\n        model: '='\r\n    },\r\n    controller: WorkflowContentTypeFlow\r\n};\r\n\n},{\"../../js/constants\":22}],9:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DatepickerComponent = void 0;\r\nclass Datepicker {\r\n    constructor(dateHelper, userService, localizationService) {\r\n        this.dateHelper = dateHelper;\r\n        this.userService = userService;\r\n        this.localizationService = localizationService;\r\n        this.$onChanges = () => {\r\n            if (this.date) {\r\n                this.change(this.date);\r\n            }\r\n            if (this.labelKey) {\r\n                this.localizationService.localize(this.labelKey)\r\n                    .then(label => this.label = label);\r\n            }\r\n        };\r\n        this.change = (dateStr) => {\r\n            this.date = this.dateHelper.convertToServerStringTime(moment(dateStr), Umbraco.Sys.ServerVariables.application.serverTimeOffset);\r\n            if (this.currentUser) {\r\n                this.setDateFormatted();\r\n            }\r\n            else {\r\n                this.userService.getCurrentUser().then((currentUser) => {\r\n                    this.currentUser = currentUser;\r\n                    this.setDateFormatted();\r\n                });\r\n            }\r\n        };\r\n        this.setDateFormatted = () => {\r\n            this.dateFormatted = this.dateHelper.getLocalDate(this.date, this.currentUser.locale, \"MMM Do YYYY, HH:mm\");\r\n        };\r\n        this.clear = () => {\r\n            this.date = null;\r\n            this.dateFormatted = null;\r\n        };\r\n        var now = new Date();\r\n        this.config = {\r\n            enableTime: true,\r\n            dateFormat: \"Y-m-d H:i\",\r\n            time_24hr: true,\r\n            defaultDate: null,\r\n            defaultHour: now.getHours(),\r\n            defaultMinute: now.getMinutes() + 5\r\n        };\r\n        this.clear();\r\n    }\r\n}\r\nexports.DatepickerComponent = {\r\n    name: 'workflowDatepicker',\r\n    bindings: {\r\n        date: '=',\r\n        label: '@',\r\n        labelKey: '@'\r\n    },\r\n    templateUrl: 'src/plumber/backoffice/components/datepicker/datepicker.html',\r\n    controller: Datepicker\r\n};\r\n\n},{}],10:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DayRangeComponent = void 0;\r\nclass DayRange {\r\n    constructor($timeout) {\r\n        this.$timeout = $timeout;\r\n        this.isOpen = false;\r\n    }\r\n    onClose() {\r\n        this.isOpen = false;\r\n        this.onChange({\r\n            range: this.value,\r\n        });\r\n    }\r\n}\r\nconst template = `\r\n    <div class=\"umb-filter\">\r\n        <button type=\"button\" class=\"btn btn-link flex p0\" ng-click=\"$ctrl.isOpen = true\">\r\n            <span><localize key=\"workflow_dateRange\">Range (days)</localize>:</span>\r\n            <span class=\"bold dib umb-filter__label\" ng-bind=\"$ctrl.value\"></span>\r\n            <span class=\"caret\" aria-hidden=\"true\"></span>\r\n        </button>\r\n\r\n        <umb-dropdown class=\"pull-right\" ng-if=\"$ctrl.isOpen\" on-close=\"$ctrl.onClose()\" style=\"z-index:9999\">\r\n            <umb-dropdown-item >\r\n                <label for=\"date-range\" class=\"sr-only\">Date range (days)</label>\r\n                <input type=\"number\"\r\n                        class=\"mb-0\"\r\n                        id=\"date-range\"\r\n                        ng-model=\"$ctrl.value\"\r\n                        ng-model-options=\"{ debounce: 300 }\"\r\n                        no-dirty-check />\r\n            </umb-dropdown-item>\r\n        </umb-dropdown>        \r\n    </div>`;\r\nexports.DayRangeComponent = {\r\n    name: 'workflowDayRange',\r\n    transclude: true,\r\n    template: template,\r\n    bindings: {\r\n        onChange: '&',\r\n        value: '='\r\n    },\r\n    controller: DayRange\r\n};\r\n\n},{}],11:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WorkflowDiffComponent = void 0;\r\nclass WorkflowDiff {\r\n    constructor(plmbrWorkflowResource) {\r\n        this.$onInit = () => {\r\n            this.workflowResource.getDiff(this.guid)\r\n                .then(resp => {\r\n                this.currentVersions = resp.diffs.currentVariants;\r\n                this.workflowVersions = resp.diffs.workflowVariants;\r\n                if (this.currentVersions.length === 1) {\r\n                    this.currentVersion = this.currentVersions[0];\r\n                }\r\n                if (this.workflowVersions.length === 1) {\r\n                    this.workflowVersion = this.workflowVersions[0];\r\n                }\r\n                if (this.workflowVersion && this.currentVersion) {\r\n                    this.createDiff();\r\n                }\r\n                this.loading = false;\r\n            });\r\n        };\r\n        this.workflowResource = plmbrWorkflowResource;\r\n        this.loading = true;\r\n    }\r\n    createDiff() {\r\n        this.diffs = [];\r\n        if (this.currentVersion.name !== this.workflowVersion.name) {\r\n            this.diffs.push({\r\n                label: 'Name',\r\n                diff: Diff.diffWords(this.currentVersion.name || '', this.workflowVersion.name || ''),\r\n                isObject: false\r\n            });\r\n        }\r\n        // extract all properties from the tabs and create new object for the diff\r\n        this.workflowVersion.tabs.forEach((tab, tabIndex) => {\r\n            tab.properties.forEach((workflowProperty, propertyIndex) => {\r\n                let currentProperty = this.currentVersion.tabs.length ?\r\n                    this.currentVersion.tabs[tabIndex].properties[propertyIndex] :\r\n                    { value: '' };\r\n                // we have to make properties storing values as object into strings (Grid, nested content, etc.)\r\n                if (workflowProperty.value instanceof Object) {\r\n                    workflowProperty.value = JSON.stringify(workflowProperty.value, null, 1);\r\n                    workflowProperty.isObject = true;\r\n                }\r\n                if (currentProperty.value instanceof Object) {\r\n                    currentProperty.value = JSON.stringify(currentProperty.value, null, 1);\r\n                    currentProperty.isObject = true;\r\n                }\r\n                // diff requires a string\r\n                workflowProperty.value = workflowProperty.value ? workflowProperty.value + '' : '';\r\n                currentProperty.value = currentProperty.value ? currentProperty.value + '' : '';\r\n                const diff = Diff.diffWords(currentProperty.value, workflowProperty.value);\r\n                this.diffs.push({\r\n                    label: workflowProperty.label,\r\n                    diff: diff,\r\n                    isObject: (workflowProperty.isObject || currentProperty.isObject) ? true : false\r\n                });\r\n            });\r\n        });\r\n    }\r\n    variantDiff() {\r\n        this.workflowVersion = this.workflowVersions.find(x => x.language.culture === this.activeVariant.culture);\r\n        this.currentVersion = this.currentVersions.find(x => x.language.culture === this.activeVariant.culture);\r\n        // if no current version, assume it's an unpublished variant, so all values are new\r\n        if (!this.currentVersion) {\r\n            this.currentVersion = {\r\n                name: '',\r\n                tabs: []\r\n            };\r\n        }\r\n        this.createDiff();\r\n    }\r\n    hasDiffs() {\r\n        return this.workflowVersions && this.workflowVersions.some(x => x.name !== null && x.tabs.length)\r\n            && this.currentVersions && this.currentVersions.some(x => x.name !== null && x.tabs.length);\r\n    }\r\n}\r\nexports.WorkflowDiffComponent = {\r\n    name: 'workflowDiff',\r\n    transclude: true,\r\n    templateUrl: 'src/plumber/backoffice/components/diff/workflowdiff.html',\r\n    bindings: {\r\n        guid: '<',\r\n    },\r\n    controller: WorkflowDiff\r\n};\r\n\n},{}],12:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.generateFilters = exports.FilterPickerComponent = void 0;\r\nconst constants_1 = require(\"../../js/constants\");\r\nclass FilterPicker {\r\n    constructor(editorService, dateHelper, localizationService) {\r\n        this.editorService = editorService;\r\n        this.dateHelper = dateHelper;\r\n        this.filters = {};\r\n        localizationService.localize('workflow_filters')\r\n            .then(resp => this.filterStr = resp);\r\n    }\r\n    showFilters() {\r\n        const overlayModel = {\r\n            view: `${Umbraco.Sys.ServerVariables.Plumber.viewsPath}overlays/filterpicker.overlay.html`,\r\n            size: constants_1.constants.sizes.s,\r\n            title: this.filterStr,\r\n            filters: this.filters,\r\n            disabledFilters: this.disabledFilters,\r\n            nodeView: this.nodeView,\r\n            submit: filters => {\r\n                this.filters = filters;\r\n                generateFilters(this.filters, this.nodeView, this.dateHelper);\r\n                this.onChange({\r\n                    filters: this.filters,\r\n                });\r\n                this.editorService.close();\r\n            },\r\n            close: () => this.editorService.close()\r\n        };\r\n        this.editorService.open(overlayModel);\r\n    }\r\n}\r\nconst template = `\r\n    <div class=\"umb-filter mr-2\">\r\n        <button type=\"button\" class=\"btn btn-link flex p0\" ng-click=\"$ctrl.showFilters()\">\r\n            <span>{{ $ctrl.filterStr }}: </span>\r\n            <span class=\"bold dib umb-filter__label\">{{ $ctrl.filters.count || '0' }}</span>\r\n            <span class=\"caret\" aria-hidden=\"true\"></span>\r\n        </button>\r\n    </div>`;\r\nexports.FilterPickerComponent = {\r\n    name: 'workflowFilterPicker',\r\n    transclude: true,\r\n    template: template,\r\n    bindings: {\r\n        onChange: '&',\r\n        filters: '=',\r\n        disabledFilters: '<',\r\n        nodeView: '<',\r\n    },\r\n    controller: FilterPicker\r\n};\r\n/**\r\n     * parse the filter object into comma-separated key and value strings\r\n     * */\r\nfunction generateFilters(filters, nodeView, dateHelper) {\r\n    var _a;\r\n    let keys = [];\r\n    let values = [];\r\n    let now = dateHelper.convertToServerStringTime(moment(new Date()), Umbraco.Sys.ServerVariables.application.serverTimeOffset);\r\n    if (filters.node) {\r\n        keys.push('nodeId');\r\n        values.push(filters.node.id);\r\n    }\r\n    if (filters.user) {\r\n        keys.push('authorUserId');\r\n        values.push(filters.user.id);\r\n    }\r\n    if (filters.variant) {\r\n        keys.push('variant');\r\n        values.push(filters.variant);\r\n    }\r\n    if (filters.type) {\r\n        keys.push('type');\r\n        values.push(filters.type);\r\n    }\r\n    if ((_a = filters.status) === null || _a === void 0 ? void 0 : _a.length) {\r\n        keys.push('status');\r\n        values.push(filters.status.join('|'));\r\n    }\r\n    if (filters.createdFrom) {\r\n        keys.push('createdDate');\r\n        values.push(filters.createdFrom + '|' + (filters.createdTo || now));\r\n    }\r\n    if (filters.completedFrom) {\r\n        keys.push('completedDate');\r\n        values.push(filters.completedFrom + '|' + (filters.completedTo || now));\r\n    }\r\n    filters.keys = keys.join(',');\r\n    filters.values = values.join(',');\r\n    filters.count = (keys.length - (nodeView ? 1 : 0)) || 0;\r\n}\r\nexports.generateFilters = generateFilters;\r\n\n},{\"../../js/constants\":22}],13:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WorkflowGroupPickerComponent = void 0;\r\nclass WorkflowGroupPicker {\r\n    constructor(plmbrGroupsResource) {\r\n        this.loading = false;\r\n        this.workflowGroupsResource = plmbrGroupsResource;\r\n    }\r\n    $onInit() {\r\n        if (!this.model.selection) {\r\n            this.model.selection = [];\r\n        }\r\n        this.loading = true;\r\n        this.workflowGroupsResource.getAllSlim()\r\n            .then(groups => {\r\n            this.groups = groups.items;\r\n            this.updateAvailableGroups();\r\n            this.loading = false;\r\n        });\r\n    }\r\n    updateAvailableGroups() {\r\n        this.groups.forEach(g => {\r\n            var _a;\r\n            g.selected = (_a = this.model.approvalPath) === null || _a === void 0 ? void 0 : _a.some(x => x.groupId === g.groupId);\r\n        });\r\n    }\r\n    selectUserGroup(group) {\r\n        if (!group.selected) {\r\n            group.selected = true;\r\n            this.model.selection.push(group);\r\n        }\r\n        else {\r\n            const idx = this.model.selection.findIndex(x => x.groupId === group.groupId);\r\n            if (idx !== -1) {\r\n                this.model.selection[idx].selected = false;\r\n                this.model.selection.splice(idx, 1);\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.WorkflowGroupPickerComponent = {\r\n    name: 'workflowGroupPicker',\r\n    transclude: true,\r\n    templateUrl: 'src/plumber/backoffice/components/grouppicker/grouppicker.html',\r\n    bindings: {\r\n        model: '='\r\n    },\r\n    controller: WorkflowGroupPicker\r\n};\r\n\n},{}],14:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.HistoryComponent = void 0;\r\nconst constants_1 = require(\"../../js/constants\");\r\nconst sorter_1 = require(\"../../js/models/sorter\");\r\nclass History {\r\n    constructor($scope, $rootScope, editorState, plmbrWorkflowResource) {\r\n        this.nodeView = false;\r\n        this.disabledFilters = [];\r\n        this.perPage = 10;\r\n        /**\r\n         *\r\n         */\r\n        this.fetch = (perPage = this.perPage) => {\r\n            this.model = {\r\n                perPage,\r\n                currentPage: 1,\r\n                filters: this.filters,\r\n                nodeView: this.nodeView,\r\n                handler: this.workflowResource.getAllInstances,\r\n                direction: sorter_1.SortDirection.DESC,\r\n            };\r\n        };\r\n        this.workflowResource = plmbrWorkflowResource;\r\n        this.activityFilter = this.workflowResource.getActivityFilter();\r\n        this.workflowResource.setTreeState();\r\n        if (this.activityFilter !== null && Object.values(this.activityFilter).length > 0) {\r\n            this.filters = this.activityFilter;\r\n        }\r\n        else {\r\n            this.filters = {\r\n                node: editorState.getCurrent(),\r\n                status: []\r\n            };\r\n        }\r\n        this.nodeView = !!this.filters.node;\r\n        this.onActioned = $rootScope.$on(constants_1.constants.events.workflowActioned, (_, data) => {\r\n            if (this.filters.node && this.filters.node.id === data.nodeId) {\r\n                this.fetch();\r\n            }\r\n        });\r\n        this.fetch();\r\n        $scope.$on('$destroy', () => {\r\n            this.onActioned();\r\n            this.workflowResource.setActivityFilter(null);\r\n        });\r\n    }\r\n    onFilter(filters) {\r\n        this.filters = filters;\r\n        this.fetch();\r\n    }\r\n}\r\nexports.HistoryComponent = {\r\n    name: 'workflowHistory',\r\n    templateUrl: 'src/plumber/backoffice/components/history/history.html',\r\n    bindings: {\r\n        disabledFilters: '=',\r\n    },\r\n    controller: History\r\n};\r\n\n},{\"../../js/constants\":22,\"../../js/models/sorter\":31}],15:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WorkflowInstancesComponent = void 0;\r\nconst models_1 = require(\"../../js/models\");\r\nconst tasklist_base_1 = require(\"../../js/models/tasklist.base\");\r\nconst filterpicker_1 = require(\"../filterpicker/filterpicker\");\r\nclass WorkflowInstances extends tasklist_base_1.TaskListBase {\r\n    constructor($scope, $rootScope, plmbrActionsService, notificationsService, dateHelper) {\r\n        super($scope, $rootScope, notificationsService, plmbrActionsService);\r\n        this.dateHelper = dateHelper;\r\n        this.sorter = new models_1.Sorter(() => this.fetch());\r\n        this.pagination = new models_1.Pagination(() => this.fetch(), 5);\r\n        this.sort = (key) => this.sorter.update(key);\r\n    }\r\n    $onChanges(change) {\r\n        if (change.model.currentValue) {\r\n            this.model = change.model.currentValue;\r\n            this.pagination.perPage = this.model.perPage || this.pagination.perPage;\r\n            // allow setting up/down since history should be oldest first, others should be newest\r\n            if (this.model.direction) {\r\n                this.sorter.setDirection(this.model.direction);\r\n            }\r\n            this.fetch();\r\n        }\r\n    }\r\n    fetch() {\r\n        var _a, _b;\r\n        const query = {\r\n            page: this.pagination.pageNumber,\r\n            count: this.pagination.perPage,\r\n            sortBy: this.sorter.sortBy,\r\n            sortDirection: this.sorter.sortDirectionString,\r\n        };\r\n        // if filters are passed down from the history view, ensure they are up to date\r\n        filterpicker_1.generateFilters(this.model.filters, this.model.nodeView, this.dateHelper);\r\n        if ((_a = this.model.filters) === null || _a === void 0 ? void 0 : _a.keys)\r\n            query.filters = this.model.filters.keys;\r\n        if ((_b = this.model.filters) === null || _b === void 0 ? void 0 : _b.values)\r\n            query.filterValues = this.model.filters.values;\r\n        if (this.model.groupId)\r\n            query.groupId = this.model.groupId;\r\n        this.doFetch(query, this.pagination);\r\n    }\r\n    ;\r\n    statusColor(item) {\r\n        switch (item.cssStatus) {\r\n            case 'approved':\r\n                return 'success'; //approved\r\n            case 'not':\r\n            case 'cancelled':\r\n                return 'gray'; //cancelled\r\n            case 'errored':\r\n                return 'danger'; //error \r\n            case 'rejected':\r\n                return 'warning';\r\n            default:\r\n                return 'primary'; //resubmitted, pending\r\n        }\r\n    }\r\n}\r\nexports.WorkflowInstancesComponent = {\r\n    name: 'workflowInstances',\r\n    transclude: true,\r\n    templateUrl: 'src/plumber/backoffice/components/instances/instances.html',\r\n    bindings: {\r\n        model: '<',\r\n    },\r\n    controller: WorkflowInstances\r\n};\r\n\n},{\"../../js/models\":29,\"../../js/models/tasklist.base\":33,\"../filterpicker/filterpicker\":12}],16:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.PageSizeComponent = void 0;\r\nclass PageSize {\r\n    constructor() {\r\n        this.value = 10;\r\n        this.isOpen = false;\r\n        this.options = [5, 10, 20, 25];\r\n    }\r\n    select(perPage) {\r\n        this.isOpen = false;\r\n        this.value = perPage;\r\n        this.onChange({ perPage });\r\n    }\r\n}\r\nconst template = `\r\n    <div class=\"umb-filter\">\r\n        <button type=\"button\" class=\"btn btn-link flex p0\" ng-click=\"$ctrl.isOpen = true\">\r\n            <span><localize key=\"workflow_pageSize\">Page size</localize>:</span>\r\n            <span class=\"bold dib umb-filter__label\" ng-bind=\"$ctrl.value\"></span>\r\n            <span class=\"caret\" aria-hidden=\"true\"></span>\r\n        </button>\r\n\r\n        <umb-dropdown class=\"pull-right\" ng-if=\"$ctrl.isOpen\" on-close=\"$ctrl.isOpen = false\" style=\"z-index:9999\">\r\n            <umb-dropdown-item ng-repeat=\"option in $ctrl.options\">\r\n                <button type=\"button\" ng-click=\"$ctrl.select(option)\" ng-bind=\"::option\"></button>                \r\n            </umb-dropdown-item>\r\n        </umb-dropdown>\r\n    </div>`;\r\nexports.PageSizeComponent = {\r\n    name: 'workflowPageSize',\r\n    transclude: true,\r\n    template: template,\r\n    bindings: {\r\n        onChange: '&',\r\n        value: '='\r\n    },\r\n    controller: PageSize\r\n};\r\n\n},{}],17:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ProgressComponent = void 0;\r\nclass WorkflowProgress {\r\n    constructor(localizationService) {\r\n        this.localizationService = localizationService;\r\n        this.permissions = [];\r\n        this.totalSteps = 0;\r\n        this.addPendingTasks = () => {\r\n            // can't count steps, as reject/resubmit use the same step number - instead, get unique step numbers\r\n            const activeSteps = this.tasks.map(t => t.currentStep).filter((v, i, s) => s.indexOf(v) === i);\r\n            // if permissions are missing (group deleted), stuff a mock permission in at the correct index\r\n            if (this.permissions.length < this.totalSteps) {\r\n                let missingIndexes = [];\r\n                this.permissions.forEach(p => {\r\n                    missingIndexes[p.permission] = p;\r\n                });\r\n                for (let i = 0; i < missingIndexes.length; i += 1) {\r\n                    if (!missingIndexes[i]) {\r\n                        this.permissions.splice(i, 0, {\r\n                            groupName: 'Group does not exist'\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            if (activeSteps.length < this.totalSteps) {\r\n                for (let i = activeSteps.length; i < this.totalSteps; i += 1) {\r\n                    this.tasks.push({\r\n                        statusName: this.pendingApprovalStr,\r\n                        currentStep: i,\r\n                        groupName: this.permissions[i] ? this.permissions[i].groupName : ''\r\n                    });\r\n                }\r\n            }\r\n            // if a rejected task is the last in its step, stuff a fake pending resubmission and pending approval task\r\n            // the responsible user will be the requestedBy value on the task\r\n            this.tasks.forEach((task, i) => {\r\n                if (task.status === 2 && (this.tasks[i + 1] && this.tasks[i + 1].currentStep === task.currentStep + 1 || !this.tasks[i + 1])) {\r\n                    this.tasks.splice(i + 1, 0, {\r\n                        statusName: this.awaitingResubmissionStr,\r\n                        currentStep: task.currentStep,\r\n                        cssStatus: 'pendingapproval',\r\n                        groupName: task.requestedBy\r\n                    });\r\n                }\r\n            });\r\n            // once everything is up to date, iterate again, and set the group classes\r\n            // if a rejection string hits more than 5 stages, collapse these to avoid the progress bar growing horribly\r\n            this.tasks.forEach((task, i) => {\r\n                const prev = this.tasks[i - 1];\r\n                const next = this.tasks[i + 1];\r\n                let str = '';\r\n                if (prev && task.currentStep !== prev.currentStep || !prev) {\r\n                    str = 'grouped-start';\r\n                }\r\n                if (next) {\r\n                    str += task.currentStep !== next.currentStep ? ' grouped-end' : ' grouped';\r\n                }\r\n                else {\r\n                    str += ' grouped-end';\r\n                }\r\n                task.groupClass = str;\r\n            });\r\n            // and iterate again :( to find each set of grouped tasks, remove the extras\r\n            // to be left with grouped-start, collapsed, grouped-end\r\n            this.tasks.forEach((task, i) => {\r\n                if (task.groupClass !== 'grouped-start grouped')\r\n                    return;\r\n                // find the next grouped-end task\r\n                const endTaskIndex = this.tasks.findIndex((t, j) => { var _a; return j > i && ((_a = t.groupClass) === null || _a === void 0 ? void 0 : _a.includes('grouped-end')); });\r\n                // if it's more than two tasks away, we collapse to three tasks\r\n                if (endTaskIndex - i < 3)\r\n                    return;\r\n                const pad = {\r\n                    cssStatus: 'collapsed',\r\n                    groupClass: 'grouped',\r\n                    currentStep: 0,\r\n                    groupName: (this.plusMoreStr || 'plus %0% more').replace('%0%', (endTaskIndex - i - 1).toString())\r\n                };\r\n                this.tasks.splice(i + 1, 0, pad);\r\n                this.tasks.splice(i + 2, endTaskIndex - i - 1);\r\n            });\r\n        };\r\n        this.$onChanges = changes => {\r\n            if (changes.instance.currentValue) {\r\n                const instance = changes.instance.currentValue;\r\n                this.tasks = instance.tasks.sort((a, b) => a.currentStep > b.currentStep);\r\n                this.totalSteps = instance.totalSteps;\r\n                this.permissions = instance.permissions;\r\n                this.localizationService.localizeMany(['workflow_pendingApproval', 'workflow_awaitingResubmission', 'workflow_plusMore'])\r\n                    .then((resp) => {\r\n                    this.pendingApprovalStr = resp[0];\r\n                    this.awaitingResubmissionStr = resp[1];\r\n                    this.plusMoreStr = resp[2];\r\n                    this.addPendingTasks();\r\n                });\r\n            }\r\n        };\r\n    }\r\n}\r\nconst template = `          \r\n    <div ng-repeat=\"task in $ctrl.tasks\"         \r\n        class=\"progress-step {{ task.cssStatus || 'future-step' }}\">\r\n        <div class=\"{{ task.groupClass }}\">\r\n            <span class=\"marker\">\r\n                <i class=\"icon-\"></i>\r\n            </span>\r\n            <span class=\"tooltip {{ ::task.cssStatus }}\">\r\n                <span ng-bind=\"::task.statusName\"></span>\r\n                {{ ::(task.status === 7 ? task.completedBy : task.groupName )}}\r\n            </span>\r\n        </div>\r\n    </div>`;\r\nexports.ProgressComponent = {\r\n    name: 'workflowProgress',\r\n    transclude: true,\r\n    bindings: {\r\n        instance: '<',\r\n    },\r\n    template: template,\r\n    controller: WorkflowProgress\r\n};\r\n\n},{}],18:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SchedulingComponent = void 0;\r\nexports.SchedulingComponent = {\r\n    name: 'workflowScheduling',\r\n    transclude: true,\r\n    template: ` \r\n        <umb-box class=\"workflow\"> \r\n            <umb-box-header title-key=\"workflow_scheduling\"></umb-box-header>\r\n            <umb-box-content>\r\n                <p ng-bind=\"::$ctrl.item.type\"></p>\r\n                <div class=\"d-flex items-center\" ng-if=\"::$ctrl.scheduledDatePassed\">\r\n                    <umb-icon icon=\"icon-alert\" class=\"schedule-warning-icon\"></umb-icon>\r\n                    <small>\r\n                        <localize key=\"workflow_schedulePassed\">Scheduled date passed before the workflow was completed. Content will be released when the current workflow is completed.</localize> \r\n                    </small>\r\n                </div>\r\n            </umb-box-content>\r\n        </umb-box>`,\r\n    bindings: {\r\n        item: '<'\r\n    },\r\n    controller: class WorkflowScheduling {\r\n        $onInit() {\r\n            const scheduledDate = new Date(this.item.scheduledDate);\r\n            const now = new Date();\r\n            this.scheduledDatePassed = scheduledDate < now && this.item.status === 3;\r\n        }\r\n    }\r\n};\r\n\n},{}],19:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SubmitWorkflowComponent = void 0;\r\nconst constants_1 = require(\"../../js/constants\");\r\nclass WorkflowSubmit {\r\n    constructor($scope, $timeout, $rootScope, $element, $sce, $location, editorState, editorService, dateHelper, fileManager, userService, formHelper, notificationsService, contentResource, localizationService, languageResource, navigationService, plmbrActionsService) {\r\n        this.$timeout = $timeout;\r\n        this.$rootScope = $rootScope;\r\n        this.$element = $element;\r\n        this.$sce = $sce;\r\n        this.$location = $location;\r\n        this.editorState = editorState;\r\n        this.editorService = editorService;\r\n        this.dateHelper = dateHelper;\r\n        this.fileManager = fileManager;\r\n        this.formHelper = formHelper;\r\n        this.notificationsService = notificationsService;\r\n        this.contentResource = contentResource;\r\n        this.localizationService = localizationService;\r\n        this.languageResource = languageResource;\r\n        this.navigationService = navigationService;\r\n        this.events = () => {\r\n            // this.state is null when submit initially loads after a process completes\r\n            this.onButtonStateChanged = this.$rootScope.$on(constants_1.constants.events.buttonStateChanged, (_, data) => {\r\n                if (this.state && data.id === this.state.nodeId) {\r\n                    this.buttonState = data.state;\r\n                    this.setSubButtons();\r\n                    this.setDefaultButton();\r\n                }\r\n            });\r\n            this.onAppActive = this.$rootScope.$on(constants_1.constants.events.workflowAppActive, (_, data) => {\r\n                if (this.state && data.id === this.state.nodeId) {\r\n                    this.action = data.action || constants_1.constants.actions.publish;\r\n                    // if we need workflowed unpublish actions, set the sub button to the opposite of the current action\r\n                    this.setSubButtons();\r\n                    this.setDefaultButton();\r\n                }\r\n            });\r\n            this.onActioned = this.$rootScope.$on(constants_1.constants.events.workflowActioned, () => {\r\n                this.comment = null;\r\n            });\r\n        };\r\n        this.setSubButtons = () => {\r\n            // if we need workflowed unpublish actions, set the sub button to the opposite of the current action\r\n            // if no unpublish permissions exist, disable the workflow and show the overlay\r\n            if (this.state.requireUnpublish) {\r\n                let subButton = this.action === constants_1.constants.actions.publish && this.state.hasUnpublishPermissions ? this.unpublishBtn\r\n                    : this.action === constants_1.constants.actions.unpublish ? this.publishBtn\r\n                        : undefined;\r\n                this.subButtons = subButton ? [subButton] : [];\r\n                this.noUnpublishPermissions = this.action === constants_1.constants.actions.unpublish && !this.state.hasUnpublishPermissions;\r\n            }\r\n            else {\r\n                this.subButtons = [];\r\n                this.noUnpublishPermissions = false;\r\n            }\r\n        };\r\n        this.setDefaultButton = () => {\r\n            this.defaultButton = this.action === constants_1.constants.actions.publish ? this.publishBtn : this.unpublishBtn;\r\n        };\r\n        this.$onInit = () => {\r\n            this.labelKey = this.action === constants_1.constants.actions.publish ? 'workflow_describeChanges' : 'workflow_addComment';\r\n            this.templateKey = `workflowCommentTemplates_${this.editorState.current.contentTypeAlias}`;\r\n            this.localizationService.localizeMany([\r\n                'workflow_invalidContent',\r\n                'workflow_noUnpublishPermissions'\r\n            ])\r\n                .then(result => {\r\n                let [invalidContent, noUnpublishPermissions] = result;\r\n                this.invalidContentStr = invalidContent;\r\n                if (noUnpublishPermissions) {\r\n                    document.body.style.setProperty('--plumberNoUnpublishPermissions', `'${noUnpublishPermissions}'`);\r\n                }\r\n                this.publishBtn = {\r\n                    labelKey: 'workflow_publishButton',\r\n                    buttonStyle: constants_1.constants.states.success,\r\n                    handler: () => this.initiate(true),\r\n                    shortcut: 'ctrl+p'\r\n                };\r\n                this.unpublishBtn = {\r\n                    labelKey: 'workflow_unpublishButton',\r\n                    buttonStyle: constants_1.constants.states.success,\r\n                    handler: () => this.initiate(false),\r\n                    shortcut: 'ctrl+u'\r\n                };\r\n                this.setSubButtons();\r\n                this.setDefaultButton();\r\n            });\r\n        };\r\n        this.setScheduledDate = (variant, isPublish) => {\r\n            if (!this.scheduledDate)\r\n                return;\r\n            const dateToSet = isPublish ? 'releaseDate' : 'expireDate';\r\n            if (variant[dateToSet] === this.scheduledDate) {\r\n                return;\r\n            }\r\n            variant[dateToSet] = this.scheduledDate;\r\n            variant[`${dateToSet}Formatted`] = this.scheduledDateFormatted;\r\n            variant.isDirty = true;\r\n        };\r\n        this.initiate = (publish) => {\r\n            let variant = [];\r\n            if (!this.formHelper.submitForm({\r\n                scope: this.scope,\r\n                action: 'save'\r\n            })) {\r\n                this.notificationsService.warning(this.invalidContentStr);\r\n                return;\r\n            }\r\n            // if content is dirty, save it then call back into this function\r\n            // since content was saved, it's no longer dirty, so we won't hit this.\r\n            if (this.scope.contentForm.$dirty) {\r\n                // if nested content exists, it needs to be syncd back\r\n                // can trigger this by closing any open nc instances\r\n                // it's horrible, but it works. Lots of timeouts, these are required\r\n                // to allow changes to propagate before acting on the expected data\r\n                const ncHeaders = document.querySelectorAll('.umb-nested-content__item--active .umb-nested-content__header-bar');\r\n                for (let openNc of Object.values(ncHeaders)) {\r\n                    this.$timeout(() => openNc.click());\r\n                }\r\n                this.buttonState = constants_1.constants.states.busy;\r\n                this.$timeout(() => {\r\n                    this.scope.content.variants.forEach(v => v.save = v.isDirty || v.active);\r\n                    let isNew = this.scope.content.id === 0;\r\n                    // need to store the date to check the auto-save completed\r\n                    // there's no other way to identify a successful, other than checking\r\n                    // notifications, but that relies on language, and knowing the notification text\r\n                    const updateDate = this.scope.content.updateDate;\r\n                    this.contentResource.save(this.scope.content, isNew, this.fileManager.getFiles(), false)\r\n                        .then(newNode => {\r\n                        // update date didn't change, save was cancelled or failed\r\n                        if (newNode.updateDate === updateDate) {\r\n                            this.buttonState = constants_1.constants.states.init;\r\n                            // notifications aren't displayed unless we ask for them...\r\n                            newNode.notifications.forEach(n => this.notificationsService.add(n));\r\n                            return;\r\n                        }\r\n                        this.$element.inheritedData('$formController').$setPristine();\r\n                        if (isNew) {\r\n                            this.scope.content.id = newNode.id;\r\n                            this.state.nodeId = newNode.id;\r\n                            //clear the query strings\r\n                            this.navigationService.clearSearch([\"cculture\", \"csegment\"]);\r\n                            this.navigationService.setSoftRedirect();\r\n                            //change to new path\r\n                            this.$location.path(`/content/content/edit/${this.scope.content.id}`);\r\n                            //don't add a browser history for this\r\n                            this.$location.replace();\r\n                            this.navigationService.syncTree({\r\n                                tree: 'content',\r\n                                path: newNode.path.split(',').map(x => parseInt(x)),\r\n                                activate: true,\r\n                            }).then(() => this.initiate(publish));\r\n                        }\r\n                        else {\r\n                            this.initiate(publish);\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n            else {\r\n                // provide variants as an array\r\n                if (this.selectedVariantName === 'all') {\r\n                    variant = this.variants.map(v => v.language.culture);\r\n                }\r\n                else {\r\n                    variant = [this.selectedVariantName];\r\n                }\r\n                // if release date has changed, assign it to all variants \r\n                // this is a UI change only as the schedule is updated on the server\r\n                // as part of creating the workflow instance\r\n                if (variant.includes('*')) {\r\n                    this.scope.content.variants.forEach(v => this.setScheduledDate(v, publish));\r\n                }\r\n                else {\r\n                    variant.forEach(variantName => this.setScheduledDate(this.scope.content.variants.find(v => v.language.culture === variantName), publish));\r\n                }\r\n                this.actionsService.initiate({\r\n                    nodeId: this.scope.content.id,\r\n                    contentTypeId: this.scope.content.contentTypeId,\r\n                    comment: this.comment,\r\n                    scheduledDate: this.scheduledDate,\r\n                    publish,\r\n                    variant,\r\n                    attachmentId: this.attachment ? this.attachment.id : null\r\n                });\r\n                this.comment = null;\r\n            }\r\n        };\r\n        this.filepicker = () => {\r\n            let currentSelection;\r\n            angular.copy(this.attachment, currentSelection);\r\n            const filePickerOptions = {\r\n                selection: currentSelection,\r\n                multiPicker: false,\r\n                submit: model => {\r\n                    this.attachment = model.selection[0];\r\n                    this.editorService.close();\r\n                },\r\n                close: () => {\r\n                    this.editorService.close();\r\n                }\r\n            };\r\n            this.editorService.mediaPicker(filePickerOptions);\r\n        };\r\n        this.$onChanges = changes => {\r\n            var _a, _b;\r\n            if (changes.state && changes.state.currentValue) {\r\n                if (!this.state.isActive) {\r\n                    this.comment = null;\r\n                }\r\n            }\r\n            // when state is updated, not intialized, reset the buttons\r\n            if (changes.state && changes.state.previousValue) {\r\n                this.setSubButtons();\r\n                this.setDefaultButton();\r\n            }\r\n            if (changes.scope && changes.scope.currentValue) {\r\n                this.variants = this.scope.content.variants;\r\n                // invariant node\r\n                if (this.variants.length === 1 && this.variants[0].language === null) {\r\n                    this.selectedVariantName = '*';\r\n                }\r\n                // variant node \r\n                else {\r\n                    const isCreate = this.$location.search().create === 'true';\r\n                    if (this.variants && this.variants.filter(x => x.language).length && !isCreate) {\r\n                        this.currentVariant = this.variants.find(v => v.active);\r\n                        this.defaultVariant = this.variants.find(v => v.language.isDefault);\r\n                        this.selectedVariantName = (_b = (_a = this.currentVariant) === null || _a === void 0 ? void 0 : _a.language.culture) !== null && _b !== void 0 ? _b : ''; // set the selection to the current displayed variant\r\n                        this.localizeToggleLabels();\r\n                    }\r\n                    else {\r\n                        this.languageResource.getAll()\r\n                            .then(resp => {\r\n                            const defaultLang = resp.find(lang => lang.isDefault);\r\n                            // this should never happen, but keeps TS happy\r\n                            if (!defaultLang)\r\n                                return;\r\n                            this.currentVariant = {\r\n                                language: defaultLang\r\n                            };\r\n                            this.defaultVariant = {\r\n                                language: defaultLang\r\n                            };\r\n                            this.selectedVariantName = this.currentVariant.language.culture;\r\n                            this.localizeToggleLabels();\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        this.localizeToggleLabels = () => {\r\n            this.localizationService.localizeMany([\r\n                'workflow_thisVariant',\r\n                'workflow_invariant',\r\n                'workflow_multiVariant',\r\n                'workflow_thisVariantDesc',\r\n                'workflow_invariantDesc',\r\n                'workflow_multiVariantDesc'\r\n            ])\r\n                .then((data) => {\r\n                var _a, _b, _c, _d;\r\n                let [thisVariant = 'Just this one', invariant = 'Invariant', multiVariant = 'Multi-variant', thisVariantDesc, invariantDesc, multiVariantDesc] = data;\r\n                let obj = { thisVariant, invariant, multiVariant, thisVariantDesc, invariantDesc, multiVariantDesc };\r\n                // append the current/default variant details to the description\r\n                obj.thisVariantDesc = obj.thisVariantDesc.replace('%0%', (_b = (_a = this.currentVariant) === null || _a === void 0 ? void 0 : _a.language.name) !== null && _b !== void 0 ? _b : '');\r\n                obj.invariantDesc = obj.invariantDesc.replace('%0%', (_d = (_c = this.defaultVariant) === null || _c === void 0 ? void 0 : _c.language.name) !== null && _d !== void 0 ? _d : '');\r\n                this.workflowTypeLabels = obj;\r\n            });\r\n        };\r\n        this.actionsService = plmbrActionsService;\r\n        // action is set when selecting the footer button\r\n        // but the workflow type may differ if the user selects from the sub-buttons\r\n        // the button handler sets isPublish and is used in initiate()\r\n        this.action = constants_1.constants.actions.publish;\r\n        this.events();\r\n        var now = new Date();\r\n        var nowFormatted = moment(now).format(\"YYYY-MM-DD HH:mm\");\r\n        this.datepickerConfig = {\r\n            enableTime: true,\r\n            dateFormat: \"Y-m-d H:i\",\r\n            time_24hr: true,\r\n            minDate: nowFormatted,\r\n            defaultDate: null,\r\n            defaultHour: now.getHours(),\r\n            defaultMinute: now.getMinutes() + 5\r\n        };\r\n        // ensure defaults for scheduling match the defaults for content\r\n        // ie scheduleDate and scheduledDateFormatted should be null\r\n        this.datepickerClear();\r\n        userService.getCurrentUser().then(currentUser => this.currentUser = currentUser);\r\n        $scope.$on('$destroy', () => {\r\n            this.onButtonStateChanged();\r\n            this.onAppActive();\r\n            this.onActioned();\r\n        });\r\n    }\r\n    datepickerChange(dateStr) {\r\n        this.scheduledDate = this.dateHelper.convertToServerStringTime(moment(dateStr), Umbraco.Sys.ServerVariables.application.serverTimeOffset);\r\n        this.scheduledDateFormatted = this.dateHelper.getLocalDate(this.scheduledDate, this.currentUser.locale, \"MMM Do YYYY, HH:mm\");\r\n    }\r\n    datepickerClear() {\r\n        this.scheduledDate = null;\r\n        this.scheduledDateFormatted = null;\r\n    }\r\n    filepickerClear() {\r\n        delete this.attachment;\r\n    }\r\n}\r\nexports.SubmitWorkflowComponent = {\r\n    name: 'workflowSubmit',\r\n    transclude: true,\r\n    bindings: {\r\n        state: '<',\r\n        scope: '<',\r\n    },\r\n    templateUrl: 'src/plumber/backoffice/components/submit-workflow/submit.html',\r\n    controller: WorkflowSubmit\r\n};\r\n\n},{\"../../js/constants\":22}],20:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TaskListComponent = void 0;\r\nconst constants_1 = require(\"../../js/constants\");\r\nclass WorkflowTaskList {\r\n    constructor($scope, $rootScope, plmbrWorkflowResource, localizationService) {\r\n        this.tasks = [];\r\n        this.$onChanges = () => {\r\n            this.fetchTasks();\r\n        };\r\n        this.avatarName = (task) => {\r\n            // don't show group if admin completed the task\r\n            if (task.actionedByAdmin) {\r\n                return this.adminStr;\r\n            }\r\n            // if not required, show the group name\r\n            if (task.status === 4) {\r\n                return task.groupName;\r\n            }\r\n            // resubmitted tasks won't have a group, just a user\r\n            if (task.status === 7) {\r\n                return task.completedBy;\r\n            }\r\n            // finally show either the group or the user\r\n            return task.groupName || task.completedBy;\r\n        };\r\n        this.statusColor = (status) => {\r\n            switch (status) {\r\n                case 1:\r\n                    return 'success'; //approved \r\n                case 2:\r\n                case 6:\r\n                    return 'danger'; //rejected, error\r\n                case 3:\r\n                    return 'primary'; //pending\r\n                case 7:\r\n                    return 'warning'; //resubmitted\r\n                default:\r\n                    return 'gray'; //cancelled, not required\r\n            }\r\n        };\r\n        this.whodunnit = (task) => {\r\n            // if rejected or incomplete, use the group name\r\n            if (task.status === 4 || !task.completedBy) {\r\n                return task.groupName;\r\n            }\r\n            if (task.status === 7) {\r\n                return task.completedBy;\r\n            }\r\n            // if actioned by an admin, show\r\n            if (task.actionedByAdmin) {\r\n                return `${task.completedBy} ${this.asAdminStr} ${this.forStr} ${task.groupName}`;\r\n            }\r\n            // if approved, show the user and group name\r\n            if (task.groupName && task.groupName !== this.noGroupStr) {\r\n                return `${task.completedBy} ${this.forStr} ${task.groupName}`;\r\n            }\r\n            // otherwise, just show the user name\r\n            return task.completedBy;\r\n        };\r\n        /**\r\n         *  there may be multiple tasks for a given step, due to rejection/resubmission - modify the tasks object to nest those tasks\r\n         * @param {array} tasks - the set of existing tasks for the instance. May be less than the total steps required in the workflow\r\n         */\r\n        this.setTaskMeta = (tasks) => {\r\n            if (!tasks.length)\r\n                return;\r\n            tasks.forEach(task => {\r\n                let t = task;\r\n                // push some extra UI strings onto each task\r\n                t.avatarName = this.avatarName(t);\r\n                t.statusColor = this.statusColor(t.status);\r\n                t.whodunnit = this.whodunnit(t);\r\n                if (!this.tasks[t.currentStep]) {\r\n                    this.tasks[t.currentStep] = [];\r\n                }\r\n                this.tasks[t.currentStep].push(t);\r\n            });\r\n            // get last task in last task collection\r\n            let lastTask = this.tasks[this.tasks.length - 1];\r\n            // last will always be a WorkflowTask, as we haven't added any ghosts yet\r\n            let lastStep = lastTask[lastTask.length - 1];\r\n            if (lastStep.status === 2) {\r\n                lastTask.push({\r\n                    avatarName: lastStep.requestedBy,\r\n                    statusColor: this.statusColor(3),\r\n                    statusName: this.awaitingResubmissionStr,\r\n                    whodunnit: lastStep.requestedBy\r\n                });\r\n            }\r\n        };\r\n        /**\r\n         * Add dummy tasks for future workflow stages\r\n         */\r\n        this.addPendingTasks = () => {\r\n            if (!this.permissions || !this.permissions.length)\r\n                return;\r\n            // if permissions are missing (group deleted), stuff a mock permission in at the correct index\r\n            if (this.permissions.length < this.totalSteps) {\r\n                let missingIndexes = [];\r\n                this.permissions.forEach(p => {\r\n                    missingIndexes[p.permission] = p;\r\n                });\r\n                const nodeId = this.permissions[0].nodeId;\r\n                const contentTypeId = this.permissions[0].contentTypeId;\r\n                for (let i = 0; i < missingIndexes.length; i += 1) {\r\n                    if (!missingIndexes[i]) {\r\n                        this.permissions.splice(i, 0, {\r\n                            groupName: this.noGroupStr,\r\n                            permission: i,\r\n                            groupId: -1,\r\n                            variant: '',\r\n                            nodeId,\r\n                            contentTypeId,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            if (this.tasks.length < this.totalSteps) {\r\n                for (let i = this.tasks.length; i < this.totalSteps; i += 1) {\r\n                    if (!this.permissions[i])\r\n                        continue;\r\n                    this.tasks.push([{\r\n                            futureTask: true,\r\n                            avatarName: this.permissions[i].groupName,\r\n                            statusName: this.pendingApprovalStr,\r\n                            statusColor: this.statusColor(3),\r\n                            whodunnit: this.permissions[i].groupName,\r\n                            currentStep: i,\r\n                        }]);\r\n                }\r\n            }\r\n        };\r\n        /**\r\n         */\r\n        this.fetchTasks = () => {\r\n            this.workflowResource.getAllTasksByGuid(this.instanceGuid)\r\n                .then(resp => {\r\n                if (resp.notifications) {\r\n                    return;\r\n                }\r\n                this.tasksLoaded = true;\r\n                this.tasks = [];\r\n                this.currentStep = resp.currentStep;\r\n                this.totalSteps = resp.totalSteps;\r\n                this.setTaskMeta(resp.items);\r\n                this.addPendingTasks();\r\n            });\r\n        };\r\n        this.tasksLoaded = false;\r\n        this.workflowResource = plmbrWorkflowResource;\r\n        // no need to get tasks on cancel - component is about to be destroyed.\r\n        this.onActioned = $rootScope.$on(constants_1.constants.events.workflowActioned, (_, data) => data.action != constants_1.constants.actions.cancel ? this.fetchTasks() : {});\r\n        localizationService.localizeMany(['workflow_admin', 'workflow_stage', 'workflow_asAdmin', 'workflow_for', 'workflow_awaitingResubmission', 'workflow_pendingApproval', 'workflow_noGroup'])\r\n            .then((resp) => {\r\n            [this.adminStr, this.stageStr, this.asAdminStr, this.forStr, this.awaitingResubmissionStr, this.pendingApprovalStr, this.noGroupStr] = resp;\r\n        });\r\n        $scope.$on('$destroy', () => {\r\n            this.onActioned();\r\n        });\r\n    }\r\n}\r\nexports.TaskListComponent = {\r\n    name: 'workflowTaskList',\r\n    transclude: true,\r\n    templateUrl: 'src/plumber/backoffice/components/tasklist/tasklist.html',\r\n    bindings: {\r\n        instanceGuid: '<',\r\n        permissions: '<'\r\n    },\r\n    controller: WorkflowTaskList\r\n};\r\n\n},{\"../../js/constants\":22}],21:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TasksComponent = void 0;\r\nconst models_1 = require(\"../../js/models\");\r\nconst tasklist_base_1 = require(\"../../js/models/tasklist.base\");\r\nclass WorkflowTasks extends tasklist_base_1.TaskListBase {\r\n    constructor($scope, $rootScope, notificationsService, plmbrActionsService) {\r\n        super($scope, $rootScope, notificationsService, plmbrActionsService);\r\n        this.pagination = new models_1.Pagination(() => this.fetch(), 5);\r\n        this.sorter = new models_1.Sorter(() => this.fetch());\r\n        this.sort = (key) => this.sorter.update(key);\r\n    }\r\n    $onChanges(change) {\r\n        if (change.model.currentValue) {\r\n            this.model = change.model.currentValue;\r\n            this.pagination.perPage = this.model.perPage || this.pagination.perPage;\r\n            this.fetch();\r\n        }\r\n    }\r\n    fetch() {\r\n        var _a, _b;\r\n        // only submit once as angular events may fire multiple times\r\n        if (this.paging)\r\n            return;\r\n        const query = {\r\n            userId: this.model.userId,\r\n            groupId: this.model.groupId,\r\n            page: this.pagination.pageNumber - 1,\r\n            count: this.pagination.perPage,\r\n            sortBy: this.sorter.sortBy,\r\n            sortDirection: this.sorter.sortDirectionString,\r\n        };\r\n        if ((_a = this.model.filters) === null || _a === void 0 ? void 0 : _a.keys)\r\n            query.filters = this.model.filters.keys;\r\n        if ((_b = this.model.filters) === null || _b === void 0 ? void 0 : _b.values)\r\n            query.filterValues = this.model.filters.values;\r\n        this.doFetch(query, this.pagination);\r\n    }\r\n    ;\r\n}\r\nexports.TasksComponent = {\r\n    name: 'workflowTasks',\r\n    transclude: true,\r\n    bindings: {\r\n        model: '<'\r\n    },\r\n    templateUrl: 'src/plumber/backoffice/components/tasks/tasks.html',\r\n    controller: WorkflowTasks\r\n};\r\n\n},{\"../../js/models\":29,\"../../js/models/tasklist.base\":33}],22:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.constants = void 0;\r\nexports.constants = {\r\n    workflow: 'workflow',\r\n    events: {\r\n        workflowAction: 'workflowAction',\r\n        workflowActioned: 'workflowActioned',\r\n        workflowDetail: 'workflowDetail',\r\n        workflowAppActive: 'workflowAppActive',\r\n        buttonStateChanged: 'buttonStateChanged',\r\n        configSaved: 'configSaved',\r\n        contentSaved: 'content.saved',\r\n        contentUnpublished: 'content.unpublished',\r\n        appTabChange: 'app.tabChange',\r\n        editorsOpen: 'appState.editors.open',\r\n        editorClose: 'appState.editors.close',\r\n        refreshGroups: 'refreshGroups',\r\n        goToNode: 'goToNode',\r\n    },\r\n    actions: {\r\n        publish: 'publish',\r\n        unpublish: 'unpublish',\r\n        initiate: 'initiate',\r\n        cancel: 'cancel',\r\n        reject: 'reject',\r\n        save: 'save',\r\n        saveAndPublish: 'saveAndPublish',\r\n        schedulePublish: 'schedulePublish',\r\n        publishDescendant: 'publishDescendant',\r\n        sendToPublish: 'sendToPublish',\r\n    },\r\n    sizes: {\r\n        s: 'small',\r\n        m: 'medium',\r\n        l: 'large',\r\n    },\r\n    states: {\r\n        success: 'success',\r\n        error: 'error',\r\n        busy: 'busy',\r\n        init: 'init',\r\n        rejected: 'rejected',\r\n        detail: 'detail',\r\n        published: 'published',\r\n        draft: 'draft',\r\n    },\r\n    updatePromptKey: 'plumberUpdatePrompt',\r\n    invariantCulture: '*',\r\n};\r\n\n},{}],23:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DirectivesModule = void 0;\r\nconst impersonationbanner_directive_1 = require(\"./impersonationbanner.directive\");\r\nconst license_directive_1 = require(\"./license.directive\");\r\nconst umblistview_directive_1 = require(\"./umblistview.directive\");\r\nconst umbtablerow_directive_1 = require(\"./umbtablerow.directive\");\r\nexports.DirectivesModule = angular\r\n    .module('plumber.directives', [])\r\n    .directive(impersonationbanner_directive_1.ImpersonationBanner.directiveName, ($compile) => new impersonationbanner_directive_1.ImpersonationBanner($compile))\r\n    .directive(license_directive_1.License.directiveName, (plmbrWorkflowResource, localizationService) => new license_directive_1.License(plmbrWorkflowResource, localizationService))\r\n    .directive(umblistview_directive_1.UmbListView.directiveName, (plmbrWorkflowResource) => new umblistview_directive_1.UmbListView(plmbrWorkflowResource))\r\n    .directive(umbtablerow_directive_1.UmbTableRow.directiveName, () => new umbtablerow_directive_1.UmbTableRow())\r\n    .name;\r\n\n},{\"./impersonationbanner.directive\":24,\"./license.directive\":25,\"./umblistview.directive\":26,\"./umbtablerow.directive\":27}],24:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ImpersonationBanner = void 0;\r\nclass ImpersonationBanner {\r\n    constructor($compile) {\r\n        this.$compile = $compile;\r\n        this.restrict = 'A';\r\n    }\r\n    link(scope, element) {\r\n        const license = Umbraco.Sys.ServerVariables.Plumber.license;\r\n        if (license.isImpersonating) {\r\n            const template = ` \r\n                <div class=\"alert alert-workflow\">\r\n                    <umb-icon icon=\"icon-alert\"></umb-icon>\r\n                    <p>Plumber license impersonation is active. All features are available on non-production domains only.</p>\r\n                </div>`;\r\n            element.prepend(this.$compile(template)(scope));\r\n        }\r\n    }\r\n}\r\nexports.ImpersonationBanner = ImpersonationBanner;\r\nImpersonationBanner.directiveName = 'impersonationBanner';\r\n\n},{}],25:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.License = void 0;\r\nclass License {\r\n    constructor(plmbrWorkflowResource, localizationService) {\r\n        this.plmbrWorkflowResource = plmbrWorkflowResource;\r\n        this.localizationService = localizationService;\r\n        this.restrict = 'A';\r\n    }\r\n    link(scope, element, attrs) {\r\n        const bind = () => {\r\n            // if the value is empty or false, return\r\n            if (attrs.licensed === 'false') {\r\n                return;\r\n            }\r\n            const license = Umbraco.Sys.ServerVariables.Plumber.license;\r\n            let title, content;\r\n            this.localizationService.localizeMany(['workflow_licensedFeature', 'workflow_licensedFeatureDescription'])\r\n                .then(result => {\r\n                [title, content] = result;\r\n                document.body.style.setProperty('--plumberUnlicensed', `'${title}'`);\r\n            });\r\n            if (!license || license.isTrial && !license.isImpersonating) {\r\n                element[0].classList.add('unlicensed');\r\n                element[0].addEventListener('click', () => {\r\n                    this.plmbrWorkflowResource.htmlOverlay(title, content);\r\n                }, false);\r\n                // this is a bit hacky, but needs the timeout to ensure the property-editor is\r\n                // full rendered before looking for the deep-nested buttons\r\n                setTimeout(() => {\r\n                    const buttons = element[0].querySelectorAll('button');\r\n                    if (buttons.length) {\r\n                        for (let i = 0; i < buttons.length; i += 1) {\r\n                            buttons[i].tabIndex = -1;\r\n                        }\r\n                    }\r\n                }, 500);\r\n            }\r\n        };\r\n        scope.$on('licenseCheck', () => bind());\r\n        bind();\r\n    }\r\n}\r\nexports.License = License;\r\nLicense.directiveName = 'licensed';\r\n\n},{}],26:[function(require,module,exports){\n\"use strict\";\r\n// directives here are used to change the icon on nodes in a list view\r\n// fetches the status for all nodes in the current view\r\n// sets a class on the list view row if an active workflow exists\r\n// raises an event once that is complete\r\n// in the umbtablerow directive, the event triggers adding a class to the table row which changes the icon and title attribute\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.UmbListView = void 0;\r\nclass UmbListView {\r\n    constructor(plmbrWorkflowResource) {\r\n        this.restrict = 'C';\r\n        this.workflowResource = plmbrWorkflowResource;\r\n    }\r\n    link(scope) {\r\n        const setIcons = nodes => scope.listViewResultSet.items.forEach(v => v.activeWorkflow = nodes[v.id] && nodes[v.id] === true);\r\n        scope.$watch(() => scope.listViewResultSet.items, (a, b) => {\r\n            if (a && a.length && a !== b) {\r\n                scope.items = a;\r\n                scope.ids = scope.items.map(i => i.id);\r\n                this.workflowResource.getStatus(scope.ids.join(','))\r\n                    .then(resp => {\r\n                    setIcons(resp.nodes);\r\n                    scope.$broadcast('listViewStatus');\r\n                });\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.UmbListView = UmbListView;\r\nUmbListView.directiveName = 'umbListview';\r\n\n},{}],27:[function(require,module,exports){\n\"use strict\";\r\n// directives here are used to change the icon on nodes in a list view\r\n// fetches the status for all nodes in the current view\r\n// sets a class on the list view row if an active workflow exists\r\n// raises an event once that is complete\r\n// in the table row directive, the event triggers adding a class to the table row which changes the icon and title attribute\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.UmbTableRow = void 0;\r\nclass UmbTableRow {\r\n    constructor() {\r\n        this.restrict = 'C';\r\n    }\r\n    link(scope, element) {\r\n        scope.$on('listViewStatus', () => {\r\n            if (scope.item && scope.item.activeWorkflow) {\r\n                element[0].classList.add('active-workflow');\r\n                element[0].childNodes.forEach(c => {\r\n                    if (c.classList && c.classList.contains('umb-table-cell')) {\r\n                        c.setAttribute('title', 'Workflow active');\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.UmbTableRow = UmbTableRow;\r\nUmbTableRow.directiveName = 'umbTableRow';\r\n\n},{}],28:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WorkflowStatus = void 0;\r\nvar WorkflowStatus;\r\n(function (WorkflowStatus) {\r\n    WorkflowStatus[WorkflowStatus[\"Approved\"] = 1] = \"Approved\";\r\n    WorkflowStatus[WorkflowStatus[\"Rejected\"] = 2] = \"Rejected\";\r\n    WorkflowStatus[WorkflowStatus[\"PendingApproval\"] = 3] = \"PendingApproval\";\r\n    WorkflowStatus[WorkflowStatus[\"NotRequired\"] = 4] = \"NotRequired\";\r\n    WorkflowStatus[WorkflowStatus[\"Cancelled\"] = 5] = \"Cancelled\";\r\n    WorkflowStatus[WorkflowStatus[\"Errored\"] = 6] = \"Errored\";\r\n    WorkflowStatus[WorkflowStatus[\"Resubmitted\"] = 7] = \"Resubmitted\";\r\n    WorkflowStatus[WorkflowStatus[\"CancelledByThirdParty\"] = 8] = \"CancelledByThirdParty\";\r\n})(WorkflowStatus = exports.WorkflowStatus || (exports.WorkflowStatus = {}));\r\n\n},{}],29:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SortOptions = exports.Sorter = exports.Pagination = void 0;\r\nvar pagination_1 = require(\"./pagination\");\r\nObject.defineProperty(exports, \"Pagination\", { enumerable: true, get: function () { return pagination_1.Pagination; } });\r\nvar sorter_1 = require(\"./sorter\");\r\nObject.defineProperty(exports, \"Sorter\", { enumerable: true, get: function () { return sorter_1.Sorter; } });\r\nvar sortoptions_1 = require(\"./sortoptions\");\r\nObject.defineProperty(exports, \"SortOptions\", { enumerable: true, get: function () { return sortoptions_1.SortOptions; } });\r\n\n},{\"./pagination\":30,\"./sorter\":31,\"./sortoptions\":32}],30:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Pagination = void 0;\r\n/**\r\n* Defaults to pageNumber = 1, totalPages = 0, perPage = 10\r\n* Pass a function to the constructor to use as the goToPage callback\r\n* goToPage manages setting the page number before executing the callback\r\n* */\r\nclass Pagination {\r\n    constructor(cb, perPage = 10) {\r\n        this.pageNumber = 1;\r\n        this.totalPages = 0;\r\n        this.perPage = perPage;\r\n        this.goToPage = i => {\r\n            this.pageNumber = i;\r\n            cb();\r\n        };\r\n    }\r\n}\r\nexports.Pagination = Pagination;\r\n\n},{}],31:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SortDirection = exports.Sorter = void 0;\r\nclass Sorter {\r\n    constructor(callback, sortBy = 'id', sortDirection = SortDirection.ASC) {\r\n        this.sortDirections = {};\r\n        this.sortBy = sortBy;\r\n        this.sortDirections[this.sortBy] = sortDirection;\r\n        this.callback = callback;\r\n    }\r\n    setDirection(sortDirection) {\r\n        this.sortDirections[this.sortBy] = sortDirection;\r\n    }\r\n    update(sortBy) {\r\n        this.sortBy = sortBy;\r\n        this.sortDirections[sortBy] = this.sortDirections[sortBy] === SortDirection.ASC\r\n            ? SortDirection.DESC\r\n            : SortDirection.ASC;\r\n        this.callback();\r\n    }\r\n    get sortDirectionString() {\r\n        return this.sortDirections[this.sortBy] === SortDirection.ASC ? 'asc' : 'desc';\r\n    }\r\n}\r\nexports.Sorter = Sorter;\r\nvar SortDirection;\r\n(function (SortDirection) {\r\n    SortDirection[\"ASC\"] = \"up\";\r\n    SortDirection[\"DESC\"] = \"down\";\r\n})(SortDirection = exports.SortDirection || (exports.SortDirection = {}));\r\n\n},{}],32:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SortOptions = void 0;\r\nclass SortOptions {\r\n    constructor(stop) {\r\n        this.axis = 'y';\r\n        this.containment = 'parent';\r\n        this.distance = 10;\r\n        this.opacity = 0.7;\r\n        this.tolerance = 'pointer';\r\n        this.scroll = true;\r\n        this.zIndex = 6000;\r\n        this.stop = () => { };\r\n        this.stop = () => {\r\n            stop ? stop() : {};\r\n        };\r\n    }\r\n}\r\nexports.SortOptions = SortOptions;\r\n\n},{}],33:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TaskListBase = void 0;\r\nconst constants_1 = require(\"../constants\");\r\nclass TaskListBase {\r\n    constructor($scope, $rootScope, notificationsService, plmbrActionsService) {\r\n        this.$rootScope = $rootScope;\r\n        this.notificationsService = notificationsService;\r\n        this.plmbrActionsService = plmbrActionsService;\r\n        this.buttonStates = [];\r\n        this.notificationsService = notificationsService;\r\n        this.actionsService = plmbrActionsService;\r\n        this.onDetail = $rootScope.$on(constants_1.constants.events.workflowDetail, (_, data) => this.setButtonState(data));\r\n        this.languageCount = Umbraco.Sys.ServerVariables.Plumber.languageCount;\r\n        $scope.$on('$destroy', () => {\r\n            this.onDetail();\r\n        });\r\n    }\r\n    doFetch(query, pagination) {\r\n        this.paging = true;\r\n        this.model.handler(query)\r\n            .then(resp => {\r\n            this.items = resp.items;\r\n            pagination.totalPages = resp.totalPages;\r\n        }, error => this.notificationsService.error('Error', error.message))\r\n            .finally(() => {\r\n            this.loaded = true;\r\n            this.paging = false;\r\n        });\r\n    }\r\n    displayName(item) {\r\n        return this.languageCount > 1 ? `${item.node.name} (${item.variantName})` : item.node.name;\r\n    }\r\n    detail(item) {\r\n        this.buttonStates[item.instanceGuid] = constants_1.constants.states.busy;\r\n        this.actionsService.detail(item);\r\n    }\r\n    setButtonState(data) {\r\n        this.buttonStates[data.instanceGuid] = constants_1.constants.states.init;\r\n    }\r\n    variantCode(item) {\r\n        return item.variantCode === '*' ? Umbraco.Sys.ServerVariables.Plumber.defaultCulture : item.variantCode;\r\n    }\r\n}\r\nexports.TaskListBase = TaskListBase;\r\n\n},{\"../constants\":22}],34:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ServicesModule = void 0;\r\nconst actions_resource_1 = require(\"./actions.resource\");\r\nconst groups_resource_1 = require(\"./groups.resource\");\r\nconst hub_resource_1 = require(\"./hub.resource\");\r\nconst state_factory_1 = require(\"./state.factory\");\r\nconst licensing_resource_1 = require(\"./licensing.resource\");\r\nconst workflow_resource_1 = require(\"./workflow.resource\");\r\nexports.ServicesModule = angular\r\n    .module('plumber.services', [])\r\n    .service(actions_resource_1.ActionsService.serviceName, actions_resource_1.ActionsService)\r\n    .service(groups_resource_1.GroupsService.serviceName, groups_resource_1.GroupsService)\r\n    .service(hub_resource_1.PlumberHub.serviceName, hub_resource_1.PlumberHub)\r\n    .service(state_factory_1.StateFactory.serviceName, state_factory_1.StateFactory)\r\n    .service(licensing_resource_1.LicensingService.serviceName, licensing_resource_1.LicensingService)\r\n    .service(workflow_resource_1.WorkflowService.serviceName, workflow_resource_1.WorkflowService)\r\n    .name;\r\n\n},{\"./actions.resource\":35,\"./groups.resource\":36,\"./hub.resource\":37,\"./licensing.resource\":38,\"./state.factory\":40,\"./workflow.resource\":41}],35:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ActionsService = void 0;\r\nconst constants_1 = require(\"../constants\");\r\nconst enums_1 = require(\"../models/enums\");\r\nclass ActionsService {\r\n    constructor($rootScope, editorService, $timeout, localizationService, navigationService, $routeParams, plmbrWorkflowResource, plmbrStateFactory) {\r\n        this.$rootScope = $rootScope;\r\n        this.editorService = editorService;\r\n        this.$timeout = $timeout;\r\n        this.localizationService = localizationService;\r\n        this.navigationService = navigationService;\r\n        this.$routeParams = $routeParams;\r\n        /**\r\n         * UI feedback for button directive\r\n         * @param {any} state\r\n         * @param {any} id\r\n         */\r\n        this.buttonState = (state, id) => this.$rootScope.$emit(constants_1.constants.events.buttonStateChanged, { state: state, id: id });\r\n        /**\r\n         * display notification after actioning workflow task\r\n         * @param {any} d\r\n         * @param {any} item\r\n         * @param {any} action\r\n         */\r\n        this.notify = (d, item, action) => {\r\n            var _a;\r\n            this.buttonState(d.status === 200 ? constants_1.constants.states.success : constants_1.constants.states.error, item.node.id);\r\n            const isScheduled = typeof item.scheduledDate !== 'undefined';\r\n            const type = item.typeId === 1 ? constants_1.constants.actions.publish : item.typeId === 2 ? constants_1.constants.actions.unpublish : null;\r\n            this.$rootScope.$emit(constants_1.constants.events.workflowActioned, {\r\n                action,\r\n                nodeId: item.node.id,\r\n                variant: item.variant,\r\n                isScheduled,\r\n                type,\r\n                status: d.workflowStatus\r\n            });\r\n            // sync the content tree to ensure current node state is correct, only after a workflow is complete\r\n            // as any other state won't have modified the node state, so no need to refresh\r\n            if (this.workflowStateFactory.path && d.workflowStatus.includes(enums_1.WorkflowStatus.Approved) && ((_a = this.$routeParams) === null || _a === void 0 ? void 0 : _a.tree)) {\r\n                this.navigationService.syncTree({ tree: this.$routeParams.tree, path: this.workflowStateFactory.path.split(',').map(x => +x), forceReload: true });\r\n            }\r\n            // finally, close the overlay if this is a dashboard action\r\n            if (this.workflowOverlay.close) {\r\n                this.workflowOverlay.close();\r\n            }\r\n        };\r\n        /**\r\n         *\r\n         * @param {any} item\r\n         * @param {any} comment\r\n         * @param {any} action\r\n         * @param {any} offline\r\n         */\r\n        this.action = (item, comment, action, offline) => {\r\n            this.buttonState(constants_1.constants.states.busy, item.node.id);\r\n            this.workflowResource.actionWorkflow({\r\n                action,\r\n                instanceGuid: item.instance.guid,\r\n                comment,\r\n                offline\r\n            }).then(resp => this.notify(resp, item, action));\r\n        };\r\n        /**\r\n         *\r\n         * @param {InitiateWorkflowModel} args\r\n         */\r\n        this.initiate = (model) => {\r\n            // notify expects an object\r\n            const item = {\r\n                node: { id: model.nodeId },\r\n                typeId: model.publish ? 1 : 2,\r\n                variant: model.variant,\r\n            };\r\n            if (model.scheduledDate) {\r\n                item.scheduledDate = model.scheduledDate;\r\n            }\r\n            this.buttonState(constants_1.constants.states.busy, model.nodeId);\r\n            this.workflowResource.initiateWorkflow(model)\r\n                .then(resp => this.notify(resp, item, constants_1.constants.actions.initiate));\r\n        };\r\n        /**\r\n         *\r\n         * @param {any} instance\r\n         */\r\n        this.detail = (instance) => {\r\n            this.localizationService.localizeMany(['workflow_pendingForNode', 'workflow_historyFor'])\r\n                .then(resp => this.doDetailOverlay(instance, resp[0], resp[1]));\r\n        };\r\n        /**\r\n         *\r\n         * @param {any} instance\r\n         * @param {any} pendingForNode\r\n         * @param {any} historyFor\r\n         */\r\n        this.doDetailOverlay = (instance, pendingForNode, historyFor) => {\r\n            const viewsPath = Umbraco.Sys.ServerVariables.Plumber.viewsPath;\r\n            pendingForNode = pendingForNode.replace('%0%', instance.type.toLowerCase());\r\n            pendingForNode = pendingForNode.replace('%1%', instance.node.name);\r\n            // readonly when the workflow is non-active\r\n            const readonly = instance.completedDate != null;\r\n            this.workflowOverlay = {\r\n                view: `${viewsPath}overlays/workflow.detail.overlay.html`,\r\n                size: readonly ? constants_1.constants.sizes.m : constants_1.constants.sizes.l,\r\n                title: pendingForNode,\r\n                description: instance.typeDescription,\r\n                instance,\r\n                readonly,\r\n                close: () => this.editorService.close()\r\n            };\r\n            if (instance.node.url !== '#') {\r\n                this.workflowOverlay.description = instance.node.url;\r\n            }\r\n            if (readonly || !instance.node.exists) {\r\n                this.workflowOverlay.title = historyFor.replace('%0%', instance.node.name);\r\n                this.editorService.open(this.workflowOverlay);\r\n            }\r\n            else {\r\n                const content = {\r\n                    id: instance.node.id,\r\n                    path: instance.path,\r\n                    contentTypeId: instance.contentTypeId\r\n                };\r\n                // if not readonly, we need state to allow correct action buttons\r\n                this.workflowStateFactory.getButtonState({ content, variantCode: instance.variantCode }).then(state => {\r\n                    this.workflowOverlay.state = state;\r\n                    this.$timeout(() => {\r\n                        this.editorService.open(this.workflowOverlay);\r\n                        this.$rootScope.$emit(constants_1.constants.events.workflowDetail, { instanceGuid: instance.instanceGuid });\r\n                    });\r\n                });\r\n            }\r\n        };\r\n        /**\r\n         * Offline gets state in the controller to check the user group is permitted to action, hence the simpler method here\r\n         */\r\n        this.offlineDetail = (instance, state) => {\r\n            this.localizationService.localize('workflow_pendingForNode')\r\n                .then(pendingForNode => this.doOfflineDetail(instance, state, pendingForNode));\r\n        };\r\n        /**\r\n         *\r\n         * @param {any} instance\r\n         * @param {any} state\r\n         * @param {any} pendingForNode\r\n         */\r\n        this.doOfflineDetail = (instance, state, pendingForNode) => {\r\n            const viewsPath = Umbraco.Sys.ServerVariables.Plumber.viewsPath;\r\n            pendingForNode = pendingForNode.replace('%0%', instance.type.toLowerCase());\r\n            pendingForNode = pendingForNode.replace('%1%', instance.node.name);\r\n            this.workflowOverlay = {\r\n                view: `${viewsPath}overlays/workflow.detail.overlay.html`,\r\n                size: constants_1.constants.sizes.l,\r\n                title: pendingForNode,\r\n                instance: instance,\r\n                readonly: false,\r\n                state: state,\r\n                close: () => this.editorService.close()\r\n            };\r\n            if (instance.node.url !== '#') {\r\n                this.workflowOverlay.description = instance.node.url;\r\n            }\r\n            this.editorService.open(this.workflowOverlay);\r\n            this.$rootScope.$emit(constants_1.constants.events.workflowDetail, { instanceGuid: instance.instanceGuid });\r\n        };\r\n        this.workflowResource = plmbrWorkflowResource;\r\n        this.workflowStateFactory = plmbrStateFactory;\r\n        this.workflowOverlay = {};\r\n        $rootScope.$on(constants_1.constants.events.goToNode, () => this.workflowOverlay.close());\r\n    }\r\n}\r\nexports.ActionsService = ActionsService;\r\nActionsService.serviceName = 'plmbrActionsService';\r\n\n},{\"../constants\":22,\"../models/enums\":28}],36:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GroupsService = void 0;\r\nconst constants_1 = require(\"../constants\");\r\nclass GroupsService {\r\n    constructor($http, $rootScope, umbRequestHelper, editorService) {\r\n        this.$http = $http;\r\n        this.umbRequestHelper = umbRequestHelper;\r\n        this.editorService = editorService;\r\n        this.request = (method, url, data) => {\r\n            url = `${Umbraco.Sys.ServerVariables.Plumber.groupsApiBaseUrl}${url}`;\r\n            return this.umbRequestHelper.resourcePromise(method === 'DELETE' ? this.$http.delete(url)\r\n                : method === 'POST' ? this.$http.post(url, data)\r\n                    : method === 'PUT' ? this.$http.put(url, data)\r\n                        : this.$http.get(url), 'Something broke');\r\n        };\r\n        /**\r\n         * @returns {array} user groups\r\n         * @description Get single group by id\r\n         */\r\n        this.get = (id) => this.request('GET', `Get?id=${id}`);\r\n        /**\r\n         * @returns {array} user group pocos - userId, groupId, inherited\r\n         * @param {Array<number|string>} ids array of Umbraco group ids to query\r\n         */\r\n        this.getInheritedMembers = (ids) => this.request('GET', `GetInheritedMembers?ids=${ids.join(',')}`);\r\n        /**\r\n         * @param {number} page defaults to 0\r\n         * @param {number} count defaults to 10000\r\n         * @param {string} filter defaults to ''\r\n         * @param {boolean} slim defaults to false\r\n         */\r\n        this.getPage = (page, count, filter = '', slim = false) => this.request('GET', `GetPage?slim=${slim}&page=${page}&count=${count}&filter=${filter}`);\r\n        /**\r\n         * @returns {array} user groups\r\n         * @description Get an array of slim user groups (id, name only)\r\n         */\r\n        this.getAllSlim = () => this.request('GET', 'GetPage?slim=true&page=1&count=10000');\r\n        /**\r\n         * Get the bare minimum content info - path, id, trashed, icon, name\r\n         * @param {any} ids\r\n         */\r\n        this.getContentSlim = ids => this.request('GET', `GetContentSlim?ids=${ids.join(',')}`);\r\n        /**\r\n         * @param {object} group\r\n         * @returns {string}\r\n         * @description save updates to an existing group object\r\n         */\r\n        this.save = group => this.request('PUT', 'Save', group);\r\n        /**\r\n         * @param {number} id\r\n         * @returns {string}\r\n         * @description delete group by id\r\n         */\r\n        this.delete = (id) => this.request('DELETE', 'Delete/' + id);\r\n        /**\r\n         *\r\n         * @param group\r\n         */\r\n        this.editGroup = (groupId) => {\r\n            const model = {\r\n                view: Umbraco.Sys.ServerVariables.Plumber.pluginPath + '/approval-groups/edit.html',\r\n                size: constants_1.constants.sizes.l,\r\n                groupId: groupId,\r\n                submit: _ => {\r\n                    this.editorService.close();\r\n                },\r\n                close: () => this.editorService.close(),\r\n            };\r\n            this.editorService.open(model);\r\n        };\r\n        /**\r\n         *\r\n         * @param name\r\n         * @param index\r\n         */\r\n        this.generateNameWithStage = (name, index) => `Stage ${index + 1}: ${name}`;\r\n        $rootScope.$on(constants_1.constants.events.refreshGroups, () => this.getAllSlim());\r\n    }\r\n}\r\nexports.GroupsService = GroupsService;\r\nGroupsService.serviceName = 'plmbrGroupsResource';\r\n\n},{\"../constants\":22}],37:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.PlumberHub = void 0;\r\nclass PlumberHub {\r\n    constructor($rootScope, $q, assetsService) {\r\n        this.$rootScope = $rootScope;\r\n        this.$q = $q;\r\n        this.assetsService = assetsService;\r\n        this.scripts = [];\r\n        this.starting = false;\r\n        this.callbacks = [];\r\n        this.setupHub = callback => {\r\n            let proxy;\r\n            let hub = {};\r\n            $.connection = new signalR.HubConnectionBuilder()\r\n                .withUrl(Umbraco.Sys.ServerVariables.Plumber.signalRHub, {\r\n                skipNegotiation: true,\r\n                transport: signalR.HttpTransportType.WebSockets,\r\n            })\r\n                .withAutomaticReconnect()\r\n                .configureLogging(signalR.LogLevel.Warning)\r\n                .build();\r\n            proxy = $.connection;\r\n            if (proxy !== undefined) {\r\n                hub = {\r\n                    active: true,\r\n                    start: () => {\r\n                        try {\r\n                            proxy.start()\r\n                                .then(() => { } /*console.info('Hub started =>', $.connection.connectionId)*/)\r\n                                .catch(() => console.warn('Failed to start hub'));\r\n                        }\r\n                        catch (e) {\r\n                            console.warn('Could not setup signalR connection', e);\r\n                        }\r\n                    },\r\n                    on: (eventName, callback) => {\r\n                        proxy.on(eventName, result => {\r\n                            this.$rootScope.$apply(() => {\r\n                                if (callback) {\r\n                                    callback(result);\r\n                                }\r\n                            });\r\n                        });\r\n                    },\r\n                    /**\r\n                     * Function is common across 472 and 5.0\r\n                     * @param methodName\r\n                     * @param callback\r\n                     */\r\n                    invoke: (methodName, callback) => {\r\n                        proxy.invoke(methodName)\r\n                            .done(result => this.$rootScope.$apply(() => {\r\n                            if (callback) {\r\n                                callback(result);\r\n                            }\r\n                        }));\r\n                    }\r\n                };\r\n            }\r\n            else {\r\n                hub = {\r\n                    on: () => { },\r\n                    invoke: () => { },\r\n                    start: () => console.warn('No hub to start'),\r\n                };\r\n            }\r\n            return callback(hub);\r\n        };\r\n        const umbracoPath = Umbraco.Sys.ServerVariables.umbracoSettings.umbracoPath;\r\n        this.scripts = [umbracoPath + '/lib/signalr/signalr.min.js'];\r\n    }\r\n    /**\r\n     * Function is common across 472 and 5.0\r\n     * */\r\n    processCallbacks() {\r\n        while (this.callbacks.length) {\r\n            const cb = this.callbacks.pop();\r\n            this.setupHub(cb);\r\n        }\r\n        this.starting = false;\r\n    }\r\n    /**\r\n     * Function is common across 472 and 5.0\r\n     * @param callback\r\n     */\r\n    initHub(callback) {\r\n        this.callbacks.push(callback);\r\n        if (!this.starting) {\r\n            if ($.connection === undefined) {\r\n                this.starting = true;\r\n                const promises = [];\r\n                this.scripts.forEach(script => promises.push(this.assetsService.loadJs(script)));\r\n                this.$q.all(promises).then(() => this.processCallbacks());\r\n            }\r\n            else {\r\n                this.processCallbacks();\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.PlumberHub = PlumberHub;\r\nPlumberHub.serviceName = 'plumberHub';\r\n\n},{}],38:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LicensingService = void 0;\r\nclass LicensingService {\r\n    constructor($http, umbRequestHelper) {\r\n        this.$http = $http;\r\n        this.umbRequestHelper = umbRequestHelper;\r\n        this.request = (method, url, data) => {\r\n            url = `${Umbraco.Sys.ServerVariables.Plumber.licensingApiBaseUrl}${url}`;\r\n            return this.umbRequestHelper.resourcePromise(method === 'GET'\r\n                ? this.$http.get(url)\r\n                : this.$http.post(url, data), 'Something broke');\r\n        };\r\n        this.validate = (license, key) => this.request('POST', 'Validate', { license, key });\r\n        this.getEula = () => this.request('GET', 'GetEula');\r\n        this.getLicensingUrl = () => this.request('GET', 'GetLicensingUrl');\r\n    }\r\n}\r\nexports.LicensingService = LicensingService;\r\nLicensingService.serviceName = 'plmbrLicensingResource';\r\n\n},{}],39:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.PlumberServiceBase = void 0;\r\nclass PlumberServiceBase {\r\n    constructor($http, $routeParams, umbRequestHelper, navigationService) {\r\n        this.$http = $http;\r\n        this.$routeParams = $routeParams;\r\n        this.umbRequestHelper = umbRequestHelper;\r\n        this.navigationService = navigationService;\r\n        /**\r\n         *\r\n         * @param {any} method\r\n         * @param {any} url\r\n         * @param {any} data\r\n         */\r\n        this.request = (method, url, data) => this.umbRequestHelper.resourcePromise(method === 'DELETE' ? this.$http.delete(url)\r\n            : method === 'POST' ? this.$http.post(url, data)\r\n                : method === 'PUT' ? this.$http.put(url, data)\r\n                    : this.$http.get(url), 'Something broke');\r\n        /**\r\n         * sync the tree in the workflow section\r\n         */\r\n        this.setTreeState = () => {\r\n            if (this.$routeParams.section === 'workflow') {\r\n                this.navigationService.syncTree({ tree: this.$routeParams.tree, path: [-1], forceReload: false });\r\n            }\r\n        };\r\n        this.urls = {\r\n            settings: Umbraco.Sys.ServerVariables.Plumber.settingsApiBaseUrl,\r\n            tasks: Umbraco.Sys.ServerVariables.Plumber.tasksApiBaseUrl,\r\n            instances: Umbraco.Sys.ServerVariables.Plumber.instancesApiBaseUrl,\r\n            actions: Umbraco.Sys.ServerVariables.Plumber.actionsApiBaseUrl,\r\n            config: Umbraco.Sys.ServerVariables.Plumber.configApiBaseUrl,\r\n            scaffold: Umbraco.Sys.ServerVariables.Plumber.scaffoldApiBaseUrl\r\n        };\r\n    }\r\n}\r\nexports.PlumberServiceBase = PlumberServiceBase;\r\n\n},{}],40:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.StateFactory = void 0;\r\nconst constants_1 = require(\"../constants\");\r\nclass StateFactory {\r\n    constructor($rootScope, $location, plmbrWorkflowResource) {\r\n        this.$rootScope = $rootScope;\r\n        this.$location = $location;\r\n        this.rejected = false;\r\n        this.canAction = false;\r\n        this.canResubmit = false;\r\n        this.canEdit = true;\r\n        this.isChangeAuthor = false;\r\n        this.isAdmin = false;\r\n        ///\r\n        this.setNodeState = (currentTask) => {\r\n            var _a, _b;\r\n            this.rejected = false;\r\n            this.isChangeAuthor = false;\r\n            this.canAction = false;\r\n            this.canEdit = true;\r\n            if (currentTask) {\r\n                this.rejected = currentTask.cssStatus === constants_1.constants.states.rejected;\r\n                // if the task has been rejected and the current user requested the change, let them edit\r\n                this.isChangeAuthor = currentTask.requestedById === this.user.id;\r\n                // if the current user is a member of the group and task is pending, they can action, UNLESS...\r\n                // if the user requested the change, is a member of the current group, and flow type is exclude, they cannot action\r\n                this.canAction = ((_b = (_a = currentTask.userGroup) === null || _a === void 0 ? void 0 : _a.usersSummary) === null || _b === void 0 ? void 0 : _b.indexOf(`|${this.user.id}|`)) !== -1 && !this.rejected;\r\n                if (this.settings.flowType === 2 && this.isChangeAuthor && this.canAction) {\r\n                    this.canAction = false;\r\n                }\r\n                this.canResubmit = this.rejected && this.isChangeAuthor;\r\n                this.canEdit = this.rejected && this.isChangeAuthor || this.isAdmin;\r\n            }\r\n        };\r\n        /**\r\n         * Trial license must have node or inherited config and !excluded for config to be valid\r\n         * Other license types can have any of node, contentType or inherited, and !excluded\r\n         */\r\n        this.hasValidConfig = () => {\r\n            if (this.config.excluded) {\r\n                return false;\r\n            }\r\n            if (Umbraco.Sys.ServerVariables.Plumber.license.isTrial) {\r\n                return this.config.node.length\r\n                    || this.config.inherited.length\r\n                    || this.config.new.length;\r\n            }\r\n            return this.config.node.length\r\n                || this.config.contentType.length\r\n                || this.config.new.length\r\n                || this.config.inherited.length;\r\n        };\r\n        /**\r\n         * Remove buttons by alias from the provided button set\r\n         * @param buttons\r\n         * @param keys\r\n         */\r\n        this.removeButtons = (buttons, keys) => {\r\n            keys.forEach(key => {\r\n                const idx = buttons.findIndex(x => x.alias === key);\r\n                if (idx === -1)\r\n                    return;\r\n                buttons.splice(idx, 1);\r\n            });\r\n        };\r\n        this.workflowResource = plmbrWorkflowResource;\r\n        this.nodeId;\r\n        this.buttons = {\r\n            detail: {\r\n                labelKey: 'workflow_detailButton',\r\n                buttonStyle: constants_1.constants.states.detail,\r\n                addEllipsis: true,\r\n                handler: () => this.showApp(),\r\n                shortcut: 'ctrl+d'\r\n            },\r\n            publish: {\r\n                labelKey: 'workflow_publishButton',\r\n                buttonStyle: constants_1.constants.states.success,\r\n                addEllipsis: true,\r\n                handler: () => this.showApp(constants_1.constants.actions.publish),\r\n                shortcut: 'ctrl+p'\r\n            },\r\n            unpublish: {\r\n                labelKey: 'workflow_unpublishButton',\r\n                addEllipsis: true,\r\n                handler: () => this.showApp(constants_1.constants.actions.unpublish),\r\n                shortcut: 'ctrl+u'\r\n            }\r\n        };\r\n        $rootScope.$on('$routeChangeStart', () => {\r\n            this.originalDefaultButton = null;\r\n            this.originalSubButtons = null;\r\n        });\r\n    }\r\n    showApp(action) {\r\n        // will have multiple apps when multiple infinite editors are open\r\n        const apps = document.querySelectorAll('[data-element=\"sub-view-workflow\"]');\r\n        const tabScope = angular.element(apps[apps.length - 1]);\r\n        if (tabScope) {\r\n            if (action && this.nodeId !== 0) {\r\n                this.$rootScope.$emit(constants_1.constants.events.workflowAppActive, { action, id: this.nodeId });\r\n            }\r\n            // this is a bit naive, but avoids scope lookup on DOM elements...\r\n            tabScope['click']();\r\n        }\r\n    }\r\n    /**\r\n     * This isn't foolproof - if a node is loaded in an unpublished state, then published\r\n     * the unpublish button won't display as it didn't exist in the original buttons when the\r\n     * node first loaded. This appears to be the same behaviour in Umbraco without Plumber\r\n     * @param subButtons\r\n     * @param activeVariantState\r\n     * @param currentTask\r\n     */\r\n    setUnpublishButtons(subButtons, activeVariantState, currentTask) {\r\n        // check for wf unpublish before adding - it may have been cached as part of the set already\r\n        const unpublishIndex = subButtons.findIndex(x => x.alias === constants_1.constants.actions.unpublish);\r\n        const workflowUnpublishBtnIndex = subButtons.findIndex(x => x.alias === this.buttons.unpublish.alias);\r\n        // only add unpublish if the node is unpublishable aka is published\r\n        // this is variant-specific as each can be in a different state\r\n        if (activeVariantState.toLowerCase().startsWith(constants_1.constants.states.published)) {\r\n            // add buttons when unpublish exists (user has permission) and no workflow button added\r\n            if (unpublishIndex !== -1 && workflowUnpublishBtnIndex === -1) {\r\n                if (this.settings.requireUnpublish || this.hasUnpublishPermissions) {\r\n                    // if unpublish is required, either add the button or replace the \r\n                    // umbraco unpublish, if the user has permission to unpublish\r\n                    if (!this.isAdmin && !this.settings.extendPermissions) {\r\n                        subButtons[unpublishIndex] = this.buttons.unpublish;\r\n                    }\r\n                    else {\r\n                        subButtons.splice(unpublishIndex, 0, this.buttons.unpublish);\r\n                    }\r\n                }\r\n            }\r\n            else if (!currentTask) {\r\n                // add the workflow unpublish button if settings dictate and it isn't already in the set\r\n                if ((this.settings.requireUnpublish || this.hasUnpublishPermissions) && workflowUnpublishBtnIndex === -1) {\r\n                    subButtons.push(this.buttons.unpublish);\r\n                }\r\n                // then add the original Umbraco unpublish if it exists in the original button set and not in the updated buttons\r\n                const originalUnpublishIndex = this.originalSubButtons.findIndex(x => x.alias === constants_1.constants.actions.unpublish);\r\n                if (originalUnpublishIndex > -1 && unpublishIndex === -1) {\r\n                    subButtons.splice(originalUnpublishIndex, 0, this.originalSubButtons[originalUnpublishIndex]);\r\n                }\r\n            }\r\n        }\r\n        else if (activeVariantState.toLowerCase() === constants_1.constants.states.draft) {\r\n            // if not published, no need for unpublish buttons\r\n            if (unpublishIndex !== -1) {\r\n                subButtons.splice(unpublishIndex, 1);\r\n            }\r\n            if (workflowUnpublishBtnIndex !== -1) {\r\n                subButtons.splice(workflowUnpublishBtnIndex, 1);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Offline state is simpler as it doesn't need to set buttons\r\n     * as we can assume plenty about the state purely by being offline\r\n     * @param {any} arg\r\n     */\r\n    getOfflineState(arg) {\r\n        this.nodeId = arg.content.id;\r\n        let variant;\r\n        // offline approvale must get variant directly from path \r\n        if (window.location.pathname.startsWith('/workflow-offline')) {\r\n            let pathArray = window.location.pathname.split('/');\r\n            variant = pathArray[3]; // /workflow-offline/nodeId/variant/etc/etc/etc\r\n            variant = variant === '0' ? '*' : variant; // can't pass * in the url, so is set to 0\r\n        }\r\n        const scaffoldQueryModel = {\r\n            nodeId: this.nodeId,\r\n            contentTypeId: arg.content.contentTypeId,\r\n            path: arg.content.path,\r\n            variant,\r\n            includeServerVariables: true,\r\n        };\r\n        return this.workflowResource.scaffold(scaffoldQueryModel)\r\n            .then(resp => {\r\n            this.user = resp.user;\r\n            this.pending = resp.tasks;\r\n            this.config = resp.config;\r\n            this.settings = resp.settings;\r\n            const currentTask = this.pending.task;\r\n            const variantTasks = this.pending.variantTasks;\r\n            let hasConfig;\r\n            this.isAdmin = this.user.allowedSections.includes('workflow');\r\n            if (this.hasValidConfig()) {\r\n                hasConfig = true;\r\n                this.setNodeState(currentTask);\r\n                let config = this.configObject({ hasConfig, currentTask, variantTasks });\r\n                config['offline'] = true;\r\n                return config;\r\n            }\r\n            else {\r\n                // should never be here for offline approval, since config must exist for the offline approval\r\n                // request to have ever been generated\r\n                return this.noConfigObject();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     *\r\n     * @param {any} arg\r\n     */\r\n    getButtonState(arg) {\r\n        var _a;\r\n        // remove the Umbraco buttons to avoid flashing the default while the updated versions are calculated\r\n        // caches in the factory using the current node id, and only sets on first request for button state\r\n        // to avoid overwriting with the workflow buttons when a workflow is completed/cancelled\r\n        this.originalSubButtons = arg.content.id != this.nodeId ? arg.subButtons : this.originalSubButtons || arg.subButtons;\r\n        this.originalDefaultButton = arg.content.id != this.nodeId ? arg.defaultButton : this.originalDefaultButton || arg.defaultButton;\r\n        this.nodeId = arg.isNew === 'true' ? Umbraco.Sys.ServerVariables.Plumber.newNodeFlowId : arg.content.id;\r\n        this.path = (_a = arg.content) === null || _a === void 0 ? void 0 : _a.path;\r\n        let variant;\r\n        // get variant from URL, or from default culture if only a single variant, else from the active variant language object\r\n        variant = arg.variantCode || this.$location.search().cculture || this.$location.search().mculture ||\r\n            (arg.content.variants.length === 1 ? Umbraco.Sys.ServerVariables.Plumber.defaultCulture : arg.content.variants.filter(v => v.active)[0].language.culture);\r\n        arg.subButtons = [];\r\n        arg.defaultButton = undefined;\r\n        const scaffoldQueryModel = {\r\n            nodeId: this.nodeId,\r\n            contentTypeId: arg.content.contentTypeId,\r\n            path: arg.content.path,\r\n            variant,\r\n        };\r\n        return this.workflowResource.scaffold(scaffoldQueryModel)\r\n            .then(resp => {\r\n            this.user = resp.user;\r\n            this.pending = resp.tasks;\r\n            this.config = resp.config;\r\n            this.settings = resp.settings;\r\n            const currentTask = this.pending.task;\r\n            const variantTasks = this.pending.variantTasks;\r\n            let subButtons;\r\n            this.isAdmin = this.user.allowedSections.includes('workflow');\r\n            if (this.hasValidConfig()) {\r\n                this.setNodeState(currentTask);\r\n                // set sub-buttons, and push default button into this set\r\n                subButtons = this.originalSubButtons || [];\r\n                // only modify buttons when contentForm property exists \r\n                // when no content form, it's a dashboard, so no buttons\r\n                if (arg.contentForm) {\r\n                    if (this.pending.task || this.pending.variantTasks && !this.isAdmin) {\r\n                        subButtons = [];\r\n                    }\r\n                    else if (this.originalDefaultButton && !subButtons.find(x => x.alias === constants_1.constants.actions.saveAndPublish)) {\r\n                        subButtons.splice(0, 0, this.originalDefaultButton);\r\n                    }\r\n                    // always remove send to publish, as this causes confusion since workflow\r\n                    // is doing much the same thing, but better :)\r\n                    this.removeButtons(subButtons, [constants_1.constants.actions.sendToPublish]);\r\n                }\r\n                // if lockIfActive remove save, save+publish\r\n                if (this.settings.lockIfActive && (this.pending.task || this.pending.variantTasks)) {\r\n                    if (arg.contentForm) {\r\n                        this.removeButtons(subButtons, [constants_1.constants.actions.save, constants_1.constants.actions.saveAndPublish]);\r\n                    }\r\n                    // if locked, no one can edit, admin or otherwise, unless they have canResubmit permission\r\n                    // because rejecting but not allowing edits is pointless\r\n                    this.canEdit = this.canResubmit || false;\r\n                }\r\n                // if unpublish workflow config exists, we can include the request unpublish button even if unpublish is not required\r\n                // this has to happen here becuase the guard below will prevent the value updating when resetting state\r\n                // after saving config changes, because that happens in the workflow app\r\n                this.hasUnpublishPermissions = this.config.node.length && this.config.node[0].type === 0\r\n                    || this.config.contentType.length && this.config.contentType[0].type === 0\r\n                    || this.config.inherited.length && this.config.inherited[0].type === 0;\r\n                // if sub-buttons contains unpublish, add the request unpublish button\r\n                // if user is admin, add the button, if not, replace existing unpublish\r\n                // unpublish does not exist, add it - all workflow users should be able to request unpublish\r\n                // finally, none of this needs to happen if requireUnpublish is not true\r\n                if (arg.contentForm) {\r\n                    const activeVariant = arg.content.variants.find(v => v.active);\r\n                    this.setUnpublishButtons(subButtons, activeVariant.state, currentTask);\r\n                    // if user is not admin, remove the save+publish, schedule and publishDescendants button\r\n                    if (!this.isAdmin && !this.settings.extendPermissions) {\r\n                        this.removeButtons(subButtons, [\r\n                            constants_1.constants.actions.saveAndPublish,\r\n                            constants_1.constants.actions.schedulePublish,\r\n                            constants_1.constants.actions.publishDescendant\r\n                        ]);\r\n                    }\r\n                }\r\n                arg.defaultButton = currentTask ? this.buttons.detail : this.buttons.publish;\r\n                arg.subButtons = subButtons;\r\n                return this.configObject({\r\n                    currentTask,\r\n                    variantTasks,\r\n                    defaultButton: arg.defaultButton,\r\n                    subButtons,\r\n                });\r\n            }\r\n            else {\r\n                arg.defaultButton = this.originalDefaultButton;\r\n                arg.subButtons = this.originalSubButtons;\r\n                return this.noConfigObject({ defaultButton: arg.defaultButton, subButtons: arg.subButtons });\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     *\r\n     * @param {any} arg an object containing lots of stuff\r\n     */\r\n    configObject(arg) {\r\n        return {\r\n            nodeId: this.nodeId,\r\n            hasConfig: true,\r\n            exclude: this.config.excluded,\r\n            permissions: {\r\n                node: this.config.node,\r\n                contentType: this.config.contentType,\r\n                inherited: this.config.inherited,\r\n                new: this.config.new,\r\n                active: this.config.node.length ? 'node'\r\n                    : this.config.contentType.length ? 'contentType'\r\n                        : this.config.inherited.length ? 'inherited' : ''\r\n            },\r\n            allowAttachments: this.settings.allowAttachments,\r\n            requireUnpublish: this.settings.requireUnpublish,\r\n            hasUnpublishPermissions: this.hasUnpublishPermissions,\r\n            isActive: !!arg.currentTask,\r\n            isAdmin: this.isAdmin,\r\n            canEdit: this.canEdit,\r\n            currentTask: arg.currentTask,\r\n            variantTasks: arg.variantTasks,\r\n            canAction: this.canAction,\r\n            rejected: this.rejected,\r\n            canResubmit: this.canResubmit,\r\n            isChangeAuthor: this.isChangeAuthor,\r\n            userId: this.user.id,\r\n            buttons: {\r\n                defaultButton: arg.defaultButton,\r\n                subButtons: arg.subButtons\r\n            }\r\n        };\r\n    }\r\n    noConfigObject(arg) {\r\n        return {\r\n            nodeId: this.nodeId,\r\n            hasConfig: false,\r\n            isAdmin: this.isAdmin,\r\n            exclude: this.config.excluded,\r\n            permissions: {\r\n                node: [],\r\n                contentType: [],\r\n                inherited: [],\r\n                new: this.config.new,\r\n                active: this.config.new.length ? 'node' : '',\r\n            },\r\n            buttons: {\r\n                defaultButton: arg.defaultButton,\r\n                subButtons: arg.subButtons\r\n            },\r\n        };\r\n    }\r\n}\r\nexports.StateFactory = StateFactory;\r\nStateFactory.serviceName = 'plmbrStateFactory';\r\n\n},{\"../constants\":22}],41:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WorkflowService = void 0;\r\nconst filterpicker_1 = require(\"../../components/filterpicker/filterpicker\");\r\nconst service_base_1 = require(\"./service-base\");\r\nclass WorkflowService extends service_base_1.PlumberServiceBase {\r\n    constructor($http, $routeParams, umbRequestHelper, navigationService, dateHelper, overlayService) {\r\n        super($http, $routeParams, umbRequestHelper, navigationService);\r\n        this.dateHelper = dateHelper;\r\n        this.overlayService = overlayService;\r\n        this.activityFilter = {};\r\n        this.htmlOverlay = (title, content) => {\r\n            const overlayModel = {\r\n                view: `${Umbraco.Sys.ServerVariables.Plumber.viewsPath}overlays/html.overlay.html`,\r\n                hideSubmitButton: true,\r\n                title,\r\n                content,\r\n                submit: () => this.overlayService.close(),\r\n                close: () => this.overlayService.close()\r\n            };\r\n            this.overlayService.open(overlayModel);\r\n        };\r\n        this.scaffold = (params) => {\r\n            params.variant = this.safeVariant(params.variant);\r\n            const result = this.request('GET', this.urls.scaffold + 'Get?' + this.generateQuery(params));\r\n            this.nodeConfig = result.nodeConfig;\r\n            this.configVariant = params.variant;\r\n            return result;\r\n        };\r\n        this.generateQuery = (params) => Object.entries(params).map((e) => e[0] + '=' + e[1]).join('&');\r\n        /*\r\n         * Don't send * as a param - api endpoints default to *\r\n         */\r\n        this.safeVariant = (variant) => variant === '*' ? '' : variant;\r\n        /* TASKS */\r\n        this.getAllTasksForGroup = (query) => this.request('GET', this.urls.tasks + 'Group?' + this.generateQuery(query));\r\n        this.getAllTasksForGroupForRange = (groupId, days) => this.request('GET', this.urls.tasks + `GetForGroupAndRange?groupId=${groupId}&days=${days}`);\r\n        this.getAllTasksByGuid = (guid) => this.request('GET', `${this.urls.tasks}TasksByInstanceGuid?guid=${guid}`);\r\n        /* INSTANCES */\r\n        this.getAllInstances = (query) => this.request('GET', this.urls.instances + 'GetAll?' + this.generateQuery(query));\r\n        this.getInstancesInitiatedByUser = (query) => this.request('GET', `${this.urls.instances}GetInitiatedBy?` + this.generateQuery(query));\r\n        this.getInstancesAssignedToUser = (query) => this.request('GET', `${this.urls.instances}GetAssignedTo?` + this.generateQuery(query));\r\n        this.getActiveInstances = (query) => this.request('GET', `${this.urls.instances}GetActive?` + this.generateQuery(query));\r\n        this.getAllInstancesForRange = (days) => this.request('GET', `${this.urls.instances}GetRange?days=${days}`);\r\n        this.getStatus = (ids) => this.request('GET', this.urls.instances + 'GetStatus?ids=' + ids);\r\n        this.getDiff = (id) => this.request('GET', this.urls.instances + 'GetDiff?guid=' + id);\r\n        /* workflow actions */\r\n        this.initiateWorkflow = (model) => this.request('POST', this.urls.actions + 'Initiate', model);\r\n        this.actionWorkflow = (model) => this.request('POST', this.urls.actions + model.action, model);\r\n        /* SAVE PERMISSIONS */\r\n        this.saveNodeConfig = (nodeId, permissions, variant, appliesTo) => {\r\n            this.nodeConfig = null;\r\n            this.configVariant = null;\r\n            return this.request('POST', this.urls.config + 'SaveNodeConfig', {\r\n                id: nodeId,\r\n                permissions: permissions,\r\n                variant: variant,\r\n                type: appliesTo,\r\n            });\r\n        };\r\n        this.saveDocTypeConfig = (syncModel) => this.request('POST', this.urls.config + 'SaveContentTypeConfig', syncModel);\r\n        this.getNewNodeConfig = () => this.request('GET', this.urls.config + 'GetNewNodeConfig');\r\n        this.getPathAndType = (nodeId) => this.request('GET', this.urls.config + 'GetPathAndType?id=' + nodeId);\r\n        // pass the activity filter between the admin and history views \r\n        this.setActivityFilter = (filter) => {\r\n            if (filter != null) {\r\n                filterpicker_1.generateFilters(filter, false, this.dateHelper);\r\n            }\r\n            this.activityFilter = filter;\r\n        };\r\n        this.getActivityFilter = () => this.activityFilter;\r\n    }\r\n}\r\nexports.WorkflowService = WorkflowService;\r\nWorkflowService.serviceName = 'plmbrWorkflowResource';\r\n\n},{\"../../components/filterpicker/filterpicker\":12,\"./service-base\":39}],42:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.OfflineModule = void 0;\r\nconst offline_controller_1 = require(\"./offline.controller\");\r\nconst iframeloaded_directive_1 = require(\"./iframeloaded.directive\");\r\nexports.OfflineModule = angular\r\n    .module('plumber.offline', [])\r\n    .controller(offline_controller_1.OfflineController.controllerName, offline_controller_1.OfflineController)\r\n    .directive(iframeloaded_directive_1.IframeLoaded.directiveName, () => new iframeloaded_directive_1.IframeLoaded())\r\n    .name;\r\n\n},{\"./iframeloaded.directive\":44,\"./offline.controller\":45}],43:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst _componentsModule_1 = require(\"../components/_componentsModule\");\r\nconst _directivesModule_1 = require(\"../js/directives/_directivesModule\");\r\nconst _servicesModule_1 = require(\"../js/services/_servicesModule\");\r\nconst _offlineModule_1 = require(\"./_offlineModule\");\r\nconst name = 'plumber';\r\nconst interceptorName = 'plumberOfflineInterceptor';\r\nangular.module(name, [\r\n    'umbraco.resources',\r\n    'umbraco.services',\r\n    'umbraco.packages',\r\n    'umbraco.directives',\r\n    'ngRoute',\r\n    'ngSanitize',\r\n    _servicesModule_1.ServicesModule,\r\n    _directivesModule_1.DirectivesModule,\r\n    _componentsModule_1.ComponentsModule,\r\n    _offlineModule_1.OfflineModule\r\n]).config($httpProvider => $httpProvider.interceptors.push(interceptorName));\r\nfunction interceptor($q) {\r\n    return {\r\n        request: req => {\r\n            // since we're outside Umbraco, routes need to be modified\r\n            if (req.url.includes('LocalizedText') || req.url.includes('views/components')) {\r\n                req.url = `/umbraco/${req.url}`;\r\n            }\r\n            return req || $q.when(req);\r\n        }\r\n    };\r\n}\r\nangular.module(name).factory(interceptorName, ['$q', interceptor]);\r\n\n},{\"../components/_componentsModule\":1,\"../js/directives/_directivesModule\":23,\"../js/services/_servicesModule\":34,\"./_offlineModule\":42}],44:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.IframeLoaded = void 0;\r\nclass IframeLoaded {\r\n    constructor() {\r\n        this.restrict = 'A';\r\n    }\r\n    link(scope, element) {\r\n        element.on('load', () => {\r\n            var _a;\r\n            const iframe = element.contentWindow || element.contentDocument;\r\n            if (iframe && iframe.document.getElementById('umbracoPreviewBadge')) {\r\n                iframe.document.getElementById('umbracoPreviewBadge').style.display = 'none';\r\n            }\r\n            const resultFrame = document.getElementById('resultFrame');\r\n            if (!((_a = resultFrame === null || resultFrame === void 0 ? void 0 : resultFrame.contentWindow) === null || _a === void 0 ? void 0 : _a['refreshLayout'])) {\r\n                scope.vm.frameLoaded = true;\r\n                scope.$apply();\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.IframeLoaded = IframeLoaded;\r\nIframeLoaded.directiveName = 'iframeLoaded';\r\n\n},{}],45:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.OfflineController = void 0;\r\nconst constants_1 = require(\"../js/constants\");\r\nconst enums_1 = require(\"../js/models/enums\");\r\nclass OfflineController {\r\n    constructor($rootScope, $timeout, plmbrStateFactory, plmbrWorkflowResource, plmbrActionsService) {\r\n        this.getState = () => {\r\n            this.workflowResource.getPathAndType(this.nodeId)\r\n                .then(pathAndType => {\r\n                this.stateFactory.getOfflineState({ content: pathAndType })\r\n                    .then(state => {\r\n                    if (!state.currentTask.userGroup.offlineApproval) {\r\n                        this.invalid = true;\r\n                        return;\r\n                    }\r\n                    this.detail = () => this.actionsService.offlineDetail(state.currentTask, state);\r\n                });\r\n            });\r\n        };\r\n        /**\r\n         * Extract cookie\r\n         * @param {any} a = the cookie key\r\n         */\r\n        this.getCookie = (a) => {\r\n            let d = [];\r\n            let e = document.cookie.split(';');\r\n            let regex = RegExp(`^\\\\s*${a}=\\\\s*(.*?)\\\\s*$`);\r\n            for (let b = 0; b < e.length; b++) {\r\n                const f = e[b].match(regex);\r\n                if (f) {\r\n                    d.push(f[1]);\r\n                }\r\n            }\r\n            return d;\r\n        };\r\n        this.workflowResource = plmbrWorkflowResource;\r\n        this.stateFactory = plmbrStateFactory;\r\n        this.actionsService = plmbrActionsService;\r\n        this.frameLoaded = false;\r\n        // if the cookie exists, the request is invalid \r\n        this.invalid = this.getCookie('Workflow_Offline').length > 0;\r\n        const segments = window.location.pathname.split('/');\r\n        if (segments && segments.length === 7) {\r\n            // domain/path/nodeid/culture/userid/taskid/guid\r\n            const [, , nodeId, culture, , ,] = segments;\r\n            this.culture = culture === '0' ? '*' : culture;\r\n            this.nodeId = +nodeId;\r\n            // v8 path can have aspx, v9 can not\r\n            this.pageUrl = `/${this.nodeId}?culture=${this.culture === '*' ? '' : culture}`;\r\n            if (!this.invalid) {\r\n                this.getState();\r\n            }\r\n        }\r\n        else {\r\n            this.invalid = true;\r\n        }\r\n        this.showFooter = !this.invalid;\r\n        $rootScope.$on(constants_1.constants.events.workflowActioned, (_, data) => {\r\n            if (this.nodeId !== data.nodeId)\r\n                return;\r\n            if (data.status.includes(enums_1.WorkflowStatus.Approved)) {\r\n                this.showFooter = false;\r\n            }\r\n            else {\r\n                this.invalid = true;\r\n            }\r\n        });\r\n        $rootScope.$on('appState.editors.open', (_, args) => args && args.editor.view.endsWith('workflow.detail.overlay.html')\r\n            ? this.infiniteMode = true : {});\r\n        $rootScope.$on('appState.editors.close', (_, args) => args && args.editor.view.endsWith('workflow.detail.overlay.html')\r\n            ? $timeout(() => this.infiniteMode = false, 320) : {});\r\n    }\r\n}\r\nexports.OfflineController = OfflineController;\r\nOfflineController.controllerName = 'workflow.offline.controller';\r\n\n},{\"../js/constants\":22,\"../js/models/enums\":28}]},{},[43,44,45,42]);\n"],"file":"plumber-offline.js"}