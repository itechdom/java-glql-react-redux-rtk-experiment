{"version":3,"names":[],"mappings":"","sources":["plumber.js"],"sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ActiveModule = void 0;\r\nconst active_overview_controller_1 = require(\"./active.overview.controller\");\r\nexports.ActiveModule = angular\r\n    .module('plumber.active', [])\r\n    .controller(active_overview_controller_1.ActiveController.controllerName, active_overview_controller_1.ActiveController).name;\r\n\n},{\"./active.overview.controller\":2}],2:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ActiveController = void 0;\r\nclass ActiveController {\r\n    constructor(localizationService, authResource, plmbrSettingsResource, plmbrWorkflowResource) {\r\n        this.authResource = authResource;\r\n        this.filters = {};\r\n        // array of filter keys to disable in the overlay\r\n        this.disabledFilters = ['status', 'completed'];\r\n        this.perPage = 10;\r\n        this.$onInit = () => {\r\n            this.authResource.getCurrentUser()\r\n                .then((user) => {\r\n                this.userId = user.id;\r\n                this.fetch();\r\n            });\r\n        };\r\n        this.workflowResource = plmbrWorkflowResource;\r\n        localizationService.localize('treeHeaders_active')\r\n            .then(resp => this.sectionName = resp);\r\n        plmbrSettingsResource.setTreeState();\r\n    }\r\n    onFilter(filters) {\r\n        this.filters = filters;\r\n        this.fetch();\r\n    }\r\n    fetch(perPage = this.perPage) {\r\n        this.activeWorkflowsModel = {\r\n            userId: this.userId,\r\n            adminUser: true,\r\n            perPage,\r\n            filters: this.filters,\r\n            handler: this.workflowResource.getActiveInstances\r\n        };\r\n    }\r\n}\r\nexports.ActiveController = ActiveController;\r\nActiveController.controllerName = 'Workflow.Active.Controller';\r\n\n},{}],3:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst _componentsModule_1 = require(\"./components/_componentsModule\");\r\nconst _controllersModule_1 = require(\"./js/controllers/_controllersModule\");\r\nconst _directivesModule_1 = require(\"./js/directives/_directivesModule\");\r\nconst _filtersModule_1 = require(\"./js/filters/_filtersModule\");\r\nconst _servicesModule_1 = require(\"./js/services/_servicesModule\");\r\nconst _approvalGroupsModule_1 = require(\"./approval-groups/_approvalGroupsModule\");\r\nconst _documentationModule_1 = require(\"./documentation/_documentationModule\");\r\nconst _historyModule_1 = require(\"./history/_historyModule\");\r\nconst _licensingModule_1 = require(\"./licensing/_licensingModule\");\r\nconst _settingsModule_1 = require(\"./settings/_settingsModule\");\r\nconst _activeModule_1 = require(\"./active/_activeModule\");\r\nconst name = 'plumber';\r\nangular.module(name, [\r\n    _servicesModule_1.ServicesModule,\r\n    _directivesModule_1.DirectivesModule,\r\n    _componentsModule_1.ComponentsModule,\r\n    _controllersModule_1.ControllersModule,\r\n    _filtersModule_1.FiltersModule,\r\n    _approvalGroupsModule_1.ApprovalGroupsModule,\r\n    _documentationModule_1.DocumentationModule,\r\n    _historyModule_1.HistoryModule,\r\n    _licensingModule_1.LicensingModule,\r\n    _settingsModule_1.SettingsModule,\r\n    _activeModule_1.ActiveModule,\r\n])\r\n    .config(['$provide', $provide => {\r\n        $provide.decorator(\"$rootScope\", $delegate => {\r\n            // this is the earliest we can detect the content load event - before any of our \r\n            // component ctors run, as soon as Umbraco receives the data. If Plumber is loaded for the \r\n            // current view, hide the footer buttons until we know what to do with them\r\n            // However, since the footer element won't be rendered yet, do this via a class on the body element\r\n            // footer is restored in app.controller => updateButtons\r\n            $delegate.$on('content.loaded', (_, data) => {\r\n                if (data.content.apps.find(a => a.alias === 'workflow')) {\r\n                    document.body.classList.add('wf-footer-buttons--out');\r\n                }\r\n            });\r\n            //var Scope = $delegate.constructor;\r\n            //var origBroadcast = Scope.prototype.$broadcast;\r\n            //var origEmit = Scope.prototype.$emit;\r\n            //Scope.prototype.$broadcast = function () {\r\n            //    console.log(\"$broadcast was called on $scope \" + Scope.$id + \" with arguments:\", arguments);\r\n            //    return origBroadcast.apply(this, arguments);\r\n            //};\r\n            //Scope.prototype.$emit = function () {\r\n            //    console.log(\"$emit was called on $scope \" + Scope.$id + \" with arguments:\", arguments);\r\n            //    return origEmit.apply(this, arguments);\r\n            //};\r\n            return $delegate;\r\n        });\r\n    }]);\r\nangular.module('umbraco').requires.push(name);\r\n\n},{\"./active/_activeModule\":1,\"./approval-groups/_approvalGroupsModule\":4,\"./components/_componentsModule\":9,\"./documentation/_documentationModule\":31,\"./history/_historyModule\":33,\"./js/controllers/_controllersModule\":36,\"./js/directives/_directivesModule\":42,\"./js/filters/_filtersModule\":47,\"./js/services/_servicesModule\":56,\"./licensing/_licensingModule\":64,\"./settings/_settingsModule\":66}],4:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ApprovalGroupsModule = void 0;\r\nconst groups_edit_controller_1 = require(\"./groups.edit.controller\");\r\nconst groups_overview_controller_1 = require(\"./groups.overview.controller\");\r\nconst groups_history_controller_1 = require(\"./groups.history.controller\");\r\nconst groups_delete_dialog_controller_1 = require(\"./groups.delete.dialog.controller\");\r\nexports.ApprovalGroupsModule = angular\r\n    .module('plumber.approvalGroups', [])\r\n    .controller(groups_edit_controller_1.EditGroupController.controllerName, groups_edit_controller_1.EditGroupController)\r\n    .controller(groups_history_controller_1.GroupsHistoryController.controllerName, groups_history_controller_1.GroupsHistoryController)\r\n    .controller(groups_delete_dialog_controller_1.GroupsDeleteDialogController.controllerName, groups_delete_dialog_controller_1.GroupsDeleteDialogController)\r\n    .controller(groups_overview_controller_1.GroupsOverviewController.controllerName, groups_overview_controller_1.GroupsOverviewController).name;\r\n\n},{\"./groups.delete.dialog.controller\":5,\"./groups.edit.controller\":6,\"./groups.history.controller\":7,\"./groups.overview.controller\":8}],5:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GroupsDeleteDialogController = void 0;\r\nclass GroupsDeleteDialogController {\r\n    constructor($scope, localizationService, plumberHub) {\r\n        this.plumberHub = plumberHub;\r\n        this.messages = [];\r\n        $scope.model.disableSubmitButton = true;\r\n        $scope.$watch(() => $scope.model.groupNameConfirmed, groupNameConfirmed => $scope.model.disableSubmitButton = groupNameConfirmed !== $scope.model.groupName);\r\n        localizationService.localize('workflow_deleteGroupWarning', [$scope.model.groupName])\r\n            .then(deleteGroupWarning => this.deleteGroupWarning = deleteGroupWarning);\r\n    }\r\n    $onInit() {\r\n        // subscribe to signalr magick\r\n        this.plumberHub.initHub(hub => {\r\n            this.hub = hub;\r\n            this.hub.on('workflowAction', data => this.messages.push({ key: data[0], value: data[1] }));\r\n            this.hub.start();\r\n        });\r\n    }\r\n}\r\nexports.GroupsDeleteDialogController = GroupsDeleteDialogController;\r\nGroupsDeleteDialogController.controllerName = 'Workflow.Groups.Delete.Dialog.Controller';\r\n\n},{}],6:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.EditGroupController = void 0;\r\nconst constants_1 = require(\"../js/constants\");\r\nconst pagination_1 = require(\"../js/models/pagination\");\r\nclass EditGroupController {\r\n    constructor(plmbrGroupsResource, plmbrSettingsResource, $q, $scope, $route, $rootScope, $location, formHelper, editorService, localizationService, userGroupsResource, overlayService, navigationService) {\r\n        this.$q = $q;\r\n        this.$scope = $scope;\r\n        this.$route = $route;\r\n        this.$rootScope = $rootScope;\r\n        this.$location = $location;\r\n        this.formHelper = formHelper;\r\n        this.editorService = editorService;\r\n        this.localizationService = localizationService;\r\n        this.userGroupsResource = userGroupsResource;\r\n        this.overlayService = overlayService;\r\n        this.navigationService = navigationService;\r\n        this.chartRange = 28;\r\n        this.loaded = false;\r\n        this.infiniteMode = false;\r\n        this.inheritedGroups = [];\r\n        this.distinctNodePermissions = [];\r\n        this.distinctDocPermissions = [];\r\n        this.nodePermissions = [];\r\n        this.docPermissions = [];\r\n        this.nodePermissionsPagination = new pagination_1.Pagination(() => this.getNodePermissionsPage());\r\n        this.docPermissionsPagination = new pagination_1.Pagination(() => this.getDocPermissionsPage());\r\n        this.$onInit = () => {\r\n            this.mculture = this.$location.search().mculture;\r\n            const promises = [\r\n                this.localizationService.localizeMany([\r\n                    'workflow_settings', 'workflow_roles',\r\n                    'workflow_members', 'workflow_history',\r\n                    'workflow_stage', 'workflow_multiVariantWorkflow'\r\n                ])\r\n            ];\r\n            this.$q.all(promises)\r\n                .then(resp => {\r\n                var _a;\r\n                [this.settingsStr, this.rolesStr, this.membersStr, this.historyStr, this.stageStr, this.multiVariantStr] = resp[0];\r\n                this.setNavigation();\r\n                /**\r\n                 * Fetch the group by the given id, or create an empty model if the id is -1 (ie a new group - id doesn't exist until saving)\r\n                 * groupId can be on the route param, or on $scope.model if opening in an infinite editor\r\n                 */\r\n                let groupId = -1;\r\n                if ((_a = this.$scope.model) === null || _a === void 0 ? void 0 : _a.groupId) {\r\n                    this.infiniteMode = true;\r\n                    groupId = this.$scope.model.groupId;\r\n                }\r\n                else if (this.$route.current.params.id && +this.$route.current.params.id !== -1) {\r\n                    groupId = +this.$route.current.params.id;\r\n                }\r\n                // if groupId === -1, get an empty scaffold for a new group\r\n                this.workflowGroupsResource.get(groupId)\r\n                    .then(group => {\r\n                    this.group = group;\r\n                    if (this.group.permissions) {\r\n                        this.getContentTypes();\r\n                    }\r\n                    if (this.group.inheritMembers) {\r\n                        this.getInheritedGroups();\r\n                    }\r\n                    for (let u of this.group.users) {\r\n                        u.id = u.userId; // makes userpicker work\r\n                    }\r\n                    if (this.group.groupEmail && Object.keys(this.group.availableLanguages).length === 1 && !this.group.groupLanguage) {\r\n                        this.group.groupLanguage = Object.keys(this.group.availableLanguages)[0];\r\n                    }\r\n                    this.loaded = true;\r\n                });\r\n                if (!this.infiniteMode) {\r\n                    this.workflowSettingsResource.setTreeState();\r\n                }\r\n            });\r\n        };\r\n        this.updateChartRange = range => this.chartRange = range;\r\n        this.setNavigation = () => {\r\n            const pluginPath = Umbraco.Sys.ServerVariables.Plumber.pluginPath;\r\n            this.navigation = [\r\n                {\r\n                    name: this.settingsStr,\r\n                    alias: 'settings',\r\n                    icon: 'icon-settings',\r\n                    view: `${pluginPath}/approval-groups/partials/settings.html`,\r\n                    active: true\r\n                }, {\r\n                    name: this.rolesStr,\r\n                    alias: 'roles',\r\n                    icon: 'icon-keychain',\r\n                    view: `${pluginPath}/approval-groups/partials/roles.html`\r\n                }, {\r\n                    name: this.membersStr,\r\n                    alias: 'members',\r\n                    icon: 'icon-users',\r\n                    view: `${pluginPath}/approval-groups/partials/members.html`\r\n                }, {\r\n                    name: this.historyStr,\r\n                    alias: 'history',\r\n                    icon: 'icon-alarm-clock',\r\n                    view: `${pluginPath}/approval-groups/partials/history.html`\r\n                }\r\n            ];\r\n        };\r\n        /**\r\n         * */\r\n        this.getInheritedGroups = () => {\r\n            this.userGroupsResource.getUserGroups()\r\n                .then(resp => {\r\n                var _a, _b;\r\n                let ids = (_b = (_a = this.group) === null || _a === void 0 ? void 0 : _a.inheritMembers) === null || _b === void 0 ? void 0 : _b.split(',');\r\n                this.inheritedGroups = resp.filter(g => ids === null || ids === void 0 ? void 0 : ids.some(i => +i === g.id));\r\n            });\r\n        };\r\n        /**\r\n         * */\r\n        this.getInheritedGroupMembers = () => {\r\n            if (!this.group.inheritMembers)\r\n                return;\r\n            this.workflowGroupsResource.getInheritedMembers(this.group.inheritMembers.split(','))\r\n                .then(resp => {\r\n                // remove existing inherited members\r\n                this.group.users = this.group.users.filter(x => !x.inherited);\r\n                // remove duplicates - user may be in multiple groups\r\n                let users = Array.from(new Set(resp));\r\n                // only keep users not explicitly assigned\r\n                users = users.filter(u => !this.group.users.some(x => x.userId === u.userId));\r\n                // only keep those we have room for - explicit takes priority, then topped up from inherited\r\n                if (users.length && this.license.maxGroups !== -1) {\r\n                    let capacity = this.license.maxGroups - this.group.users.length;\r\n                    users = capacity ? users.slice(0, capacity - 1) : [];\r\n                }\r\n                this.group.users = [...this.group.users, ...users];\r\n            });\r\n        };\r\n        this.getNodePermissionsPage = () => {\r\n            const from = (this.nodePermissionsPagination.pageNumber - 1) * this.nodePermissionsPagination.perPage;\r\n            const to = from + this.nodePermissionsPagination.perPage;\r\n            const ids = this.distinctNodePermissions.slice(from, to);\r\n            this.workflowGroupsResource.getContentSlim(ids)\r\n                .then(resp => {\r\n                this.pagedNodePermissions = [];\r\n                resp.forEach(v => {\r\n                    this.nodePermissions.forEach(p => {\r\n                        if (p.nodeId === v.nodeId) {\r\n                            p.icon = v.icon;\r\n                            p.path = v.path;\r\n                            p.trashed = v.trashed;\r\n                            p.name = this.getNodeName(p, p.nodeName);\r\n                            this.pagedNodePermissions.push(p);\r\n                        }\r\n                    });\r\n                });\r\n            });\r\n        };\r\n        this.getDocPermissionsPage = () => {\r\n            const from = (this.docPermissionsPagination.pageNumber - 1) * this.docPermissionsPagination.perPage;\r\n            const to = from + this.docPermissionsPagination.perPage;\r\n            this.pagedDocPermissions = this.docPermissions.slice(from, to);\r\n        };\r\n        /**\r\n         * paging for node permissions is serverside, paging for content types is client side\r\n         * will have a lot more node permissions than content type\r\n         * */\r\n        this.getContentTypes = () => {\r\n            var _a, _b, _c, _d;\r\n            this.nodePermissions = (_b = (_a = this.group.permissions) === null || _a === void 0 ? void 0 : _a.filter(v => v.nodeId)) !== null && _b !== void 0 ? _b : [];\r\n            this.docPermissions = (_d = (_c = this.group.permissions) === null || _c === void 0 ? void 0 : _c.filter(v => v.contentTypeId)) !== null && _d !== void 0 ? _d : [];\r\n            if (this.nodePermissions.length) {\r\n                this.distinctNodePermissions = [...new Set(this.nodePermissions.map(v => v.nodeId))];\r\n                this.nodePermissionsPagination.totalPages = Math.ceil(this.nodePermissions.length / this.nodePermissionsPagination.perPage);\r\n                this.getNodePermissionsPage();\r\n            }\r\n            if (this.docPermissions.length) {\r\n                this.docPermissionsPagination.totalPages = Math.ceil(this.docPermissions.length / this.docPermissionsPagination.perPage);\r\n                // todo => only get required types\r\n                this.workflowSettingsResource.getContentTypes()\r\n                    .then(resp => {\r\n                    resp.forEach(v => {\r\n                        this.docPermissions.forEach(p => {\r\n                            if (p.contentTypeId === v.id) {\r\n                                p.icon = v.icon;\r\n                                p.path = v.path;\r\n                                p.name = this.getNodeName(p, p.contentTypeName);\r\n                            }\r\n                        });\r\n                    });\r\n                });\r\n            }\r\n        };\r\n        this.editDocTypePermission = () => {\r\n            this.$location.search('mculture', this.mculture);\r\n            this.$location.path('/workflow/settings/overview');\r\n        };\r\n        /**\r\n         * Build the node name to include the stage and variant where appropriate\r\n         * @param {any} node\r\n         * @param {any} base\r\n         */\r\n        this.getNodeName = (node, base) => {\r\n            let name = `${base} - ${this.stageStr.toLowerCase()} ${node.permission + 1}`;\r\n            if (node.nodeId === Umbraco.Sys.ServerVariables.Plumber.newNodeFlowId)\r\n                return name;\r\n            const variant = node.variant === '*' ? this.multiVariantStr : node.variant;\r\n            name += Object.keys(this.group.availableLanguages).length > 1 ? ` (${variant})` : '';\r\n            return name;\r\n        };\r\n        // todo -> Would be sweet to open the config dialog from here, rather than just navigating to the node...\r\n        this.editContentPermission = (id) => {\r\n            this.navigationService.changeSection('content');\r\n            this.$location.search('app', 'workflow');\r\n            this.$location.search('view', 'config');\r\n            this.$location.search('mculture', this.mculture);\r\n            this.$location.path(`/content/content/edit/${id}`);\r\n        };\r\n        /**\r\n         * Remove a user from the group\r\n         * @param {any} id\r\n         */\r\n        this.remove = (id) => {\r\n            const index = this.group.users.findIndex(u => u.userId === id);\r\n            this.group.users.splice(index, 1);\r\n            // refresh the inherited member list, as removing an explicit may re-include the user via inheritance\r\n            if (this.inheritedGroups.length) {\r\n                this.getInheritedGroupMembers();\r\n            }\r\n        };\r\n        /**\r\n         * Remove an inherited group from the group\r\n         * @param {any} id\r\n         */\r\n        this.removeInherited = (id) => {\r\n            var _a;\r\n            const index = this.inheritedGroups.findIndex(g => g.id === id);\r\n            this.inheritedGroups.splice(index, 1);\r\n            let groupIds = (_a = this.group.inheritMembers) === null || _a === void 0 ? void 0 : _a.split(',').filter(x => +x !== id);\r\n            this.group.inheritMembers = groupIds === null || groupIds === void 0 ? void 0 : groupIds.join(',');\r\n            this.getInheritedGroupMembers();\r\n        };\r\n        /**\r\n         * Open the picker to add a new user to the group\r\n         */\r\n        this.openUserPicker = () => {\r\n            const userPickerOptions = {\r\n                selection: [...this.group.users.filter(x => !x.inherited)],\r\n                submit: (model) => {\r\n                    // can't directly assign as will wipe inherited members\r\n                    model.selection.forEach(s => {\r\n                        // if user is in group already, make sure they're not inherited\r\n                        // then add the new user if not in the group\r\n                        let existing = this.group.users.find(u => u.userId === s.id);\r\n                        if (existing && existing.inherited) {\r\n                            existing.inherited = false;\r\n                        }\r\n                        else if (!existing) {\r\n                            this.group.users.push({\r\n                                userId: s.id,\r\n                                id: s.id,\r\n                                name: s.name,\r\n                                inherited: false,\r\n                                email: s.email,\r\n                            });\r\n                        }\r\n                    });\r\n                    this.editorService.close();\r\n                },\r\n                close: () => this.editorService.close()\r\n            };\r\n            this.editorService.userPicker(userPickerOptions);\r\n        };\r\n        /**\r\n         * Open the picker to select a group for inheritance\r\n         */\r\n        this.openGroupPicker = () => {\r\n            const groupPickerOptions = {\r\n                selection: [...this.inheritedGroups],\r\n                submit: (model) => {\r\n                    this.group.inheritMembers = model.selection.map(g => g.id).join(',');\r\n                    this.inheritedGroups = model.selection;\r\n                    this.getInheritedGroupMembers();\r\n                    this.editorService.close();\r\n                },\r\n                close: () => {\r\n                    this.editorService.close();\r\n                }\r\n            };\r\n            this.editorService.userGroupPicker(groupPickerOptions);\r\n        };\r\n        this.delete = () => {\r\n            let submitted = false;\r\n            this.overlayService.open({\r\n                view: `${Umbraco.Sys.ServerVariables.Plumber.viewsPath}overlays/deletegroup.confirm.overlay.html`,\r\n                submitButtonLabelKey: 'general_delete',\r\n                submitButtonStyle: 'danger',\r\n                groupName: this.group.name,\r\n                hideHeader: true,\r\n                submit: model => {\r\n                    model.hideSubmitButton = true;\r\n                    model.deleting = true;\r\n                    this.workflowGroupsResource.delete(this.group.groupId)\r\n                        .then(_ => {\r\n                        submitted = true;\r\n                        model.deleting = false;\r\n                    });\r\n                },\r\n                close: () => {\r\n                    this.overlayService.close();\r\n                    if (submitted) {\r\n                        this.$location.search('mculture', this.mculture);\r\n                        this.$location.path('/workflow/approval-groups/overview');\r\n                        this.$rootScope.$emit(constants_1.constants.events.refreshGroups);\r\n                    }\r\n                }\r\n            });\r\n        };\r\n        /**\r\n         * Save the group and show appropriate notifications\r\n         */\r\n        this.save = () => {\r\n            if (this.formHelper.submitForm({ scope: this.$scope })) {\r\n                this.saveButtonState = constants_1.constants.states.busy;\r\n                // user model needs to be simplified to send the expected poco - userId and groupId.\r\n                // todo => naughty naughty\r\n                const model = JSON.parse(JSON.stringify(this.group));\r\n                // only save explicit users, inherited are set from the group id on demand\r\n                model.users = model.users.filter(x => !x.inherited);\r\n                for (let u of model.users) {\r\n                    delete u.name;\r\n                    delete u.id;\r\n                    u.groupId = model.groupId;\r\n                }\r\n                this.workflowGroupsResource.save(model)\r\n                    .then(resp => {\r\n                    this.formHelper.resetForm({ scope: this.$scope });\r\n                    this.saveButtonState = constants_1.constants.states.success;\r\n                    if (this.infiniteMode) {\r\n                        this.$scope.model.close();\r\n                        return;\r\n                    }\r\n                    if (this.$route.current.params.create) {\r\n                        this.$route.updateParams({ id: resp.group.groupId });\r\n                        this.$location.search('create', null).replace();\r\n                        this.$rootScope.$emit(constants_1.constants.events.refreshGroups);\r\n                    }\r\n                }, _ => {\r\n                    this.saveButtonState = constants_1.constants.states.error;\r\n                });\r\n            }\r\n        };\r\n        this.workflowGroupsResource = plmbrGroupsResource;\r\n        this.workflowSettingsResource = plmbrSettingsResource;\r\n        this.license = Umbraco.Sys.ServerVariables.Plumber.license;\r\n    }\r\n}\r\nexports.EditGroupController = EditGroupController;\r\nEditGroupController.controllerName = 'Workflow.Groups.Edit.Controller';\r\n\n},{\"../js/constants\":35,\"../js/models/pagination\":52}],7:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GroupsHistoryController = void 0;\r\nconst pagination_1 = require(\"../js/models/pagination\");\r\nclass GroupsHistoryController {\r\n    constructor($scope, $routeParams, plmbrWorkflowResource) {\r\n        this.$scope = $scope;\r\n        this.$routeParams = $routeParams;\r\n        this.filters = {};\r\n        this.perPage = 10;\r\n        this.pagination = new pagination_1.Pagination(() => this.fetch(), 10);\r\n        /**\r\n         *\r\n         */\r\n        this.fetch = (perPage = this.perPage, currentPage = this.pagination.pageNumber) => {\r\n            this.model = {\r\n                perPage,\r\n                currentPage,\r\n                groupId: this.groupId,\r\n                filters: this.filters,\r\n                handler: this.workflowResource.getAllTasksForGroup,\r\n            };\r\n        };\r\n        this.workflowResource = plmbrWorkflowResource;\r\n        this.workflowResource.setTreeState();\r\n    }\r\n    $onInit() {\r\n        var _a;\r\n        this.groupId = +(((_a = this.$scope.model.group) === null || _a === void 0 ? void 0 : _a.groupId) || this.$routeParams.id);\r\n        this.fetch();\r\n    }\r\n    onFilter(filters) {\r\n        this.filters = filters;\r\n        this.fetch(this.perPage, 1);\r\n    }\r\n}\r\nexports.GroupsHistoryController = GroupsHistoryController;\r\nGroupsHistoryController.controllerName = 'Workflow.Groups.History.Controller';\r\n\n},{\"../js/models/pagination\":52}],8:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GroupsOverviewController = void 0;\r\nconst pagination_1 = require(\"../js/models/pagination\");\r\nclass GroupsOverviewController {\r\n    constructor($scope, $location, languageResource, plmbrGroupsResource, localizationService, plmbrWorkflowResource) {\r\n        this.$location = $location;\r\n        this.languageResource = languageResource;\r\n        this.pagination = new pagination_1.Pagination(() => this.fetch());\r\n        this.$onDestroy = () => {\r\n            this.watchSearch();\r\n        };\r\n        this.$onInit = () => {\r\n            this.mculture = this.$location.search().mculture;\r\n            this.fetch();\r\n        };\r\n        this.setLabels = () => {\r\n            this.items.forEach(i => i.permissions ? i.permissions.forEach(p => {\r\n                var _a;\r\n                const type = (_a = p.contentTypeName) !== null && _a !== void 0 ? _a : p.nodeName;\r\n                let label = `${type} - stage ${p.permission + 1}`;\r\n                //check this is the only lang, add variant name if not\r\n                if (this.languageCount > 1) {\r\n                    label += ` (${p.variant})`;\r\n                }\r\n                p.label = label;\r\n            }) : {});\r\n        };\r\n        this.fetch = () => {\r\n            this.workflowGroupsResource.getPage(this.pagination.pageNumber, this.pagination.perPage, this.search)\r\n                .then((resp) => {\r\n                this.loading = false;\r\n                this.items = resp.items;\r\n                if (!this.languageCount) {\r\n                    this.languageResource.getAll()\r\n                        .then(languages => {\r\n                        this.languageCount = languages.length;\r\n                        this.setLabels();\r\n                    });\r\n                }\r\n                else {\r\n                    this.setLabels();\r\n                }\r\n                // only set once on initial request, as this has the the correct total\r\n                if (this.maxGroups === undefined) {\r\n                    this.maxGroups = this.groupLimit > 0 && resp.totalItems >= this.groupLimit;\r\n                }\r\n                this.pagination.totalPages = resp.totalPages;\r\n            });\r\n        };\r\n        this.createGroup = () => this.$location\r\n            .path('/workflow/approval-groups/edit/-1')\r\n            .search('create', 'true');\r\n        this.getEmail = (users) => users.map(v => v.email).join(';');\r\n        this.workflowGroupsResource = plmbrGroupsResource;\r\n        this.workflowResource = plmbrWorkflowResource;\r\n        this.groupLimit = Umbraco.Sys.ServerVariables.Plumber.license.maxGroups;\r\n        this.languageCount = Umbraco.Sys.ServerVariables.Plumber.languageCount;\r\n        localizationService.localize('treeHeaders_approval-groups')\r\n            .then(resp => this.sectionName = resp);\r\n        this.loading = true;\r\n        this.items = [];\r\n        this.workflowResource.setTreeState();\r\n        this.watchSearch = $scope.$watch(() => this.search, (newVal, oldVal) => {\r\n            if (newVal === oldVal)\r\n                return;\r\n            this.pagination.goToPage(1);\r\n        });\r\n    }\r\n}\r\nexports.GroupsOverviewController = GroupsOverviewController;\r\nGroupsOverviewController.controllerName = 'Workflow.Groups.Overview.Controller';\r\n\n},{\"../js/models/pagination\":52}],9:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ComponentsModule = void 0;\r\nconst action_1 = require(\"./action-workflow/action\");\r\nconst changedescription_1 = require(\"./changedescription/changedescription\");\r\nconst chart_1 = require(\"./chart/chart\");\r\nconst comments_1 = require(\"./comments/comments\");\r\nconst config_1 = require(\"./config/config\");\r\nconst contenttypeflow_1 = require(\"./contenttypeflow/contenttypeflow\");\r\nconst instances_1 = require(\"./instances/instances\");\r\nconst progress_1 = require(\"./progress/progress\");\r\nconst submit_1 = require(\"./submit-workflow/submit\");\r\nconst tasklist_1 = require(\"./tasklist/tasklist\");\r\nconst tasks_1 = require(\"./tasks/tasks\");\r\nconst workflowdiff_1 = require(\"./diff/workflowdiff\");\r\nconst scheduling_1 = require(\"./scheduling/scheduling\");\r\nconst applies_to_1 = require(\"./applies-to/applies-to\");\r\nconst datepicker_1 = require(\"./datepicker/datepicker\");\r\nconst history_1 = require(\"./history/history\");\r\nconst grouppicker_1 = require(\"./grouppicker/grouppicker\");\r\nconst pagesize_1 = require(\"./pagesize/pagesize\");\r\nconst filterpicker_1 = require(\"./filterpicker/filterpicker\");\r\nconst dayrange_1 = require(\"./dayrange/dayrange\");\r\nexports.ComponentsModule = angular\r\n    .module('plumber.components', [])\r\n    .component(action_1.WorkflowActionComponent.name, action_1.WorkflowActionComponent)\r\n    .component(changedescription_1.ChangeDescriptionComponent.name, changedescription_1.ChangeDescriptionComponent)\r\n    .component(chart_1.ChartComponent.name, chart_1.ChartComponent)\r\n    .component(comments_1.CommentsComponent.name, comments_1.CommentsComponent)\r\n    .component(config_1.ConfigComponent.name, config_1.ConfigComponent)\r\n    .component(contenttypeflow_1.ContentTypeFlowComponent.name, contenttypeflow_1.ContentTypeFlowComponent)\r\n    .component(instances_1.WorkflowInstancesComponent.name, instances_1.WorkflowInstancesComponent)\r\n    .component(progress_1.ProgressComponent.name, progress_1.ProgressComponent)\r\n    .component(submit_1.SubmitWorkflowComponent.name, submit_1.SubmitWorkflowComponent)\r\n    .component(tasklist_1.TaskListComponent.name, tasklist_1.TaskListComponent)\r\n    .component(tasks_1.TasksComponent.name, tasks_1.TasksComponent)\r\n    .component(workflowdiff_1.WorkflowDiffComponent.name, workflowdiff_1.WorkflowDiffComponent)\r\n    .component(scheduling_1.SchedulingComponent.name, scheduling_1.SchedulingComponent)\r\n    .component(applies_to_1.AppliesToComponent.name, applies_to_1.AppliesToComponent)\r\n    .component(datepicker_1.DatepickerComponent.name, datepicker_1.DatepickerComponent)\r\n    .component(history_1.HistoryComponent.name, history_1.HistoryComponent)\r\n    .component(grouppicker_1.WorkflowGroupPickerComponent.name, grouppicker_1.WorkflowGroupPickerComponent)\r\n    .component(pagesize_1.PageSizeComponent.name, pagesize_1.PageSizeComponent)\r\n    .component(filterpicker_1.FilterPickerComponent.name, filterpicker_1.FilterPickerComponent)\r\n    .component(dayrange_1.DayRangeComponent.name, dayrange_1.DayRangeComponent)\r\n    .name;\r\n\n},{\"./action-workflow/action\":10,\"./applies-to/applies-to\":11,\"./changedescription/changedescription\":12,\"./chart/chart\":13,\"./comments/comments\":14,\"./config/config\":15,\"./contenttypeflow/contenttypeflow\":16,\"./datepicker/datepicker\":17,\"./dayrange/dayrange\":18,\"./diff/workflowdiff\":19,\"./filterpicker/filterpicker\":20,\"./grouppicker/grouppicker\":21,\"./history/history\":22,\"./instances/instances\":23,\"./pagesize/pagesize\":24,\"./progress/progress\":25,\"./scheduling/scheduling\":26,\"./submit-workflow/submit\":27,\"./tasklist/tasklist\":28,\"./tasks/tasks\":29}],10:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WorkflowActionComponent = void 0;\r\nconst constants_1 = require(\"../../js/constants\");\r\nclass WorkflowAction {\r\n    constructor($scope, $rootScope, $window, $location, navigationService, localizationService, plmbrActionsService, plmbrStateFactory) {\r\n        this.$rootScope = $rootScope;\r\n        this.$window = $window;\r\n        this.$location = $location;\r\n        this.navigationService = navigationService;\r\n        this.buttonState = {\r\n            approve: 'init',\r\n            resubmit: 'init',\r\n            reject: 'init',\r\n            cancel: 'init',\r\n        };\r\n        this.comment = '';\r\n        this.commentMaxLength = 250;\r\n        this.currentAction = '';\r\n        this.invalidComment = false;\r\n        this.$onInit = () => {\r\n            this.setButtonSuffix();\r\n        };\r\n        /**\r\n         * If the app controller modifies state, we'll hear about it here, and update the view if required\r\n         * @param {any} changes\r\n         */\r\n        this.$onChanges = changes => {\r\n            if (changes.state && changes.state.currentValue.nodeId === this.state.nodeId) {\r\n                this.state = changes.state.currentValue;\r\n                this.setActivePermissions();\r\n                this.setButtonSuffix();\r\n                this.comment = null;\r\n            }\r\n        };\r\n        this.setButtonSuffix = () => {\r\n            if (!this.state || this.state.canAction) {\r\n                this.btnSuffix = '';\r\n                return;\r\n            }\r\n            this.btnSuffix = this.state.isAdmin && !this.state.canAction && !this.state.canResubmit ? this.asAdminStr : '';\r\n            if (this.state.currentTask) {\r\n                this.btnSuffix = this.state.currentTask.taskStatus === 2 && this.state.canResubmit ? '' : this.btnSuffix;\r\n            }\r\n        };\r\n        this.actionsService = plmbrActionsService;\r\n        this.stateFactory = plmbrStateFactory;\r\n        this.onButtonStateChanged = $rootScope.$on(constants_1.constants.events.buttonStateChanged, (_, data) => {\r\n            if (this.state && data.id === this.state.nodeId) {\r\n                this.buttonState[this.currentAction] = data.state;\r\n            }\r\n        });\r\n        localizationService.localizeMany(['workflow_action', 'workflow_asAdmin',])\r\n            .then((resp) => {\r\n            let [action, asAdmin] = resp;\r\n            this.actionStr = action;\r\n            this.asAdminStr = `(${asAdmin})`;\r\n            this.setButtonSuffix();\r\n        });\r\n        $scope.$on('$destroy', () => {\r\n            this.onButtonStateChanged();\r\n            this.listen ? this.listen() : {};\r\n        });\r\n    }\r\n    setActivePermissions() {\r\n        const key = this.state.currentTask.node.new && this.state.permissions.new.length ? 'new' : this.state.permissions.active;\r\n        this.activePermissions = this.state.permissions[key];\r\n    }\r\n    preview() {\r\n        // Build the correct path so both /#/ and #/ work.\r\n        // get the culture from mculture if nothing on state\r\n        let query = `id=${this.state.nodeId}`;\r\n        if (this.state.currentTask.variantCode && this.state.currentTask.variantCode !== '*') {\r\n            query += `#?culture=${this.state.currentTask.variantCode}`;\r\n        }\r\n        const redirect = Umbraco.Sys.ServerVariables.umbracoSettings.umbracoPath + '/preview/?' + query;\r\n        // Chromes popup blocker will kick in if a window is opened\r\n        // without the initial scoped request. This trick will fix that.\r\n        const previewWindow = this.$window.open('preview/?init=true', 'umbpreview');\r\n        if (previewWindow) {\r\n            previewWindow.location.href = redirect;\r\n        }\r\n    }\r\n    action(actionName) {\r\n        this.currentAction = actionName;\r\n        this.actionsService.action(this.state.currentTask, this.comment, actionName, this.state.offline);\r\n        this.comment = null;\r\n    }\r\n    goToNode() {\r\n        this.navigationService.changeSection('content');\r\n        this.$location.path(`/content/content/edit/${this.state.nodeId}`);\r\n        this.$rootScope.$emit(constants_1.constants.events.goToNode);\r\n    }\r\n    /**\r\n     * If the instance has status === error, the error message is on the author comment\r\n     * wrapped in square brackets. This extracts it.\r\n     * @returns {string} c\r\n     */\r\n    extractErrorFromComment() {\r\n        const c = this.state.currentTask.comment || '';\r\n        return c.substring(c.indexOf('[') + 1, c.length - 1);\r\n    }\r\n}\r\nexports.WorkflowActionComponent = {\r\n    name: 'workflowAction',\r\n    transclude: true,\r\n    templateUrl: 'src/plumber/backoffice/components/action-workflow/action.html',\r\n    bindings: {\r\n        state: '<',\r\n        instance: '<',\r\n        dashboard: '<',\r\n    },\r\n    controller: WorkflowAction\r\n};\r\n\n},{\"../../js/constants\":35}],11:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AppliesToComponent = void 0;\r\nclass AppliesTo {\r\n    constructor(localizationService) {\r\n        this.localizationService = localizationService;\r\n        this.$onInit = () => {\r\n            this.localizationService.localizeMany(['workflow_publishOnly', 'workflow_publishAndUnpublish', 'workflow_unpublishDisabled', 'workflow_appliesTo'])\r\n                .then(resp => {\r\n                this.publishOnly = resp[0];\r\n                this.publishAndUnpublish = resp[1];\r\n                this.unpublishDisabled = resp[2];\r\n                this.appliesTo = resp[3];\r\n            });\r\n        };\r\n    }\r\n}\r\nconst template = `\r\n    <div ng-disabled=\"$ctrl.disabled\" class=\"mt-2\">\r\n        <label class=\"control-label mb-0\" for=\"appliesTo\">{{ $ctrl.appliesTo }}</label>\r\n        <div>\r\n            <umb-radiobutton value=\"0\"\r\n                             name=\"appliesTo_0\"\r\n                             text=\"{{ $ctrl.publishAndUnpublish }}\"\r\n                             model=\"$ctrl.model\">\r\n            </umb-radiobutton>\r\n            <umb-radiobutton value=\"1\"\r\n                             name=\"appliesTo_1\"\r\n                             text=\"{{ $ctrl.publishOnly }}\"\r\n                             model=\"$ctrl.model\">\r\n            </umb-radiobutton>\r\n        </div>\r\n        <small ng-if=\"$ctrl.disabled\" class=\"mt-1\" style=\"display:inline-block\">\r\n            {{ $ctrl.unpublishDisabled }}\r\n        </small>\r\n    </div>`;\r\nexports.AppliesToComponent = {\r\n    name: 'appliesTo',\r\n    transclude: true,\r\n    bindings: {\r\n        model: '=',\r\n        disabled: '<',\r\n    },\r\n    template: template,\r\n    controller: AppliesTo\r\n};\r\n\n},{}],12:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ChangeDescriptionComponent = void 0;\r\nclass WorkflowChangeDescription {\r\n    constructor($q, assetsService, editorService, overlayService, plmbrGroupsResource, localizationService) {\r\n        this.editorService = editorService;\r\n        this.overlayService = overlayService;\r\n        this.plmbrGroupsResource = plmbrGroupsResource;\r\n        this.showDiffBtn = false;\r\n        this.$onChanges = changes => {\r\n            if (changes.state && changes.state.currentVersion) {\r\n                this.item = this.state.currentTask;\r\n            }\r\n        };\r\n        this.viewsPath = Umbraco.Sys.ServerVariables.Plumber.viewsPath;\r\n        const license = Umbraco.Sys.ServerVariables.Plumber.license;\r\n        this.unlicensed = !license || license.isTrial && !license.isImpersonating;\r\n        const promises = [\r\n            assetsService.loadJs('/umbraco/lib/jsdiff/diff.js'),\r\n            localizationService.localizeMany(['workflow_showDiff', 'workflow_viewAttachment', 'workflow_showDiff']),\r\n        ];\r\n        $q.all(promises).then(resp => {\r\n            let strings = [];\r\n            [this.loaded, strings] = resp;\r\n            this.showDiffStr = strings[0];\r\n            this.viewAttachmentBtnStr = strings[1];\r\n            this.showDiffBtnStr = strings[2];\r\n        });\r\n    }\r\n    $onInit() {\r\n        this.item = this.state ? this.state.currentTask : this.item;\r\n        this.showDiffBtn = !this.unlicensed && this.item.node.exists && !['cancelled', 'errored'].includes(this.item.cssStatus || '');\r\n        this.language = Umbraco.Sys.ServerVariables.Plumber.languageCount > 1 ? this.item.variantName : Umbraco.Sys.ServerVariables.Plumber.defaultCultureName;\r\n    }\r\n    showDiff() {\r\n        const diffOVerlay = {\r\n            view: `${this.viewsPath}overlays/workflow.diff.overlay.html`,\r\n            size: 'medium',\r\n            guid: this.getInstanceGuid(),\r\n            hideDescription: true,\r\n            title: `${this.showDiffStr}: ${this.item.node.name}`,\r\n            close: () => this.editorService.close()\r\n        };\r\n        this.editorService.open(diffOVerlay);\r\n    }\r\n    /**\r\n     * Only called on active tasks, so safe to check state as it will exist\r\n     * */\r\n    showGroupDetails() {\r\n        var _a, _b;\r\n        const overlayModel = {\r\n            view: `${Umbraco.Sys.ServerVariables.Plumber.viewsPath}overlays/groupdetail.overlay.html`,\r\n            submitButtonLabelKey: 'workflow_editGroup',\r\n            submitButtonStyle: 'primary',\r\n            hideSubmitButton: !((_a = this.state) === null || _a === void 0 ? void 0 : _a.isAdmin),\r\n            group: this.item.userGroup,\r\n            title: (_b = this.item.userGroup) === null || _b === void 0 ? void 0 : _b.name,\r\n            submit: model => {\r\n                this.overlayService.close();\r\n                this.plmbrGroupsResource.editGroup(model.group.groupId);\r\n            },\r\n            close: () => this.overlayService.close()\r\n        };\r\n        this.overlayService.open(overlayModel);\r\n    }\r\n    /**\r\n     * Since the component can receive either a task or instance, need to check the correct property for the guid\r\n     * */\r\n    getInstanceGuid() {\r\n        return this.item.hasOwnProperty('instanceGuid') ? this.item['instanceGuid'] : this.item['instance'].guid;\r\n    }\r\n}\r\nexports.ChangeDescriptionComponent = {\r\n    name: 'workflowChangeDescription',\r\n    transclude: true,\r\n    templateUrl: 'src/plumber/backoffice/components/changedescription/changedescription.html',\r\n    bindings: {\r\n        state: '<',\r\n        item: '<',\r\n    },\r\n    controller: WorkflowChangeDescription\r\n};\r\n\n},{}],13:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ChartComponent = void 0;\r\nclass WorkflowChart {\r\n    constructor($window, dateHelper, plmbrWorkflowResource) {\r\n        this.$window = $window;\r\n        this.dateHelper = dateHelper;\r\n        this.now = moment.utc().endOf('day');\r\n        this.totalApproved = 0;\r\n        this.totalCancelled = 0;\r\n        this.totalErrored = 0;\r\n        this.totalPending = 0;\r\n        this.loaded = false;\r\n        this.colorMap = {\r\n            approved: '#2bc37c',\r\n            pending: '#3544b1',\r\n            cancelled: '#eaddd5',\r\n            errored: '#ee5f5b',\r\n        };\r\n        this.$onChanges = change => {\r\n            var _a;\r\n            if ((_a = change.range) === null || _a === void 0 ? void 0 : _a.currentValue) {\r\n                this.getForRange();\r\n            }\r\n        };\r\n        this.emptySeries = (length) => Array.from({ length }, (_, i) => ({ x: this.earliest.clone().add(i, 'd'), y: 0 }));\r\n        this.buildChartSeries = items => {\r\n            this.showStatsBox = items.length > 0;\r\n            const validNames = ['Pending', 'Approved', 'Cancelled', 'Errored'];\r\n            const series = [];\r\n            const seriesNames = [];\r\n            this.earliest = this.now.clone().subtract(this.range - 1, 'd');\r\n            const pendingItems = this.emptySeries(this.range);\r\n            const approvedItems = this.emptySeries(this.range);\r\n            const cancelledItems = this.emptySeries(this.range);\r\n            const erroredItems = this.emptySeries(this.range);\r\n            const o = {\r\n                label: 'Pending',\r\n                borderColor: this.colorMap.pending,\r\n                backgroundColor: this.colorMap.pending,\r\n                data: pendingItems,\r\n                type: 'line',\r\n                fill: false\r\n            };\r\n            this.seconds = {\r\n                min: 0,\r\n                max: 0,\r\n                total: 0,\r\n            };\r\n            series.push(o);\r\n            seriesNames.push('Pending');\r\n            items.forEach(v => {\r\n                let statusName = (this.groupId ? v.statusName : v.status).split(' ')[0]; // `Pending Approval` becomes `Pending`\r\n                let cssStatus = v.cssStatus;\r\n                let completedDate = moment(v.completedDate ? v.completedDate.replace('Z', '') : null);\r\n                const createdDateKey = this.groupId ? 'requestedOn' : 'createdDate';\r\n                let createdDate = moment(v[createdDateKey].replace('Z', ''));\r\n                // rejected items are counted as pending\r\n                cssStatus = cssStatus === 'rejected' ? 'pendingapproval' : cssStatus;\r\n                statusName = statusName === 'Rejected' ? 'Pending' : statusName;\r\n                let seconds = (v.completedDate ? completedDate : moment()).diff(createdDate, 'seconds');\r\n                this.seconds.total += seconds;\r\n                this.seconds.max = Math.max(seconds, this.seconds.max);\r\n                this.seconds.min = Math.min(seconds, this.seconds.min);\r\n                if (!seriesNames.includes(statusName) && validNames.includes(statusName)) {\r\n                    const o = {\r\n                        label: statusName,\r\n                        borderColor: this.colorMap[cssStatus],\r\n                        backgroundColor: this.colorMap[cssStatus],\r\n                        data: cssStatus === 'approved' ? approvedItems : cssStatus === 'errored' ? erroredItems : cancelledItems\r\n                    };\r\n                    series.push(o);\r\n                    seriesNames.push(statusName);\r\n                }\r\n                const completedIndex = pendingItems.findIndex(item => item.x.dayOfYear() === completedDate.dayOfYear());\r\n                const createdIndex = pendingItems.findIndex(item => item.x.dayOfYear() === createdDate.dayOfYear());\r\n                pendingItems[createdIndex !== -1 ? createdIndex : 0].y += 1;\r\n                if (completedIndex !== -1) {\r\n                    pendingItems[completedIndex].y -= 1;\r\n                    if (cssStatus === 'approved') {\r\n                        this.totalApproved += 1;\r\n                        approvedItems[completedIndex].y += 1;\r\n                    }\r\n                    else if (cssStatus === 'cancelled') {\r\n                        this.totalCancelled += 1;\r\n                        cancelledItems[completedIndex].y += 1;\r\n                    }\r\n                    else if (cssStatus === 'errored') {\r\n                        this.totalErrored += 1;\r\n                        erroredItems[completedIndex].y += 1;\r\n                    }\r\n                    else if (cssStatus === 'pendingapproval') {\r\n                        this.totalPending += 1;\r\n                    }\r\n                }\r\n                else if (cssStatus === 'pendingapproval') {\r\n                    this.totalPending += 1;\r\n                }\r\n            });\r\n            // accumulate pending items\r\n            let pendingItemsData = series.find(x => x.label === 'Pending');\r\n            if (pendingItemsData) {\r\n                pendingItemsData.data.forEach((_, i) => {\r\n                    if (i > 0 && pendingItemsData) {\r\n                        pendingItemsData.data[i].y += pendingItemsData.data[i - 1].y;\r\n                    }\r\n                });\r\n            }\r\n            this.series = series;\r\n            this.averageSeconds = moment.duration(this.seconds.total / items.length, 'seconds');\r\n            this.maxSeconds = moment.duration(this.seconds.max, 'seconds');\r\n            this.minSeconds = moment.duration(this.seconds.min, 'seconds');\r\n            // finally, init the chart\r\n            this.drawChart();\r\n        };\r\n        this.getForRange = () => {\r\n            if (this.range > 0) {\r\n                this.totalApproved = 0;\r\n                this.totalCancelled = 0;\r\n                this.totalPending = 0;\r\n                this.totalErrored = 0;\r\n                this.seconds = {\r\n                    min: 0,\r\n                    max: 0,\r\n                    total: 0,\r\n                };\r\n                this.loaded = false;\r\n                // one less than range since current date is included\r\n                // if a group id exists, the endpoint is different\r\n                (this.groupId ?\r\n                    this.workflowResource.getAllTasksForGroupForRange(this.groupId, this.range - 1) :\r\n                    this.workflowResource.getAllInstancesForRange(this.range - 1))\r\n                    .then(resp => this.buildChartSeries(resp.items));\r\n            }\r\n        };\r\n        this.getActivity = filter => {\r\n            let statusValues = [\r\n                { key: 'Pending approval', value: '3' },\r\n                { key: 'Approved', value: '1' },\r\n                { key: 'Cancelled', value: '5' },\r\n                { key: 'Errored', value: '6' }\r\n            ];\r\n            const f = statusValues.find(x => x.key === filter);\r\n            const o = {\r\n                status: []\r\n            };\r\n            if (f) {\r\n                // if filtering pending, include rejected and resubmitted\r\n                if (filter !== 'Pending approval') {\r\n                    o.status = [f.value];\r\n                }\r\n                else {\r\n                    o.status = [3, 2, 7];\r\n                }\r\n            }\r\n            // if the key is NOT pending, filter by items completed inside the current range\r\n            if (filter !== 'Pending approval') {\r\n                let from = this.dateHelper.convertToServerStringTime(this.earliest, Umbraco.Sys.ServerVariables.application.serverTimeOffset);\r\n                o.completedFrom = from;\r\n            }\r\n            this.workflowResource.setActivityFilter(o);\r\n            this.$window.location = Umbraco.Sys.ServerVariables.umbracoSettings.umbracoPath +\r\n                '/#/workflow/history/overview';\r\n        };\r\n        this.drawChart = () => {\r\n            Chart.defaults.scale.gridLines.display = false;\r\n            Chart.defaults.scale.ticks.beginAtZero = true;\r\n            const chart = document.getElementById('chart');\r\n            if (!chart)\r\n                return;\r\n            const ctx = chart.getContext('2d');\r\n            if (this.chart && this.chart.destroy)\r\n                this.chart.destroy();\r\n            this.chart = new Chart(ctx, {\r\n                type: 'bar',\r\n                data: {\r\n                    labels: this.emptySeries(this.range).map(x => x.x.format('D MMM')),\r\n                    datasets: this.series\r\n                },\r\n                options: {\r\n                    scales: {\r\n                        yAxes: [\r\n                            {\r\n                                ticks: {\r\n                                    stepSize: 1,\r\n                                    maxTicksLimit: 5\r\n                                }\r\n                            }\r\n                        ],\r\n                        xAxes: [\r\n                            {\r\n                                time: {\r\n                                    stepSize: 4\r\n                                }\r\n                            }\r\n                        ]\r\n                    }\r\n                }\r\n            });\r\n            this.loaded = true;\r\n        };\r\n        this.workflowResource = plmbrWorkflowResource;\r\n    }\r\n}\r\nexports.ChartComponent = {\r\n    name: 'workflowChart',\r\n    transclude: true,\r\n    templateUrl: 'src/plumber/backoffice/components/chart/chart.html',\r\n    controller: WorkflowChart,\r\n    bindings: {\r\n        groupId: '<',\r\n        range: '<',\r\n    }\r\n};\r\n\n},{}],14:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.CommentsComponent = void 0;\r\nconst constants_1 = require(\"../../js/constants\");\r\nclass WorkflowComments {\r\n    constructor(localizationService, $sce, $rootScope) {\r\n        this.localizationService = localizationService;\r\n        this.$sce = $sce;\r\n        this.defaultMaxLength = 250;\r\n        this.maxLengthStr = '';\r\n        this.remainingStr = '';\r\n        this.$onInit = () => {\r\n            this.maxLength = this.maxLength || this.defaultMaxLength;\r\n            this.localizationService.localizeMany([this.labelKey || 'workflow_addComment', this.templateKey || '', 'workflow_commentRemaining', 'workflow_commentMaxLength'])\r\n                .then((resp) => {\r\n                this.labelStr = resp[0];\r\n                const template = resp[1];\r\n                this.remainingStr = resp[2];\r\n                this.maxLengthStr = resp[3].replace('%0%', this.maxLength.toString());\r\n                if (!template.startsWith('[') && !template.endsWith(']')) {\r\n                    this.comment = this.$sce.trustAsHtml(template);\r\n                    this.limitChars(template.length);\r\n                }\r\n                else {\r\n                    this.limitChars();\r\n                }\r\n            });\r\n        };\r\n        this.$onDestroy = () => {\r\n            this.onActioned();\r\n        };\r\n        /**\r\n         * Optionally provide a numeric value to set the initial counter\r\n         * Used when setting a template as the escaped string doesn't set the model\r\n         * until it is modified, but does have a length\r\n         * @param length\r\n         */\r\n        this.limitChars = (length) => {\r\n            var _a;\r\n            length = length || ((_a = this.comment) === null || _a === void 0 ? void 0 : _a.length);\r\n            if (length > this.maxLength) {\r\n                this.info = this.maxLengthStr;\r\n                this.comment = this.comment.substr(0, this.maxLength);\r\n                this.invalid = true;\r\n            }\r\n            else {\r\n                this.info = this.remainingStr.replace('%0%', (this.maxLength - (length || 0)).toString());\r\n                this.invalid = !length;\r\n            }\r\n        };\r\n        this.onActioned = $rootScope.$on(constants_1.constants.events.workflowActioned, () => {\r\n            this.limitChars();\r\n        });\r\n    }\r\n}\r\nconst template = `\r\n    <div class=\"umb-el-wrap\">\r\n        <label class=\"control-label\" for=\"workflowComment\">\r\n            {{ $ctrl.labelStr }}\r\n            <small ng-bind=\"$ctrl.info\"></small>\r\n        </label>\r\n        <div class=\"controls\">\r\n            <textarea\r\n                id=\"workflowComment\"\r\n                ng-model=\"$ctrl.comment\"\r\n                ng-change=\"$ctrl.limitChars()\"\r\n                no-dirty-check\r\n                umb-auto-focus\r\n                rows=\"5\"                     \r\n                class=\"umb-property-editor umb-textarea\"></textarea>\r\n        </div>\r\n    </div>`;\r\nexports.CommentsComponent = {\r\n    name: 'workflowComments',\r\n    transclude: true,\r\n    bindings: {\r\n        comment: '=',\r\n        maxLength: '<',\r\n        invalid: '=',\r\n        templateKey: '<',\r\n        labelKey: '<'\r\n    },\r\n    template: template,\r\n    controller: WorkflowComments\r\n};\r\n\n},{\"../../js/constants\":35}],15:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ConfigComponent = void 0;\r\nconst constants_1 = require(\"../../js/constants\");\r\nclass WorkflowConfig {\r\n    constructor($scope, $rootScope, $element, $location, editorService, plmbrGroupsResource, plmbrWorkflowResource) {\r\n        this.$scope = $scope;\r\n        this.$rootScope = $rootScope;\r\n        this.$element = $element;\r\n        this.$location = $location;\r\n        this.editorService = editorService;\r\n        this.sortOptions = {\r\n            axis: 'y',\r\n            containment: 'parent',\r\n            distance: 10,\r\n            opacity: 0.7,\r\n            tolerance: 'pointer',\r\n            scroll: true,\r\n            zIndex: 6000,\r\n            stop: () => { },\r\n        };\r\n        /**\r\n         * */\r\n        this.checkActiveType = () => {\r\n            this.activeType =\r\n                this.approvalPath.length || this.useNewNodePath ? 'content' :\r\n                    this.contentTypeApprovalPath.length ? 'type' :\r\n                        this.inherited.length ? 'inherited' : null;\r\n        };\r\n        this.workflowGroupsResource = plmbrGroupsResource;\r\n        this.workflowResource = plmbrWorkflowResource;\r\n        this.inherited = [];\r\n        this.approvalPath = [];\r\n        this.contentTypeApprovalPath = [];\r\n        this.sortOptions.stop = () => {\r\n            this.$scope.contentFlowForm.$setDirty();\r\n        };\r\n    }\r\n    /**\r\n     * Process the approvalPath object, then save it\r\n     */\r\n    save() {\r\n        // ensure everything being saved has the correct variant and appliesTo value\r\n        // need to make sure this doesn't break anything when the original path was inherited\r\n        // also ensures the permission is set correctly as the sort order may have changed\r\n        this.approvalPath.forEach((v, i) => {\r\n            v.variant = this.variant;\r\n            v.type = +this.appliesTo;\r\n            v.permission = i;\r\n        });\r\n        this.workflowResource.saveNodeConfig(this.node.id, this.approvalPath, this.variant, +this.appliesTo)\r\n            .then(() => {\r\n            this.$scope.contentFlowForm.$setPristine();\r\n            this.$element.inheritedData('$formController').$setPristine();\r\n            this.$rootScope.$emit(constants_1.constants.events.configSaved, { id: this.node.id });\r\n        });\r\n    }\r\n    /**\r\n     * */\r\n    openGroupOverlay() {\r\n        const model = {\r\n            view: Umbraco.Sys.ServerVariables.Plumber.viewsPath + '/overlays/grouppicker.overlay.html',\r\n            size: constants_1.constants.sizes.s,\r\n            title: 'Add workflow approval group/s',\r\n            approvalPath: this.approvalPath,\r\n            submit: (result) => {\r\n                result.selection.forEach(group => {\r\n                    this.add(group);\r\n                });\r\n                this.editorService.close();\r\n            },\r\n            close: () => this.editorService.close(),\r\n        };\r\n        this.editorService.open(model);\r\n    }\r\n    groupName(name, idx) {\r\n        return this.workflowGroupsResource.generateNameWithStage(name, idx);\r\n    }\r\n    editGroup(group) {\r\n        this.workflowGroupsResource.editGroup(group.groupId);\r\n    }\r\n    /**\r\n     * */\r\n    removeAll() {\r\n        this.approvalPath = [];\r\n        this.checkActiveType();\r\n        this.save();\r\n    }\r\n    /**\r\n     * Adds a stage to the approval flow\r\n     */\r\n    add(group) {\r\n        this.$scope.contentFlowForm.$setDirty();\r\n        this.approvalPath.push({\r\n            groupName: group.name,\r\n            nodeId: this.node.id,\r\n            permission: this.approvalPath.length,\r\n            groupId: group.groupId\r\n        });\r\n        this.checkActiveType();\r\n    }\r\n    /**\r\n     * Removes a stage from the approval flow\r\n     * @param {any} $event\r\n     * @param {any} item\r\n     */\r\n    remove(group) {\r\n        this.$scope.contentFlowForm.$setDirty();\r\n        const idx = this.approvalPath.findIndex(x => x.groupId === group.groupId);\r\n        this.approvalPath.splice(idx, 1);\r\n        this.approvalPath.forEach((v, i) => v.permission = i);\r\n        this.checkActiveType();\r\n        if (this.approvalPath.length === 0) {\r\n            this.save();\r\n        }\r\n    }\r\n    $onInit() {\r\n        const activeVariant = this.node.variants.find(x => x.active);\r\n        const isCreate = this.$location.search().create === 'true';\r\n        const variant = !isCreate && (activeVariant === null || activeVariant === void 0 ? void 0 : activeVariant.language) ? activeVariant.language.culture : this.$location.search().cculture;\r\n        this.variant = variant || Umbraco.Sys.ServerVariables.Plumber.defaultCulture;\r\n        this.useNewNodePath = !(activeVariant === null || activeVariant === void 0 ? void 0 : activeVariant.publishDate) && this.state.permissions.new.length > 0;\r\n        this.approvalPath = this.state.permissions.node;\r\n        this.contentTypeApprovalPath = this.state.permissions.contentType;\r\n        this.inherited = this.state.permissions.inherited;\r\n        this.newNodePath = this.state.permissions.new;\r\n        // set the applies to checkbox to match the node-level approvals (all will have the same value)\r\n        // if no node level, check if unpublish is required - if it is, type is publish+unpubish, else publish only\r\n        this.appliesTo = (this.approvalPath.length ? this.approvalPath[0].type : this.state.requireUnpublish ? 0 : 1).toString();\r\n        this.checkActiveType();\r\n        this.path = isCreate ? '-1' : this.node.path;\r\n    }\r\n}\r\nexports.ConfigComponent = {\r\n    name: 'workflowConfig',\r\n    transclude: true,\r\n    templateUrl: 'src/plumber/backoffice/components/config/config.html',\r\n    bindings: {\r\n        node: '<',\r\n        state: '<'\r\n    },\r\n    controller: WorkflowConfig\r\n};\r\n\n},{\"../../js/constants\":35}],16:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ContentTypeFlowComponent = void 0;\r\nconst constants_1 = require(\"../../js/constants\");\r\nclass WorkflowContentTypeFlow {\r\n    constructor(languageResource, plmbrGroupsResource, editorService) {\r\n        this.languageResource = languageResource;\r\n        this.editorService = editorService;\r\n        this.init = () => {\r\n            var _a;\r\n            if (this.model.type) {\r\n                this.model.type.variant = (_a = this.languages.find(x => x.isDefault)) === null || _a === void 0 ? void 0 : _a.culture;\r\n                this.variantChanged();\r\n                this.typeChanged();\r\n                this.model.type.permissions.forEach((p) => {\r\n                    if (p.condition) {\r\n                        // reopening the overlay has the already-split condition, so don't try doing it again...\r\n                        p.condition = typeof p.condition === 'string' ? p.condition.split(',') : p.condition;\r\n                        p.condition.forEach(c => {\r\n                            if (c) {\r\n                                this.conditions.push({\r\n                                    groupName: p.groupName,\r\n                                    groupId: p.groupId,\r\n                                    condition: c,\r\n                                    variant: p.variant\r\n                                });\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n                // binding to radiobutton requires a string value, sad face.\r\n                this.model.appliesTo = this.model.type.permissions[0].type.toString();\r\n            }\r\n            else {\r\n                this.isAdd = true;\r\n                this.model.appliesTo = \"0\";\r\n            }\r\n        };\r\n        /**\r\n         *\r\n         */\r\n        this.variantChanged = () => {\r\n            let variantPermissions = this.model.type.permissions.filter(p => p.variant === this.model.type.variant);\r\n            this.variantPermissionsCount = (variantPermissions ? variantPermissions : this.model.type.permissions.filter(p => p.variant === '*')).length;\r\n        };\r\n        /**\r\n         * */\r\n        this.typeChanged = () => {\r\n            var _a;\r\n            this.properties = this.model.type.properties;\r\n            this.model.type.variant = (_a = this.languages.find(x => x.isDefault)) === null || _a === void 0 ? void 0 : _a.culture;\r\n            this.variantChanged();\r\n        };\r\n        /**\r\n         *\r\n         */\r\n        this.addCondition = () => this.conditions.push({\r\n            variant: this.model.type.variant\r\n        });\r\n        /**\r\n         *\r\n         * @param {object} $event the click event\r\n         * @param {int} index the index of the condition\r\n         * @param {string} condition the condition value\r\n         */\r\n        this.removeCondition = ($event, index, condition) => {\r\n            $event.stopPropagation();\r\n            this.conditions.splice(index, 1);\r\n            this.model.type.permissions.forEach((p) => {\r\n                var _a;\r\n                if (p.contentTypeId === this.model.type.id\r\n                    && typeof p.condition === 'object'\r\n                    && ((_a = p.condition) === null || _a === void 0 ? void 0 : _a.some(x => x === condition))\r\n                    && p.variant === this.model.type.variant) {\r\n                    p.condition.splice(p.condition.indexOf(condition), 1);\r\n                }\r\n            });\r\n        };\r\n        /**\r\n         *\r\n         * @param {int} groupId id of the group assigned to the condition\r\n         * @param {string} condition rule representing the workflow stage condition\r\n         * @param {object} oldValue the previous condition\r\n         */\r\n        this.setCondition = (groupId, condition, currentValue) => {\r\n            const permission = this.model.type.permissions.find((p) => p.contentTypeId === this.model.type.id &&\r\n                p.variant === this.model.type.variant &&\r\n                p.groupId === groupId);\r\n            if (permission.condition) {\r\n                const existingIndex = permission.condition.indexOf(currentValue);\r\n                if (existingIndex > -1) {\r\n                    permission.condition[existingIndex] = condition;\r\n                }\r\n                else {\r\n                    permission.condition.push(condition);\r\n                }\r\n            }\r\n            else {\r\n                permission.condition = [condition];\r\n            }\r\n        };\r\n        /**\r\n         *\r\n         */\r\n        this.add = (group) => {\r\n            // when adding a new config, type will not exist.\r\n            if (!this.model.type) {\r\n                this.model.type = {\r\n                    variant: Umbraco.Sys.ServerVariables.Plumber.defaultCulture\r\n                };\r\n            }\r\n            this.model.type.permissions.push({\r\n                contentTypeId: this.model.type.id,\r\n                permission: this.model.type.permissions.filter((p) => p.variant === this.model.type.variant).length,\r\n                groupId: group.groupId,\r\n                groupName: group.name,\r\n                variant: this.model.type.variant\r\n            });\r\n            this.variantChanged();\r\n        };\r\n        /**\r\n         *\r\n         * @param {object} $event click\r\n         * @param {object} item a permissions item\r\n         */\r\n        this.remove = (item) => {\r\n            this.model.type.permissions.splice(this.model.type.permissions.indexOf(item), 1);\r\n            // also remove any conditions - can't do in the existing method as params are different.\r\n            if (this.conditions.length > 0) {\r\n                this.conditions = this.conditions.filter(c => c.groupId !== item.groupId);\r\n            }\r\n            this.variantChanged();\r\n        };\r\n        this.$onInit = () => {\r\n            this.languageResource.getAll()\r\n                .then(languages => {\r\n                this.languages = languages;\r\n                this.init();\r\n            });\r\n        };\r\n        this.workflowGroupsResource = plmbrGroupsResource;\r\n        this.properties = [];\r\n        this.conditions = [];\r\n        this.sortOptions = {\r\n            axis: 'y',\r\n            cursor: 'move',\r\n            handle: '.sort-handle',\r\n            stop: (e, ui) => {\r\n                const permissions = this.model.type.permissions.filter(p => p.variant === this.model.type.variant);\r\n                permissions.forEach((p, i) => {\r\n                    p.permission = i;\r\n                });\r\n            }\r\n        };\r\n    }\r\n    /**\r\n * */\r\n    openGroupOverlay() {\r\n        const model = {\r\n            view: Umbraco.Sys.ServerVariables.Plumber.viewsPath + '/overlays/grouppicker.overlay.html',\r\n            size: constants_1.constants.sizes.s,\r\n            title: 'Add workflow approval group/s',\r\n            approvalPath: this.model.type.permissions,\r\n            submit: (result) => {\r\n                result.selection.forEach(group => {\r\n                    this.add(group);\r\n                });\r\n                this.editorService.close();\r\n            },\r\n            close: () => this.editorService.close(),\r\n        };\r\n        this.editorService.open(model);\r\n    }\r\n    groupName(name, idx) {\r\n        return this.workflowGroupsResource.generateNameWithStage(name, idx);\r\n    }\r\n    editGroup(group) {\r\n        this.workflowGroupsResource.editGroup(group.groupId);\r\n    }\r\n}\r\nexports.ContentTypeFlowComponent = {\r\n    name: 'workflowContentTypeFlow',\r\n    transclude: true,\r\n    templateUrl: 'src/plumber/backoffice/components/contenttypeflow/contenttypeflow.html',\r\n    bindings: {\r\n        model: '='\r\n    },\r\n    controller: WorkflowContentTypeFlow\r\n};\r\n\n},{\"../../js/constants\":35}],17:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DatepickerComponent = void 0;\r\nclass Datepicker {\r\n    constructor(dateHelper, userService, localizationService) {\r\n        this.dateHelper = dateHelper;\r\n        this.userService = userService;\r\n        this.localizationService = localizationService;\r\n        this.$onChanges = () => {\r\n            if (this.date) {\r\n                this.change(this.date);\r\n            }\r\n            if (this.labelKey) {\r\n                this.localizationService.localize(this.labelKey)\r\n                    .then(label => this.label = label);\r\n            }\r\n        };\r\n        this.change = (dateStr) => {\r\n            this.date = this.dateHelper.convertToServerStringTime(moment(dateStr), Umbraco.Sys.ServerVariables.application.serverTimeOffset);\r\n            if (this.currentUser) {\r\n                this.setDateFormatted();\r\n            }\r\n            else {\r\n                this.userService.getCurrentUser().then((currentUser) => {\r\n                    this.currentUser = currentUser;\r\n                    this.setDateFormatted();\r\n                });\r\n            }\r\n        };\r\n        this.setDateFormatted = () => {\r\n            this.dateFormatted = this.dateHelper.getLocalDate(this.date, this.currentUser.locale, \"MMM Do YYYY, HH:mm\");\r\n        };\r\n        this.clear = () => {\r\n            this.date = null;\r\n            this.dateFormatted = null;\r\n        };\r\n        var now = new Date();\r\n        this.config = {\r\n            enableTime: true,\r\n            dateFormat: \"Y-m-d H:i\",\r\n            time_24hr: true,\r\n            defaultDate: null,\r\n            defaultHour: now.getHours(),\r\n            defaultMinute: now.getMinutes() + 5\r\n        };\r\n        this.clear();\r\n    }\r\n}\r\nexports.DatepickerComponent = {\r\n    name: 'workflowDatepicker',\r\n    bindings: {\r\n        date: '=',\r\n        label: '@',\r\n        labelKey: '@'\r\n    },\r\n    templateUrl: 'src/plumber/backoffice/components/datepicker/datepicker.html',\r\n    controller: Datepicker\r\n};\r\n\n},{}],18:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DayRangeComponent = void 0;\r\nclass DayRange {\r\n    constructor($timeout) {\r\n        this.$timeout = $timeout;\r\n        this.isOpen = false;\r\n    }\r\n    onClose() {\r\n        this.isOpen = false;\r\n        this.onChange({\r\n            range: this.value,\r\n        });\r\n    }\r\n}\r\nconst template = `\r\n    <div class=\"umb-filter\">\r\n        <button type=\"button\" class=\"btn btn-link flex p0\" ng-click=\"$ctrl.isOpen = true\">\r\n            <span><localize key=\"workflow_dateRange\">Range (days)</localize>:</span>\r\n            <span class=\"bold dib umb-filter__label\" ng-bind=\"$ctrl.value\"></span>\r\n            <span class=\"caret\" aria-hidden=\"true\"></span>\r\n        </button>\r\n\r\n        <umb-dropdown class=\"pull-right\" ng-if=\"$ctrl.isOpen\" on-close=\"$ctrl.onClose()\" style=\"z-index:9999\">\r\n            <umb-dropdown-item >\r\n                <label for=\"date-range\" class=\"sr-only\">Date range (days)</label>\r\n                <input type=\"number\"\r\n                        class=\"mb-0\"\r\n                        id=\"date-range\"\r\n                        ng-model=\"$ctrl.value\"\r\n                        ng-model-options=\"{ debounce: 300 }\"\r\n                        no-dirty-check />\r\n            </umb-dropdown-item>\r\n        </umb-dropdown>        \r\n    </div>`;\r\nexports.DayRangeComponent = {\r\n    name: 'workflowDayRange',\r\n    transclude: true,\r\n    template: template,\r\n    bindings: {\r\n        onChange: '&',\r\n        value: '='\r\n    },\r\n    controller: DayRange\r\n};\r\n\n},{}],19:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WorkflowDiffComponent = void 0;\r\nclass WorkflowDiff {\r\n    constructor(plmbrWorkflowResource) {\r\n        this.$onInit = () => {\r\n            this.workflowResource.getDiff(this.guid)\r\n                .then(resp => {\r\n                this.currentVersions = resp.diffs.currentVariants;\r\n                this.workflowVersions = resp.diffs.workflowVariants;\r\n                if (this.currentVersions.length === 1) {\r\n                    this.currentVersion = this.currentVersions[0];\r\n                }\r\n                if (this.workflowVersions.length === 1) {\r\n                    this.workflowVersion = this.workflowVersions[0];\r\n                }\r\n                if (this.workflowVersion && this.currentVersion) {\r\n                    this.createDiff();\r\n                }\r\n                this.loading = false;\r\n            });\r\n        };\r\n        this.workflowResource = plmbrWorkflowResource;\r\n        this.loading = true;\r\n    }\r\n    createDiff() {\r\n        this.diffs = [];\r\n        if (this.currentVersion.name !== this.workflowVersion.name) {\r\n            this.diffs.push({\r\n                label: 'Name',\r\n                diff: Diff.diffWords(this.currentVersion.name || '', this.workflowVersion.name || ''),\r\n                isObject: false\r\n            });\r\n        }\r\n        // extract all properties from the tabs and create new object for the diff\r\n        this.workflowVersion.tabs.forEach((tab, tabIndex) => {\r\n            tab.properties.forEach((workflowProperty, propertyIndex) => {\r\n                let currentProperty = this.currentVersion.tabs.length ?\r\n                    this.currentVersion.tabs[tabIndex].properties[propertyIndex] :\r\n                    { value: '' };\r\n                // we have to make properties storing values as object into strings (Grid, nested content, etc.)\r\n                if (workflowProperty.value instanceof Object) {\r\n                    workflowProperty.value = JSON.stringify(workflowProperty.value, null, 1);\r\n                    workflowProperty.isObject = true;\r\n                }\r\n                if (currentProperty.value instanceof Object) {\r\n                    currentProperty.value = JSON.stringify(currentProperty.value, null, 1);\r\n                    currentProperty.isObject = true;\r\n                }\r\n                // diff requires a string\r\n                workflowProperty.value = workflowProperty.value ? workflowProperty.value + '' : '';\r\n                currentProperty.value = currentProperty.value ? currentProperty.value + '' : '';\r\n                const diff = Diff.diffWords(currentProperty.value, workflowProperty.value);\r\n                this.diffs.push({\r\n                    label: workflowProperty.label,\r\n                    diff: diff,\r\n                    isObject: (workflowProperty.isObject || currentProperty.isObject) ? true : false\r\n                });\r\n            });\r\n        });\r\n    }\r\n    variantDiff() {\r\n        this.workflowVersion = this.workflowVersions.find(x => x.language.culture === this.activeVariant.culture);\r\n        this.currentVersion = this.currentVersions.find(x => x.language.culture === this.activeVariant.culture);\r\n        // if no current version, assume it's an unpublished variant, so all values are new\r\n        if (!this.currentVersion) {\r\n            this.currentVersion = {\r\n                name: '',\r\n                tabs: []\r\n            };\r\n        }\r\n        this.createDiff();\r\n    }\r\n    hasDiffs() {\r\n        return this.workflowVersions && this.workflowVersions.some(x => x.name !== null && x.tabs.length)\r\n            && this.currentVersions && this.currentVersions.some(x => x.name !== null && x.tabs.length);\r\n    }\r\n}\r\nexports.WorkflowDiffComponent = {\r\n    name: 'workflowDiff',\r\n    transclude: true,\r\n    templateUrl: 'src/plumber/backoffice/components/diff/workflowdiff.html',\r\n    bindings: {\r\n        guid: '<',\r\n    },\r\n    controller: WorkflowDiff\r\n};\r\n\n},{}],20:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.generateFilters = exports.FilterPickerComponent = void 0;\r\nconst constants_1 = require(\"../../js/constants\");\r\nclass FilterPicker {\r\n    constructor(editorService, dateHelper, localizationService) {\r\n        this.editorService = editorService;\r\n        this.dateHelper = dateHelper;\r\n        this.filters = {};\r\n        localizationService.localize('workflow_filters')\r\n            .then(resp => this.filterStr = resp);\r\n    }\r\n    showFilters() {\r\n        const overlayModel = {\r\n            view: `${Umbraco.Sys.ServerVariables.Plumber.viewsPath}overlays/filterpicker.overlay.html`,\r\n            size: constants_1.constants.sizes.s,\r\n            title: this.filterStr,\r\n            filters: this.filters,\r\n            disabledFilters: this.disabledFilters,\r\n            nodeView: this.nodeView,\r\n            submit: filters => {\r\n                this.filters = filters;\r\n                generateFilters(this.filters, this.nodeView, this.dateHelper);\r\n                this.onChange({\r\n                    filters: this.filters,\r\n                });\r\n                this.editorService.close();\r\n            },\r\n            close: () => this.editorService.close()\r\n        };\r\n        this.editorService.open(overlayModel);\r\n    }\r\n}\r\nconst template = `\r\n    <div class=\"umb-filter mr-2\">\r\n        <button type=\"button\" class=\"btn btn-link flex p0\" ng-click=\"$ctrl.showFilters()\">\r\n            <span>{{ $ctrl.filterStr }}: </span>\r\n            <span class=\"bold dib umb-filter__label\">{{ $ctrl.filters.count || '0' }}</span>\r\n            <span class=\"caret\" aria-hidden=\"true\"></span>\r\n        </button>\r\n    </div>`;\r\nexports.FilterPickerComponent = {\r\n    name: 'workflowFilterPicker',\r\n    transclude: true,\r\n    template: template,\r\n    bindings: {\r\n        onChange: '&',\r\n        filters: '=',\r\n        disabledFilters: '<',\r\n        nodeView: '<',\r\n    },\r\n    controller: FilterPicker\r\n};\r\n/**\r\n     * parse the filter object into comma-separated key and value strings\r\n     * */\r\nfunction generateFilters(filters, nodeView, dateHelper) {\r\n    var _a;\r\n    let keys = [];\r\n    let values = [];\r\n    let now = dateHelper.convertToServerStringTime(moment(new Date()), Umbraco.Sys.ServerVariables.application.serverTimeOffset);\r\n    if (filters.node) {\r\n        keys.push('nodeId');\r\n        values.push(filters.node.id);\r\n    }\r\n    if (filters.user) {\r\n        keys.push('authorUserId');\r\n        values.push(filters.user.id);\r\n    }\r\n    if (filters.variant) {\r\n        keys.push('variant');\r\n        values.push(filters.variant);\r\n    }\r\n    if (filters.type) {\r\n        keys.push('type');\r\n        values.push(filters.type);\r\n    }\r\n    if ((_a = filters.status) === null || _a === void 0 ? void 0 : _a.length) {\r\n        keys.push('status');\r\n        values.push(filters.status.join('|'));\r\n    }\r\n    if (filters.createdFrom) {\r\n        keys.push('createdDate');\r\n        values.push(filters.createdFrom + '|' + (filters.createdTo || now));\r\n    }\r\n    if (filters.completedFrom) {\r\n        keys.push('completedDate');\r\n        values.push(filters.completedFrom + '|' + (filters.completedTo || now));\r\n    }\r\n    filters.keys = keys.join(',');\r\n    filters.values = values.join(',');\r\n    filters.count = (keys.length - (nodeView ? 1 : 0)) || 0;\r\n}\r\nexports.generateFilters = generateFilters;\r\n\n},{\"../../js/constants\":35}],21:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WorkflowGroupPickerComponent = void 0;\r\nclass WorkflowGroupPicker {\r\n    constructor(plmbrGroupsResource) {\r\n        this.loading = false;\r\n        this.workflowGroupsResource = plmbrGroupsResource;\r\n    }\r\n    $onInit() {\r\n        if (!this.model.selection) {\r\n            this.model.selection = [];\r\n        }\r\n        this.loading = true;\r\n        this.workflowGroupsResource.getAllSlim()\r\n            .then(groups => {\r\n            this.groups = groups.items;\r\n            this.updateAvailableGroups();\r\n            this.loading = false;\r\n        });\r\n    }\r\n    updateAvailableGroups() {\r\n        this.groups.forEach(g => {\r\n            var _a;\r\n            g.selected = (_a = this.model.approvalPath) === null || _a === void 0 ? void 0 : _a.some(x => x.groupId === g.groupId);\r\n        });\r\n    }\r\n    selectUserGroup(group) {\r\n        if (!group.selected) {\r\n            group.selected = true;\r\n            this.model.selection.push(group);\r\n        }\r\n        else {\r\n            const idx = this.model.selection.findIndex(x => x.groupId === group.groupId);\r\n            if (idx !== -1) {\r\n                this.model.selection[idx].selected = false;\r\n                this.model.selection.splice(idx, 1);\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.WorkflowGroupPickerComponent = {\r\n    name: 'workflowGroupPicker',\r\n    transclude: true,\r\n    templateUrl: 'src/plumber/backoffice/components/grouppicker/grouppicker.html',\r\n    bindings: {\r\n        model: '='\r\n    },\r\n    controller: WorkflowGroupPicker\r\n};\r\n\n},{}],22:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.HistoryComponent = void 0;\r\nconst constants_1 = require(\"../../js/constants\");\r\nconst sorter_1 = require(\"../../js/models/sorter\");\r\nclass History {\r\n    constructor($scope, $rootScope, editorState, plmbrWorkflowResource) {\r\n        this.nodeView = false;\r\n        this.disabledFilters = [];\r\n        this.perPage = 10;\r\n        /**\r\n         *\r\n         */\r\n        this.fetch = (perPage = this.perPage) => {\r\n            this.model = {\r\n                perPage,\r\n                currentPage: 1,\r\n                filters: this.filters,\r\n                nodeView: this.nodeView,\r\n                handler: this.workflowResource.getAllInstances,\r\n                direction: sorter_1.SortDirection.DESC,\r\n            };\r\n        };\r\n        this.workflowResource = plmbrWorkflowResource;\r\n        this.activityFilter = this.workflowResource.getActivityFilter();\r\n        this.workflowResource.setTreeState();\r\n        if (this.activityFilter !== null && Object.values(this.activityFilter).length > 0) {\r\n            this.filters = this.activityFilter;\r\n        }\r\n        else {\r\n            this.filters = {\r\n                node: editorState.getCurrent(),\r\n                status: []\r\n            };\r\n        }\r\n        this.nodeView = !!this.filters.node;\r\n        this.onActioned = $rootScope.$on(constants_1.constants.events.workflowActioned, (_, data) => {\r\n            if (this.filters.node && this.filters.node.id === data.nodeId) {\r\n                this.fetch();\r\n            }\r\n        });\r\n        this.fetch();\r\n        $scope.$on('$destroy', () => {\r\n            this.onActioned();\r\n            this.workflowResource.setActivityFilter(null);\r\n        });\r\n    }\r\n    onFilter(filters) {\r\n        this.filters = filters;\r\n        this.fetch();\r\n    }\r\n}\r\nexports.HistoryComponent = {\r\n    name: 'workflowHistory',\r\n    templateUrl: 'src/plumber/backoffice/components/history/history.html',\r\n    bindings: {\r\n        disabledFilters: '=',\r\n    },\r\n    controller: History\r\n};\r\n\n},{\"../../js/constants\":35,\"../../js/models/sorter\":53}],23:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WorkflowInstancesComponent = void 0;\r\nconst models_1 = require(\"../../js/models\");\r\nconst tasklist_base_1 = require(\"../../js/models/tasklist.base\");\r\nconst filterpicker_1 = require(\"../filterpicker/filterpicker\");\r\nclass WorkflowInstances extends tasklist_base_1.TaskListBase {\r\n    constructor($scope, $rootScope, plmbrActionsService, notificationsService, dateHelper) {\r\n        super($scope, $rootScope, notificationsService, plmbrActionsService);\r\n        this.dateHelper = dateHelper;\r\n        this.sorter = new models_1.Sorter(() => this.fetch());\r\n        this.pagination = new models_1.Pagination(() => this.fetch(), 5);\r\n        this.sort = (key) => this.sorter.update(key);\r\n    }\r\n    $onChanges(change) {\r\n        if (change.model.currentValue) {\r\n            this.model = change.model.currentValue;\r\n            this.pagination.perPage = this.model.perPage || this.pagination.perPage;\r\n            // allow setting up/down since history should be oldest first, others should be newest\r\n            if (this.model.direction) {\r\n                this.sorter.setDirection(this.model.direction);\r\n            }\r\n            this.fetch();\r\n        }\r\n    }\r\n    fetch() {\r\n        var _a, _b;\r\n        const query = {\r\n            page: this.pagination.pageNumber,\r\n            count: this.pagination.perPage,\r\n            sortBy: this.sorter.sortBy,\r\n            sortDirection: this.sorter.sortDirectionString,\r\n        };\r\n        // if filters are passed down from the history view, ensure they are up to date\r\n        filterpicker_1.generateFilters(this.model.filters, this.model.nodeView, this.dateHelper);\r\n        if ((_a = this.model.filters) === null || _a === void 0 ? void 0 : _a.keys)\r\n            query.filters = this.model.filters.keys;\r\n        if ((_b = this.model.filters) === null || _b === void 0 ? void 0 : _b.values)\r\n            query.filterValues = this.model.filters.values;\r\n        if (this.model.groupId)\r\n            query.groupId = this.model.groupId;\r\n        this.doFetch(query, this.pagination);\r\n    }\r\n    ;\r\n    statusColor(item) {\r\n        switch (item.cssStatus) {\r\n            case 'approved':\r\n                return 'success'; //approved\r\n            case 'not':\r\n            case 'cancelled':\r\n                return 'gray'; //cancelled\r\n            case 'errored':\r\n                return 'danger'; //error \r\n            case 'rejected':\r\n                return 'warning';\r\n            default:\r\n                return 'primary'; //resubmitted, pending\r\n        }\r\n    }\r\n}\r\nexports.WorkflowInstancesComponent = {\r\n    name: 'workflowInstances',\r\n    transclude: true,\r\n    templateUrl: 'src/plumber/backoffice/components/instances/instances.html',\r\n    bindings: {\r\n        model: '<',\r\n    },\r\n    controller: WorkflowInstances\r\n};\r\n\n},{\"../../js/models\":51,\"../../js/models/tasklist.base\":55,\"../filterpicker/filterpicker\":20}],24:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.PageSizeComponent = void 0;\r\nclass PageSize {\r\n    constructor() {\r\n        this.value = 10;\r\n        this.isOpen = false;\r\n        this.options = [5, 10, 20, 25];\r\n    }\r\n    select(perPage) {\r\n        this.isOpen = false;\r\n        this.value = perPage;\r\n        this.onChange({ perPage });\r\n    }\r\n}\r\nconst template = `\r\n    <div class=\"umb-filter\">\r\n        <button type=\"button\" class=\"btn btn-link flex p0\" ng-click=\"$ctrl.isOpen = true\">\r\n            <span><localize key=\"workflow_pageSize\">Page size</localize>:</span>\r\n            <span class=\"bold dib umb-filter__label\" ng-bind=\"$ctrl.value\"></span>\r\n            <span class=\"caret\" aria-hidden=\"true\"></span>\r\n        </button>\r\n\r\n        <umb-dropdown class=\"pull-right\" ng-if=\"$ctrl.isOpen\" on-close=\"$ctrl.isOpen = false\" style=\"z-index:9999\">\r\n            <umb-dropdown-item ng-repeat=\"option in $ctrl.options\">\r\n                <button type=\"button\" ng-click=\"$ctrl.select(option)\" ng-bind=\"::option\"></button>                \r\n            </umb-dropdown-item>\r\n        </umb-dropdown>\r\n    </div>`;\r\nexports.PageSizeComponent = {\r\n    name: 'workflowPageSize',\r\n    transclude: true,\r\n    template: template,\r\n    bindings: {\r\n        onChange: '&',\r\n        value: '='\r\n    },\r\n    controller: PageSize\r\n};\r\n\n},{}],25:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ProgressComponent = void 0;\r\nclass WorkflowProgress {\r\n    constructor(localizationService) {\r\n        this.localizationService = localizationService;\r\n        this.permissions = [];\r\n        this.totalSteps = 0;\r\n        this.addPendingTasks = () => {\r\n            // can't count steps, as reject/resubmit use the same step number - instead, get unique step numbers\r\n            const activeSteps = this.tasks.map(t => t.currentStep).filter((v, i, s) => s.indexOf(v) === i);\r\n            // if permissions are missing (group deleted), stuff a mock permission in at the correct index\r\n            if (this.permissions.length < this.totalSteps) {\r\n                let missingIndexes = [];\r\n                this.permissions.forEach(p => {\r\n                    missingIndexes[p.permission] = p;\r\n                });\r\n                for (let i = 0; i < missingIndexes.length; i += 1) {\r\n                    if (!missingIndexes[i]) {\r\n                        this.permissions.splice(i, 0, {\r\n                            groupName: 'Group does not exist'\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            if (activeSteps.length < this.totalSteps) {\r\n                for (let i = activeSteps.length; i < this.totalSteps; i += 1) {\r\n                    this.tasks.push({\r\n                        statusName: this.pendingApprovalStr,\r\n                        currentStep: i,\r\n                        groupName: this.permissions[i] ? this.permissions[i].groupName : ''\r\n                    });\r\n                }\r\n            }\r\n            // if a rejected task is the last in its step, stuff a fake pending resubmission and pending approval task\r\n            // the responsible user will be the requestedBy value on the task\r\n            this.tasks.forEach((task, i) => {\r\n                if (task.status === 2 && (this.tasks[i + 1] && this.tasks[i + 1].currentStep === task.currentStep + 1 || !this.tasks[i + 1])) {\r\n                    this.tasks.splice(i + 1, 0, {\r\n                        statusName: this.awaitingResubmissionStr,\r\n                        currentStep: task.currentStep,\r\n                        cssStatus: 'pendingapproval',\r\n                        groupName: task.requestedBy\r\n                    });\r\n                }\r\n            });\r\n            // once everything is up to date, iterate again, and set the group classes\r\n            // if a rejection string hits more than 5 stages, collapse these to avoid the progress bar growing horribly\r\n            this.tasks.forEach((task, i) => {\r\n                const prev = this.tasks[i - 1];\r\n                const next = this.tasks[i + 1];\r\n                let str = '';\r\n                if (prev && task.currentStep !== prev.currentStep || !prev) {\r\n                    str = 'grouped-start';\r\n                }\r\n                if (next) {\r\n                    str += task.currentStep !== next.currentStep ? ' grouped-end' : ' grouped';\r\n                }\r\n                else {\r\n                    str += ' grouped-end';\r\n                }\r\n                task.groupClass = str;\r\n            });\r\n            // and iterate again :( to find each set of grouped tasks, remove the extras\r\n            // to be left with grouped-start, collapsed, grouped-end\r\n            this.tasks.forEach((task, i) => {\r\n                if (task.groupClass !== 'grouped-start grouped')\r\n                    return;\r\n                // find the next grouped-end task\r\n                const endTaskIndex = this.tasks.findIndex((t, j) => { var _a; return j > i && ((_a = t.groupClass) === null || _a === void 0 ? void 0 : _a.includes('grouped-end')); });\r\n                // if it's more than two tasks away, we collapse to three tasks\r\n                if (endTaskIndex - i < 3)\r\n                    return;\r\n                const pad = {\r\n                    cssStatus: 'collapsed',\r\n                    groupClass: 'grouped',\r\n                    currentStep: 0,\r\n                    groupName: (this.plusMoreStr || 'plus %0% more').replace('%0%', (endTaskIndex - i - 1).toString())\r\n                };\r\n                this.tasks.splice(i + 1, 0, pad);\r\n                this.tasks.splice(i + 2, endTaskIndex - i - 1);\r\n            });\r\n        };\r\n        this.$onChanges = changes => {\r\n            if (changes.instance.currentValue) {\r\n                const instance = changes.instance.currentValue;\r\n                this.tasks = instance.tasks.sort((a, b) => a.currentStep > b.currentStep);\r\n                this.totalSteps = instance.totalSteps;\r\n                this.permissions = instance.permissions;\r\n                this.localizationService.localizeMany(['workflow_pendingApproval', 'workflow_awaitingResubmission', 'workflow_plusMore'])\r\n                    .then((resp) => {\r\n                    this.pendingApprovalStr = resp[0];\r\n                    this.awaitingResubmissionStr = resp[1];\r\n                    this.plusMoreStr = resp[2];\r\n                    this.addPendingTasks();\r\n                });\r\n            }\r\n        };\r\n    }\r\n}\r\nconst template = `          \r\n    <div ng-repeat=\"task in $ctrl.tasks\"         \r\n        class=\"progress-step {{ task.cssStatus || 'future-step' }}\">\r\n        <div class=\"{{ task.groupClass }}\">\r\n            <span class=\"marker\">\r\n                <i class=\"icon-\"></i>\r\n            </span>\r\n            <span class=\"tooltip {{ ::task.cssStatus }}\">\r\n                <span ng-bind=\"::task.statusName\"></span>\r\n                {{ ::(task.status === 7 ? task.completedBy : task.groupName )}}\r\n            </span>\r\n        </div>\r\n    </div>`;\r\nexports.ProgressComponent = {\r\n    name: 'workflowProgress',\r\n    transclude: true,\r\n    bindings: {\r\n        instance: '<',\r\n    },\r\n    template: template,\r\n    controller: WorkflowProgress\r\n};\r\n\n},{}],26:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SchedulingComponent = void 0;\r\nexports.SchedulingComponent = {\r\n    name: 'workflowScheduling',\r\n    transclude: true,\r\n    template: ` \r\n        <umb-box class=\"workflow\"> \r\n            <umb-box-header title-key=\"workflow_scheduling\"></umb-box-header>\r\n            <umb-box-content>\r\n                <p ng-bind=\"::$ctrl.item.type\"></p>\r\n                <div class=\"d-flex items-center\" ng-if=\"::$ctrl.scheduledDatePassed\">\r\n                    <umb-icon icon=\"icon-alert\" class=\"schedule-warning-icon\"></umb-icon>\r\n                    <small>\r\n                        <localize key=\"workflow_schedulePassed\">Scheduled date passed before the workflow was completed. Content will be released when the current workflow is completed.</localize> \r\n                    </small>\r\n                </div>\r\n            </umb-box-content>\r\n        </umb-box>`,\r\n    bindings: {\r\n        item: '<'\r\n    },\r\n    controller: class WorkflowScheduling {\r\n        $onInit() {\r\n            const scheduledDate = new Date(this.item.scheduledDate);\r\n            const now = new Date();\r\n            this.scheduledDatePassed = scheduledDate < now && this.item.status === 3;\r\n        }\r\n    }\r\n};\r\n\n},{}],27:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SubmitWorkflowComponent = void 0;\r\nconst constants_1 = require(\"../../js/constants\");\r\nclass WorkflowSubmit {\r\n    constructor($scope, $timeout, $rootScope, $element, $sce, $location, editorState, editorService, dateHelper, fileManager, userService, formHelper, notificationsService, contentResource, localizationService, languageResource, navigationService, plmbrActionsService) {\r\n        this.$timeout = $timeout;\r\n        this.$rootScope = $rootScope;\r\n        this.$element = $element;\r\n        this.$sce = $sce;\r\n        this.$location = $location;\r\n        this.editorState = editorState;\r\n        this.editorService = editorService;\r\n        this.dateHelper = dateHelper;\r\n        this.fileManager = fileManager;\r\n        this.formHelper = formHelper;\r\n        this.notificationsService = notificationsService;\r\n        this.contentResource = contentResource;\r\n        this.localizationService = localizationService;\r\n        this.languageResource = languageResource;\r\n        this.navigationService = navigationService;\r\n        this.events = () => {\r\n            // this.state is null when submit initially loads after a process completes\r\n            this.onButtonStateChanged = this.$rootScope.$on(constants_1.constants.events.buttonStateChanged, (_, data) => {\r\n                if (this.state && data.id === this.state.nodeId) {\r\n                    this.buttonState = data.state;\r\n                    this.setSubButtons();\r\n                    this.setDefaultButton();\r\n                }\r\n            });\r\n            this.onAppActive = this.$rootScope.$on(constants_1.constants.events.workflowAppActive, (_, data) => {\r\n                if (this.state && data.id === this.state.nodeId) {\r\n                    this.action = data.action || constants_1.constants.actions.publish;\r\n                    // if we need workflowed unpublish actions, set the sub button to the opposite of the current action\r\n                    this.setSubButtons();\r\n                    this.setDefaultButton();\r\n                }\r\n            });\r\n            this.onActioned = this.$rootScope.$on(constants_1.constants.events.workflowActioned, () => {\r\n                this.comment = null;\r\n            });\r\n        };\r\n        this.setSubButtons = () => {\r\n            // if we need workflowed unpublish actions, set the sub button to the opposite of the current action\r\n            // if no unpublish permissions exist, disable the workflow and show the overlay\r\n            if (this.state.requireUnpublish) {\r\n                let subButton = this.action === constants_1.constants.actions.publish && this.state.hasUnpublishPermissions ? this.unpublishBtn\r\n                    : this.action === constants_1.constants.actions.unpublish ? this.publishBtn\r\n                        : undefined;\r\n                this.subButtons = subButton ? [subButton] : [];\r\n                this.noUnpublishPermissions = this.action === constants_1.constants.actions.unpublish && !this.state.hasUnpublishPermissions;\r\n            }\r\n            else {\r\n                this.subButtons = [];\r\n                this.noUnpublishPermissions = false;\r\n            }\r\n        };\r\n        this.setDefaultButton = () => {\r\n            this.defaultButton = this.action === constants_1.constants.actions.publish ? this.publishBtn : this.unpublishBtn;\r\n        };\r\n        this.$onInit = () => {\r\n            this.labelKey = this.action === constants_1.constants.actions.publish ? 'workflow_describeChanges' : 'workflow_addComment';\r\n            this.templateKey = `workflowCommentTemplates_${this.editorState.current.contentTypeAlias}`;\r\n            this.localizationService.localizeMany([\r\n                'workflow_invalidContent',\r\n                'workflow_noUnpublishPermissions'\r\n            ])\r\n                .then(result => {\r\n                let [invalidContent, noUnpublishPermissions] = result;\r\n                this.invalidContentStr = invalidContent;\r\n                if (noUnpublishPermissions) {\r\n                    document.body.style.setProperty('--plumberNoUnpublishPermissions', `'${noUnpublishPermissions}'`);\r\n                }\r\n                this.publishBtn = {\r\n                    labelKey: 'workflow_publishButton',\r\n                    buttonStyle: constants_1.constants.states.success,\r\n                    handler: () => this.initiate(true),\r\n                    shortcut: 'ctrl+p'\r\n                };\r\n                this.unpublishBtn = {\r\n                    labelKey: 'workflow_unpublishButton',\r\n                    buttonStyle: constants_1.constants.states.success,\r\n                    handler: () => this.initiate(false),\r\n                    shortcut: 'ctrl+u'\r\n                };\r\n                this.setSubButtons();\r\n                this.setDefaultButton();\r\n            });\r\n        };\r\n        this.setScheduledDate = (variant, isPublish) => {\r\n            if (!this.scheduledDate)\r\n                return;\r\n            const dateToSet = isPublish ? 'releaseDate' : 'expireDate';\r\n            if (variant[dateToSet] === this.scheduledDate) {\r\n                return;\r\n            }\r\n            variant[dateToSet] = this.scheduledDate;\r\n            variant[`${dateToSet}Formatted`] = this.scheduledDateFormatted;\r\n            variant.isDirty = true;\r\n        };\r\n        this.initiate = (publish) => {\r\n            let variant = [];\r\n            if (!this.formHelper.submitForm({\r\n                scope: this.scope,\r\n                action: 'save'\r\n            })) {\r\n                this.notificationsService.warning(this.invalidContentStr);\r\n                return;\r\n            }\r\n            // if content is dirty, save it then call back into this function\r\n            // since content was saved, it's no longer dirty, so we won't hit this.\r\n            if (this.scope.contentForm.$dirty) {\r\n                // if nested content exists, it needs to be syncd back\r\n                // can trigger this by closing any open nc instances\r\n                // it's horrible, but it works. Lots of timeouts, these are required\r\n                // to allow changes to propagate before acting on the expected data\r\n                const ncHeaders = document.querySelectorAll('.umb-nested-content__item--active .umb-nested-content__header-bar');\r\n                for (let openNc of Object.values(ncHeaders)) {\r\n                    this.$timeout(() => openNc.click());\r\n                }\r\n                this.buttonState = constants_1.constants.states.busy;\r\n                this.$timeout(() => {\r\n                    this.scope.content.variants.forEach(v => v.save = v.isDirty || v.active);\r\n                    let isNew = this.scope.content.id === 0;\r\n                    // need to store the date to check the auto-save completed\r\n                    // there's no other way to identify a successful, other than checking\r\n                    // notifications, but that relies on language, and knowing the notification text\r\n                    const updateDate = this.scope.content.updateDate;\r\n                    this.contentResource.save(this.scope.content, isNew, this.fileManager.getFiles(), false)\r\n                        .then(newNode => {\r\n                        // update date didn't change, save was cancelled or failed\r\n                        if (newNode.updateDate === updateDate) {\r\n                            this.buttonState = constants_1.constants.states.init;\r\n                            // notifications aren't displayed unless we ask for them...\r\n                            newNode.notifications.forEach(n => this.notificationsService.add(n));\r\n                            return;\r\n                        }\r\n                        this.$element.inheritedData('$formController').$setPristine();\r\n                        if (isNew) {\r\n                            this.scope.content.id = newNode.id;\r\n                            this.state.nodeId = newNode.id;\r\n                            //clear the query strings\r\n                            this.navigationService.clearSearch([\"cculture\", \"csegment\"]);\r\n                            this.navigationService.setSoftRedirect();\r\n                            //change to new path\r\n                            this.$location.path(`/content/content/edit/${this.scope.content.id}`);\r\n                            //don't add a browser history for this\r\n                            this.$location.replace();\r\n                            this.navigationService.syncTree({\r\n                                tree: 'content',\r\n                                path: newNode.path.split(',').map(x => parseInt(x)),\r\n                                activate: true,\r\n                            }).then(() => this.initiate(publish));\r\n                        }\r\n                        else {\r\n                            this.initiate(publish);\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n            else {\r\n                // provide variants as an array\r\n                if (this.selectedVariantName === 'all') {\r\n                    variant = this.variants.map(v => v.language.culture);\r\n                }\r\n                else {\r\n                    variant = [this.selectedVariantName];\r\n                }\r\n                // if release date has changed, assign it to all variants \r\n                // this is a UI change only as the schedule is updated on the server\r\n                // as part of creating the workflow instance\r\n                if (variant.includes('*')) {\r\n                    this.scope.content.variants.forEach(v => this.setScheduledDate(v, publish));\r\n                }\r\n                else {\r\n                    variant.forEach(variantName => this.setScheduledDate(this.scope.content.variants.find(v => v.language.culture === variantName), publish));\r\n                }\r\n                this.actionsService.initiate({\r\n                    nodeId: this.scope.content.id,\r\n                    contentTypeId: this.scope.content.contentTypeId,\r\n                    comment: this.comment,\r\n                    scheduledDate: this.scheduledDate,\r\n                    publish,\r\n                    variant,\r\n                    attachmentId: this.attachment ? this.attachment.id : null\r\n                });\r\n                this.comment = null;\r\n            }\r\n        };\r\n        this.filepicker = () => {\r\n            let currentSelection;\r\n            angular.copy(this.attachment, currentSelection);\r\n            const filePickerOptions = {\r\n                selection: currentSelection,\r\n                multiPicker: false,\r\n                submit: model => {\r\n                    this.attachment = model.selection[0];\r\n                    this.editorService.close();\r\n                },\r\n                close: () => {\r\n                    this.editorService.close();\r\n                }\r\n            };\r\n            this.editorService.mediaPicker(filePickerOptions);\r\n        };\r\n        this.$onChanges = changes => {\r\n            var _a, _b;\r\n            if (changes.state && changes.state.currentValue) {\r\n                if (!this.state.isActive) {\r\n                    this.comment = null;\r\n                }\r\n            }\r\n            // when state is updated, not intialized, reset the buttons\r\n            if (changes.state && changes.state.previousValue) {\r\n                this.setSubButtons();\r\n                this.setDefaultButton();\r\n            }\r\n            if (changes.scope && changes.scope.currentValue) {\r\n                this.variants = this.scope.content.variants;\r\n                // invariant node\r\n                if (this.variants.length === 1 && this.variants[0].language === null) {\r\n                    this.selectedVariantName = '*';\r\n                }\r\n                // variant node \r\n                else {\r\n                    const isCreate = this.$location.search().create === 'true';\r\n                    if (this.variants && this.variants.filter(x => x.language).length && !isCreate) {\r\n                        this.currentVariant = this.variants.find(v => v.active);\r\n                        this.defaultVariant = this.variants.find(v => v.language.isDefault);\r\n                        this.selectedVariantName = (_b = (_a = this.currentVariant) === null || _a === void 0 ? void 0 : _a.language.culture) !== null && _b !== void 0 ? _b : ''; // set the selection to the current displayed variant\r\n                        this.localizeToggleLabels();\r\n                    }\r\n                    else {\r\n                        this.languageResource.getAll()\r\n                            .then(resp => {\r\n                            const defaultLang = resp.find(lang => lang.isDefault);\r\n                            // this should never happen, but keeps TS happy\r\n                            if (!defaultLang)\r\n                                return;\r\n                            this.currentVariant = {\r\n                                language: defaultLang\r\n                            };\r\n                            this.defaultVariant = {\r\n                                language: defaultLang\r\n                            };\r\n                            this.selectedVariantName = this.currentVariant.language.culture;\r\n                            this.localizeToggleLabels();\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        this.localizeToggleLabels = () => {\r\n            this.localizationService.localizeMany([\r\n                'workflow_thisVariant',\r\n                'workflow_invariant',\r\n                'workflow_multiVariant',\r\n                'workflow_thisVariantDesc',\r\n                'workflow_invariantDesc',\r\n                'workflow_multiVariantDesc'\r\n            ])\r\n                .then((data) => {\r\n                var _a, _b, _c, _d;\r\n                let [thisVariant = 'Just this one', invariant = 'Invariant', multiVariant = 'Multi-variant', thisVariantDesc, invariantDesc, multiVariantDesc] = data;\r\n                let obj = { thisVariant, invariant, multiVariant, thisVariantDesc, invariantDesc, multiVariantDesc };\r\n                // append the current/default variant details to the description\r\n                obj.thisVariantDesc = obj.thisVariantDesc.replace('%0%', (_b = (_a = this.currentVariant) === null || _a === void 0 ? void 0 : _a.language.name) !== null && _b !== void 0 ? _b : '');\r\n                obj.invariantDesc = obj.invariantDesc.replace('%0%', (_d = (_c = this.defaultVariant) === null || _c === void 0 ? void 0 : _c.language.name) !== null && _d !== void 0 ? _d : '');\r\n                this.workflowTypeLabels = obj;\r\n            });\r\n        };\r\n        this.actionsService = plmbrActionsService;\r\n        // action is set when selecting the footer button\r\n        // but the workflow type may differ if the user selects from the sub-buttons\r\n        // the button handler sets isPublish and is used in initiate()\r\n        this.action = constants_1.constants.actions.publish;\r\n        this.events();\r\n        var now = new Date();\r\n        var nowFormatted = moment(now).format(\"YYYY-MM-DD HH:mm\");\r\n        this.datepickerConfig = {\r\n            enableTime: true,\r\n            dateFormat: \"Y-m-d H:i\",\r\n            time_24hr: true,\r\n            minDate: nowFormatted,\r\n            defaultDate: null,\r\n            defaultHour: now.getHours(),\r\n            defaultMinute: now.getMinutes() + 5\r\n        };\r\n        // ensure defaults for scheduling match the defaults for content\r\n        // ie scheduleDate and scheduledDateFormatted should be null\r\n        this.datepickerClear();\r\n        userService.getCurrentUser().then(currentUser => this.currentUser = currentUser);\r\n        $scope.$on('$destroy', () => {\r\n            this.onButtonStateChanged();\r\n            this.onAppActive();\r\n            this.onActioned();\r\n        });\r\n    }\r\n    datepickerChange(dateStr) {\r\n        this.scheduledDate = this.dateHelper.convertToServerStringTime(moment(dateStr), Umbraco.Sys.ServerVariables.application.serverTimeOffset);\r\n        this.scheduledDateFormatted = this.dateHelper.getLocalDate(this.scheduledDate, this.currentUser.locale, \"MMM Do YYYY, HH:mm\");\r\n    }\r\n    datepickerClear() {\r\n        this.scheduledDate = null;\r\n        this.scheduledDateFormatted = null;\r\n    }\r\n    filepickerClear() {\r\n        delete this.attachment;\r\n    }\r\n}\r\nexports.SubmitWorkflowComponent = {\r\n    name: 'workflowSubmit',\r\n    transclude: true,\r\n    bindings: {\r\n        state: '<',\r\n        scope: '<',\r\n    },\r\n    templateUrl: 'src/plumber/backoffice/components/submit-workflow/submit.html',\r\n    controller: WorkflowSubmit\r\n};\r\n\n},{\"../../js/constants\":35}],28:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TaskListComponent = void 0;\r\nconst constants_1 = require(\"../../js/constants\");\r\nclass WorkflowTaskList {\r\n    constructor($scope, $rootScope, plmbrWorkflowResource, localizationService) {\r\n        this.tasks = [];\r\n        this.$onChanges = () => {\r\n            this.fetchTasks();\r\n        };\r\n        this.avatarName = (task) => {\r\n            // don't show group if admin completed the task\r\n            if (task.actionedByAdmin) {\r\n                return this.adminStr;\r\n            }\r\n            // if not required, show the group name\r\n            if (task.status === 4) {\r\n                return task.groupName;\r\n            }\r\n            // resubmitted tasks won't have a group, just a user\r\n            if (task.status === 7) {\r\n                return task.completedBy;\r\n            }\r\n            // finally show either the group or the user\r\n            return task.groupName || task.completedBy;\r\n        };\r\n        this.statusColor = (status) => {\r\n            switch (status) {\r\n                case 1:\r\n                    return 'success'; //approved \r\n                case 2:\r\n                case 6:\r\n                    return 'danger'; //rejected, error\r\n                case 3:\r\n                    return 'primary'; //pending\r\n                case 7:\r\n                    return 'warning'; //resubmitted\r\n                default:\r\n                    return 'gray'; //cancelled, not required\r\n            }\r\n        };\r\n        this.whodunnit = (task) => {\r\n            // if rejected or incomplete, use the group name\r\n            if (task.status === 4 || !task.completedBy) {\r\n                return task.groupName;\r\n            }\r\n            if (task.status === 7) {\r\n                return task.completedBy;\r\n            }\r\n            // if actioned by an admin, show\r\n            if (task.actionedByAdmin) {\r\n                return `${task.completedBy} ${this.asAdminStr} ${this.forStr} ${task.groupName}`;\r\n            }\r\n            // if approved, show the user and group name\r\n            if (task.groupName && task.groupName !== this.noGroupStr) {\r\n                return `${task.completedBy} ${this.forStr} ${task.groupName}`;\r\n            }\r\n            // otherwise, just show the user name\r\n            return task.completedBy;\r\n        };\r\n        /**\r\n         *  there may be multiple tasks for a given step, due to rejection/resubmission - modify the tasks object to nest those tasks\r\n         * @param {array} tasks - the set of existing tasks for the instance. May be less than the total steps required in the workflow\r\n         */\r\n        this.setTaskMeta = (tasks) => {\r\n            if (!tasks.length)\r\n                return;\r\n            tasks.forEach(task => {\r\n                let t = task;\r\n                // push some extra UI strings onto each task\r\n                t.avatarName = this.avatarName(t);\r\n                t.statusColor = this.statusColor(t.status);\r\n                t.whodunnit = this.whodunnit(t);\r\n                if (!this.tasks[t.currentStep]) {\r\n                    this.tasks[t.currentStep] = [];\r\n                }\r\n                this.tasks[t.currentStep].push(t);\r\n            });\r\n            // get last task in last task collection\r\n            let lastTask = this.tasks[this.tasks.length - 1];\r\n            // last will always be a WorkflowTask, as we haven't added any ghosts yet\r\n            let lastStep = lastTask[lastTask.length - 1];\r\n            if (lastStep.status === 2) {\r\n                lastTask.push({\r\n                    avatarName: lastStep.requestedBy,\r\n                    statusColor: this.statusColor(3),\r\n                    statusName: this.awaitingResubmissionStr,\r\n                    whodunnit: lastStep.requestedBy\r\n                });\r\n            }\r\n        };\r\n        /**\r\n         * Add dummy tasks for future workflow stages\r\n         */\r\n        this.addPendingTasks = () => {\r\n            if (!this.permissions || !this.permissions.length)\r\n                return;\r\n            // if permissions are missing (group deleted), stuff a mock permission in at the correct index\r\n            if (this.permissions.length < this.totalSteps) {\r\n                let missingIndexes = [];\r\n                this.permissions.forEach(p => {\r\n                    missingIndexes[p.permission] = p;\r\n                });\r\n                const nodeId = this.permissions[0].nodeId;\r\n                const contentTypeId = this.permissions[0].contentTypeId;\r\n                for (let i = 0; i < missingIndexes.length; i += 1) {\r\n                    if (!missingIndexes[i]) {\r\n                        this.permissions.splice(i, 0, {\r\n                            groupName: this.noGroupStr,\r\n                            permission: i,\r\n                            groupId: -1,\r\n                            variant: '',\r\n                            nodeId,\r\n                            contentTypeId,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            if (this.tasks.length < this.totalSteps) {\r\n                for (let i = this.tasks.length; i < this.totalSteps; i += 1) {\r\n                    if (!this.permissions[i])\r\n                        continue;\r\n                    this.tasks.push([{\r\n                            futureTask: true,\r\n                            avatarName: this.permissions[i].groupName,\r\n                            statusName: this.pendingApprovalStr,\r\n                            statusColor: this.statusColor(3),\r\n                            whodunnit: this.permissions[i].groupName,\r\n                            currentStep: i,\r\n                        }]);\r\n                }\r\n            }\r\n        };\r\n        /**\r\n         */\r\n        this.fetchTasks = () => {\r\n            this.workflowResource.getAllTasksByGuid(this.instanceGuid)\r\n                .then(resp => {\r\n                if (resp.notifications) {\r\n                    return;\r\n                }\r\n                this.tasksLoaded = true;\r\n                this.tasks = [];\r\n                this.currentStep = resp.currentStep;\r\n                this.totalSteps = resp.totalSteps;\r\n                this.setTaskMeta(resp.items);\r\n                this.addPendingTasks();\r\n            });\r\n        };\r\n        this.tasksLoaded = false;\r\n        this.workflowResource = plmbrWorkflowResource;\r\n        // no need to get tasks on cancel - component is about to be destroyed.\r\n        this.onActioned = $rootScope.$on(constants_1.constants.events.workflowActioned, (_, data) => data.action != constants_1.constants.actions.cancel ? this.fetchTasks() : {});\r\n        localizationService.localizeMany(['workflow_admin', 'workflow_stage', 'workflow_asAdmin', 'workflow_for', 'workflow_awaitingResubmission', 'workflow_pendingApproval', 'workflow_noGroup'])\r\n            .then((resp) => {\r\n            [this.adminStr, this.stageStr, this.asAdminStr, this.forStr, this.awaitingResubmissionStr, this.pendingApprovalStr, this.noGroupStr] = resp;\r\n        });\r\n        $scope.$on('$destroy', () => {\r\n            this.onActioned();\r\n        });\r\n    }\r\n}\r\nexports.TaskListComponent = {\r\n    name: 'workflowTaskList',\r\n    transclude: true,\r\n    templateUrl: 'src/plumber/backoffice/components/tasklist/tasklist.html',\r\n    bindings: {\r\n        instanceGuid: '<',\r\n        permissions: '<'\r\n    },\r\n    controller: WorkflowTaskList\r\n};\r\n\n},{\"../../js/constants\":35}],29:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TasksComponent = void 0;\r\nconst models_1 = require(\"../../js/models\");\r\nconst tasklist_base_1 = require(\"../../js/models/tasklist.base\");\r\nclass WorkflowTasks extends tasklist_base_1.TaskListBase {\r\n    constructor($scope, $rootScope, notificationsService, plmbrActionsService) {\r\n        super($scope, $rootScope, notificationsService, plmbrActionsService);\r\n        this.pagination = new models_1.Pagination(() => this.fetch(), 5);\r\n        this.sorter = new models_1.Sorter(() => this.fetch());\r\n        this.sort = (key) => this.sorter.update(key);\r\n    }\r\n    $onChanges(change) {\r\n        if (change.model.currentValue) {\r\n            this.model = change.model.currentValue;\r\n            this.pagination.perPage = this.model.perPage || this.pagination.perPage;\r\n            this.fetch();\r\n        }\r\n    }\r\n    fetch() {\r\n        var _a, _b;\r\n        // only submit once as angular events may fire multiple times\r\n        if (this.paging)\r\n            return;\r\n        const query = {\r\n            userId: this.model.userId,\r\n            groupId: this.model.groupId,\r\n            page: this.pagination.pageNumber - 1,\r\n            count: this.pagination.perPage,\r\n            sortBy: this.sorter.sortBy,\r\n            sortDirection: this.sorter.sortDirectionString,\r\n        };\r\n        if ((_a = this.model.filters) === null || _a === void 0 ? void 0 : _a.keys)\r\n            query.filters = this.model.filters.keys;\r\n        if ((_b = this.model.filters) === null || _b === void 0 ? void 0 : _b.values)\r\n            query.filterValues = this.model.filters.values;\r\n        this.doFetch(query, this.pagination);\r\n    }\r\n    ;\r\n}\r\nexports.TasksComponent = {\r\n    name: 'workflowTasks',\r\n    transclude: true,\r\n    bindings: {\r\n        model: '<'\r\n    },\r\n    templateUrl: 'src/plumber/backoffice/components/tasks/tasks.html',\r\n    controller: WorkflowTasks\r\n};\r\n\n},{\"../../js/models\":51,\"../../js/models/tasklist.base\":55}],30:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.removeBanner = exports.addBanner = void 0;\r\nfunction addBanner(state, strings) {\r\n    let bannerText = '';\r\n    if (!state.rejected || !state.canEdit) {\r\n        bannerText = strings.docIsActive + (!state.canEdit ? ' ' + strings.cannotBeEdited : '');\r\n    }\r\n    else if (state.rejected && state.canEdit) {\r\n        bannerText = strings.previousChangesRejected;\r\n    }\r\n    // add banner inside first content panel so that anchoring when switching apps lands in the right place\r\n    const target = document.querySelector('[name=\"tabbedContentForm\"]');\r\n    const panel = target; // ? target.querySelector('.umb-group-panel') : null;\r\n    // since this is outside the component scope (naughty naughty) it won't be \r\n    // removed from DOM when changing tabs. No worries though, we just won't add it twice\r\n    if (panel && !target.querySelector('.alert-workflow')) {\r\n        target.dataset.workflowActive = 'true';\r\n        target.dataset.workflowCanEdit = state.canEdit.toString();\r\n        let banner = document.createElement('div');\r\n        banner.className = 'alert alert-workflow transform';\r\n        banner.innerHTML = `<div class=\"sentinel\"></div><umb-icon icon=\"icon-alert\"></umb-icon>${bannerText}`;\r\n        panel.prepend(banner);\r\n        const observer = new IntersectionObserver(([e]) => {\r\n            e.intersectionRatio < 1 ?\r\n                banner.classList.add('stuck') :\r\n                banner.classList.remove('stuck');\r\n        });\r\n        const sentinel = document.querySelector('.sentinel');\r\n        sentinel ? observer.observe(sentinel) : {};\r\n    }\r\n    // also lock the save/preview buttons in the footer, if canEdit is false\r\n    const footer = document.querySelector('.umb-editor-footer');\r\n    if (footer) {\r\n        footer.dataset.workflowCanEdit = state.canEdit.toString();\r\n    }\r\n}\r\nexports.addBanner = addBanner;\r\nfunction removeBanner() {\r\n    // remove lock banner - it's outside angular scope\r\n    const target = document.querySelector('[name=\"tabbedContentForm\"]');\r\n    const footer = document.querySelector('.umb-editor-footer');\r\n    let alert;\r\n    if (target) {\r\n        target.removeAttribute('data-workflow-active');\r\n        target.removeAttribute('data-workflow-can-edit');\r\n        alert = target.querySelector('.alert-workflow');\r\n        if (alert) {\r\n            alert.parentElement.removeChild(alert);\r\n        }\r\n    }\r\n    if (footer) {\r\n        footer.removeAttribute('data-workflow-can-edit');\r\n    }\r\n}\r\nexports.removeBanner = removeBanner;\r\n\n},{}],31:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DocumentationModule = void 0;\r\nconst documentation_overview_controller_1 = require(\"./documentation.overview.controller\");\r\nexports.DocumentationModule = angular\r\n    .module('plumber.documentation', [])\r\n    .controller(documentation_overview_controller_1.DocumentationController.controllerName, documentation_overview_controller_1.DocumentationController).name;\r\n\n},{\"./documentation.overview.controller\":32}],32:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DocumentationController = void 0;\r\nclass DocumentationController {\r\n    /**\r\n     * Docs are fetched from a parsed markdown file on GitHub - it needs to be parsed into a JSON object to use the healthcheck-style UI\r\n     * Keeping the raw file as markdown makes for easier editing, but does add some processing overhead on the client\r\n     * @param {any} workflowResource\r\n     */\r\n    constructor($timeout, plmbrSettingsResource) {\r\n        this.$timeout = $timeout;\r\n        this.viewState = 'list';\r\n        /**\r\n         * Allow links in docs to open other sections, based on simple matching on the hash and doc name\r\n         */\r\n        this.openDocFromDoc = (e) => {\r\n            e.preventDefault();\r\n            // on click, get the anchor, find the correct section and switch to it\r\n            const target = this.docs.filter(v => {\r\n                var name = v.name.toLowerCase().replace(' ', '-');\r\n                return name.indexOf(e.target.hash.substring(1)) === 0;\r\n            })[0];\r\n            if (target) {\r\n                this.openDoc(target);\r\n            }\r\n        };\r\n        this.bindListeners = () => {\r\n            this.$timeout(() => {\r\n                var elms = document.querySelectorAll('.umb-healthcheck-group__details-check-description a');\r\n                if (elms.length) {\r\n                    for (let i = 0; i < elms.length; i += 1) {\r\n                        elms[i].addEventListener('click', e => this.openDocFromDoc(e));\r\n                    }\r\n                }\r\n            });\r\n        };\r\n        /**\r\n         *\r\n         * @param {number} index\r\n         * @param {HTMLCollection} elements\r\n         */\r\n        this.getContentForHeading = (index, elements) => {\r\n            let html = '';\r\n            if (!elements)\r\n                return html;\r\n            for (let i = index + 1; i < elements.length; i += 1) {\r\n                if (elements[i].tagName !== 'H3') {\r\n                    html += elements[i].outerHTML;\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            return html;\r\n        };\r\n        /**\r\n         *\r\n         * @param {string} docs\r\n         */\r\n        this.parseDocs = (docs) => {\r\n            const parser = new DOMParser();\r\n            const article = parser.parseFromString(docs, 'text/html').querySelector('article');\r\n            const elements = article === null || article === void 0 ? void 0 : article.children;\r\n            let json = [];\r\n            for (const [index, value] of Array.from(elements !== null && elements !== void 0 ? elements : []).entries()) {\r\n                if (value.tagName === 'H3') {\r\n                    json.push({\r\n                        name: value.innerText,\r\n                        content: this.getContentForHeading(index, elements)\r\n                    });\r\n                }\r\n            }\r\n            this.docs = json;\r\n            this.loaded = true;\r\n        };\r\n        /**\r\n         *\r\n         * @param {any} doc\r\n         */\r\n        this.openDoc = (doc) => {\r\n            this.selectedDoc = doc;\r\n            this.viewState = 'details';\r\n            // this will only be the current open doc\r\n            this.bindListeners();\r\n        };\r\n        /**\r\n         *\r\n         * @param {any} state\r\n         */\r\n        this.setViewState = (state) => {\r\n            this.viewState = state;\r\n        };\r\n        this.workflowSettingsResource = plmbrSettingsResource;\r\n        this.workflowSettingsResource.getDocs()\r\n            .then(docs => {\r\n            if (docs === 'Documentation unavailable') {\r\n                this.noDocs = docs;\r\n                this.loaded = true;\r\n            }\r\n            else {\r\n                this.parseDocs(docs);\r\n            }\r\n        });\r\n        this.workflowSettingsResource.setTreeState();\r\n    }\r\n}\r\nexports.DocumentationController = DocumentationController;\r\nDocumentationController.controllerName = 'Workflow.DocsDashboard.Controller';\r\n\n},{}],33:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.HistoryModule = void 0;\r\nconst history_overview_controller_1 = require(\"./history.overview.controller\");\r\nexports.HistoryModule = angular\r\n    .module('plumber.history', [])\r\n    .controller(history_overview_controller_1.HistoryController.controllerName, history_overview_controller_1.HistoryController).name;\r\n\n},{\"./history.overview.controller\":34}],34:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.HistoryController = void 0;\r\nclass HistoryController {\r\n    constructor(localizationService) {\r\n        localizationService.localize('workflow_workflowHistory')\r\n            .then(resp => this.sectionName = resp);\r\n    }\r\n}\r\nexports.HistoryController = HistoryController;\r\nHistoryController.controllerName = 'Workflow.History.Controller';\r\n\n},{}],35:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.constants = void 0;\r\nexports.constants = {\r\n    workflow: 'workflow',\r\n    events: {\r\n        workflowAction: 'workflowAction',\r\n        workflowActioned: 'workflowActioned',\r\n        workflowDetail: 'workflowDetail',\r\n        workflowAppActive: 'workflowAppActive',\r\n        buttonStateChanged: 'buttonStateChanged',\r\n        configSaved: 'configSaved',\r\n        contentSaved: 'content.saved',\r\n        contentUnpublished: 'content.unpublished',\r\n        appTabChange: 'app.tabChange',\r\n        editorsOpen: 'appState.editors.open',\r\n        editorClose: 'appState.editors.close',\r\n        refreshGroups: 'refreshGroups',\r\n        goToNode: 'goToNode',\r\n    },\r\n    actions: {\r\n        publish: 'publish',\r\n        unpublish: 'unpublish',\r\n        initiate: 'initiate',\r\n        cancel: 'cancel',\r\n        reject: 'reject',\r\n        save: 'save',\r\n        saveAndPublish: 'saveAndPublish',\r\n        schedulePublish: 'schedulePublish',\r\n        publishDescendant: 'publishDescendant',\r\n        sendToPublish: 'sendToPublish',\r\n    },\r\n    sizes: {\r\n        s: 'small',\r\n        m: 'medium',\r\n        l: 'large',\r\n    },\r\n    states: {\r\n        success: 'success',\r\n        error: 'error',\r\n        busy: 'busy',\r\n        init: 'init',\r\n        rejected: 'rejected',\r\n        detail: 'detail',\r\n        published: 'published',\r\n        draft: 'draft',\r\n    },\r\n    updatePromptKey: 'plumberUpdatePrompt',\r\n    invariantCulture: '*',\r\n};\r\n\n},{}],36:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ControllersModule = void 0;\r\nconst admin_dashboard_controller_1 = require(\"./admin.dashboard.controller\");\r\nconst user_dashboard_controller_1 = require(\"./user.dashboard.controller\");\r\nconst app_controller_1 = require(\"./app.controller\");\r\nconst html_dialog_controller_1 = require(\"./html.dialog.controller\");\r\nconst filterpicker_controller_1 = require(\"./filterpicker.controller\");\r\nexports.ControllersModule = angular\r\n    .module('plumber.controllers', [])\r\n    .controller(admin_dashboard_controller_1.AdminDashboardController.controllerName, admin_dashboard_controller_1.AdminDashboardController)\r\n    .controller(user_dashboard_controller_1.UserDashboardController.controllerName, user_dashboard_controller_1.UserDashboardController)\r\n    .controller(app_controller_1.AppController.controllerName, app_controller_1.AppController)\r\n    .controller(html_dialog_controller_1.HtmlDialogController.controllerName, html_dialog_controller_1.HtmlDialogController)\r\n    .controller(filterpicker_controller_1.FilterPickerController.controllerName, filterpicker_controller_1.FilterPickerController)\r\n    .name;\r\n\n},{\"./admin.dashboard.controller\":37,\"./app.controller\":38,\"./filterpicker.controller\":39,\"./html.dialog.controller\":40,\"./user.dashboard.controller\":41}],37:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AdminDashboardController = void 0;\r\nconst constants_1 = require(\"../../js/constants\");\r\nclass AdminDashboardController {\r\n    constructor($sce, plmbrSettingsResource) {\r\n        this.$sce = $sce;\r\n        this.chartRange = 28;\r\n        this.updateAlertHidden = () => {\r\n            var _a;\r\n            localStorage.setItem(constants_1.constants.updatePromptKey, this.now.add(7, 'days'));\r\n            const alert = document.getElementById('upgradeAlert');\r\n            (_a = alert === null || alert === void 0 ? void 0 : alert.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(alert);\r\n        };\r\n        this.updateChartRange = range => this.chartRange = range;\r\n        this.workflowSettingsResource = plmbrSettingsResource;\r\n        this.now = new moment();\r\n        // check the current installed version against the remote on GitHub, only if the \r\n        // alert has never been dismissed, or was dismissed more than 7 days ago\r\n        const pesterDate = localStorage.getItem(constants_1.constants.updatePromptKey);\r\n        if (!pesterDate || moment(new Date(pesterDate)).isBefore(this.now)) {\r\n            this.workflowSettingsResource.getVersion()\r\n                .then(resp => {\r\n                if (typeof resp === 'object') {\r\n                    this.version = resp;\r\n                    this.version.releaseNotes = this.$sce.trustAsHtml(this.version.releaseNotes);\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\nexports.AdminDashboardController = AdminDashboardController;\r\nAdminDashboardController.controllerName = 'Workflow.AdminDashboard.Controller';\r\n\n},{\"../../js/constants\":35}],38:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AppController = void 0;\r\nconst usercanedit_1 = require(\"../../components/usercanedit/usercanedit\");\r\nconst constants_1 = require(\"../constants\");\r\nclass AppController {\r\n    constructor($scope, $rootScope, $location, $timeout, $element, localizationService, entityResource, editorState, plmbrStateFactory) {\r\n        this.$rootScope = $rootScope;\r\n        this.$location = $location;\r\n        this.$timeout = $timeout;\r\n        this.$element = $element;\r\n        this.localizationService = localizationService;\r\n        this.entityResource = entityResource;\r\n        this.currentVariant = '';\r\n        // don't show node filter when showing node-level history\r\n        this.disabledFilters = ['node'];\r\n        this.$onDestroy = () => {\r\n            this.tabChange();\r\n            this.contentSaved();\r\n            this.configSaved();\r\n            this.workflowAppActive();\r\n            this.contentUnpublished();\r\n            this.workflowActioned();\r\n        };\r\n        /**\r\n         * */\r\n        this.getEditorScope = $scope => {\r\n            let editorScope = $scope.$parent;\r\n            do {\r\n                editorScope = editorScope.$parent;\r\n            } while (!Object.prototype.hasOwnProperty.call(editorScope, 'contentForm'));\r\n            this.editorScope = editorScope;\r\n        };\r\n        /**\r\n         * */\r\n        this.localize = () => {\r\n            this.localizationService.localizeMany([\r\n                'workflow_docIsActive',\r\n                'workflow_cannotBeEdited',\r\n                'workflow_previousChangesRejected'\r\n            ]).then(text => {\r\n                let [docIsActive, cannotBeEdited, previousChangesRejected] = text;\r\n                this.bannerStrings = { docIsActive, cannotBeEdited, previousChangesRejected };\r\n            });\r\n        };\r\n        /**\r\n         *\r\n         * @param show\r\n         */\r\n        this.updateButtons = (show = true) => {\r\n            if (this.state && this.state.buttons) {\r\n                this.editorScope.defaultButton = this.state.buttons.defaultButton;\r\n                this.editorScope.subButtons = this.state.buttons.subButtons;\r\n            }\r\n            document.body.classList[show ? 'remove' : 'add']('wf-footer-buttons--out');\r\n        };\r\n        /**\r\n         * After saving or unpublishing, check that the sub-buttons array\r\n         * should still include the unpublish actions. Publishing does not raise\r\n         * own event, but does raise save, then setUnpublishButtons checks the content state\r\n         * @param id\r\n         */\r\n        this.checkUpdateButtons = (id) => {\r\n            if (this.state.nodeId !== id) {\r\n                return;\r\n            }\r\n            this.workflowStateFactory.setUnpublishButtons(this.state.buttons.subButtons, this.editorScope.content.variants.find(v => v.active).state, this.state.currentTask);\r\n            this.updateButtons();\r\n        };\r\n        /**\r\n         *\r\n         */\r\n        this.events = () => {\r\n            let currentApp = '';\r\n            this.tabChange = this.$rootScope.$on(constants_1.constants.events.appTabChange, (_, data) => {\r\n                if (this.editorScope.content.id === this.currentId) {\r\n                    document.body.classList[data.alias === constants_1.constants.workflow ? 'add' : 'remove']('wf-footer-buttons--out');\r\n                    currentApp = data.alias;\r\n                    this.$timeout(() => {\r\n                        const form = this.$element.closest('form');\r\n                        // force scrolling to the top - banner messes with offsets\r\n                        if (form && data.alias === 'umbContent') {\r\n                            form.find('[data-element=\"editor-container\"]')[0].scrollTop = 0;\r\n                        }\r\n                    });\r\n                }\r\n                this.updateButtons(currentApp !== constants_1.constants.workflow);\r\n            });\r\n            /* rebind state when node is saved */\r\n            this.contentSaved = this.$rootScope.$on(constants_1.constants.events.contentSaved, (_, data) => {\r\n                if (this.state.nodeId === Umbraco.Sys.ServerVariables.Plumber.newNodeFlowId) {\r\n                    // data contains the new node\r\n                    this.setState(data.content.path);\r\n                }\r\n                else {\r\n                    this.checkUpdateButtons(data.content.id);\r\n                }\r\n            });\r\n            /* update buttons when content is unpublished */\r\n            this.contentUnpublished = this.$rootScope.$on(constants_1.constants.events.contentUnpublished, (_, data) => this.checkUpdateButtons(data.content.id));\r\n            // when config is saved, refresh state and stay on config view\r\n            this.configSaved = this.$rootScope.$on(constants_1.constants.events.configSaved, (_, data) => {\r\n                if (this.state.nodeId === data.id) {\r\n                    this.setState(this.editorScope.content.path, 'config');\r\n                }\r\n            });\r\n            // always default to the first view when arriving via the footer buttons\r\n            this.workflowAppActive = this.$rootScope.$on(constants_1.constants.events.workflowAppActive, (_, data) => {\r\n                if (this.state.nodeId === data.id) {\r\n                    this.setActiveView(null, 'active');\r\n                }\r\n            });\r\n            this.workflowActioned = this.$rootScope.$on(constants_1.constants.events.workflowActioned, (_, data) => {\r\n                if (this.state.nodeId !== data.nodeId)\r\n                    return;\r\n                // when cancelling, remove any scheduled dates\r\n                // no need to re-save as this has been cleared on the server\r\n                // so we only need the UI update here\r\n                if (data.action === constants_1.constants.actions.cancel && data.isScheduled) {\r\n                    const action = data.type === constants_1.constants.actions.publish ? 'releaseDate' : 'expireDate';\r\n                    this.editorScope.content.variants.forEach(variant => {\r\n                        if (variant.language && variant.language.culture !== data.variant && data.variant !== '*')\r\n                            return;\r\n                        variant[action] = null;\r\n                        variant[`${action}Formatted`] = null;\r\n                    });\r\n                }\r\n                // sync app state\r\n                this.setState(this.editorScope.content.path, 'active', currentApp !== constants_1.constants.workflow);\r\n            });\r\n        };\r\n        this.$onInit = () => {\r\n            var _a;\r\n            // activate workflow app, if qs param exists\r\n            if (this.$location.search().app === 'workflow') {\r\n                (_a = this.$element.closest('form')) === null || _a === void 0 ? void 0 : _a.find('[data-element=\"sub-view-workflow\"]').click();\r\n                this.$location.search('app', null);\r\n            }\r\n            this.setActiveView(undefined, this.$location.search().view);\r\n        };\r\n        /**\r\n         *\r\n         * @param {any} e ...\r\n         * @param {any} view ...\r\n         */\r\n        this.setActiveView = (e, view = 'active') => {\r\n            this.activeView = view;\r\n            this.$timeout(() => {\r\n                const activeButtons = document.querySelectorAll('#workflowAppHeader .umb-button__button');\r\n                activeButtons.forEach(btn => btn.classList.remove('active'));\r\n                const target = e ? e.currentTarget : activeButtons[view === 'config' ? 1 : 0];\r\n                if (target) {\r\n                    target.classList.add('active');\r\n                }\r\n            });\r\n        };\r\n        /**\r\n         *\r\n         * @param {any} path\r\n         */\r\n        this.setState = (path = this.editorScope.content.path, setView = 'active', showButtons = true) => {\r\n            this.editorScope.content.path = path;\r\n            // no path if it's a new node - need to get it from the parent\r\n            // so grab it, then come back here and try again...   \r\n            if (!this.editorScope.content.path) {\r\n                if (this.editorScope.content.parentId === -1) {\r\n                    this.setState('-1');\r\n                }\r\n                else {\r\n                    this.entityResource.getPath(this.editorScope.content.parentId, 'document')\r\n                        .then(resp => this.setState(resp));\r\n                }\r\n            }\r\n            else {\r\n                this.workflowStateFactory.getButtonState(this.editorScope).then(state => {\r\n                    if (this.editorScope.content.id === state.nodeId || this.editorScope.isNew === 'true' && state.nodeId === Umbraco.Sys.ServerVariables.Plumber.newNodeFlowId) {\r\n                        this.state = Object.assign({}, state);\r\n                        if (this.state.isActive) {\r\n                            usercanedit_1.addBanner(this.state, this.bannerStrings);\r\n                        }\r\n                        else {\r\n                            usercanedit_1.removeBanner();\r\n                        }\r\n                        if (!this.$location.search().view) {\r\n                            this.$timeout(() => {\r\n                                this.setActiveView(null, this.state.hasConfig ? setView : 'config');\r\n                            });\r\n                        }\r\n                        // map buttons back from state - won't happen in the factory because we are on the content app\r\n                        this.updateButtons(!showButtons ? false : setView !== 'config');\r\n                    }\r\n                });\r\n            }\r\n        };\r\n        // plumber \r\n        this.workflowStateFactory = plmbrStateFactory;\r\n        // call methods\r\n        this.events();\r\n        this.localize();\r\n        this.getEditorScope($scope);\r\n        if (this.editorScope) {\r\n            this.setState();\r\n        }\r\n        this.currentId = editorState.current.id;\r\n    }\r\n}\r\nexports.AppController = AppController;\r\nAppController.controllerName = 'Workflow.App.Controller';\r\n\n},{\"../../components/usercanedit/usercanedit\":30,\"../constants\":35}],39:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.FilterPickerController = void 0;\r\nconst constants_1 = require(\"../../js/constants\");\r\nclass FilterPickerController {\r\n    constructor($scope, languageResource, editorService) {\r\n        this.$scope = $scope;\r\n        this.languageResource = languageResource;\r\n        this.editorService = editorService;\r\n        this.languages = [];\r\n        this.statusValues = [];\r\n        this.typeValues = [];\r\n        this.disabledFilters = [];\r\n        /** */\r\n        this.$onInit = () => {\r\n            this.getFieldValues();\r\n            this.disabledFilters = this.$scope.model.disabledFilters;\r\n            this.languageResource.getAll()\r\n                .then(resp => {\r\n                this.languages = resp;\r\n                if (this.languages.length > 1) {\r\n                    this.languages.push({\r\n                        culture: constants_1.constants.invariantCulture,\r\n                        name: 'Invariant'\r\n                    });\r\n                }\r\n            });\r\n        };\r\n        this.clear = () => {\r\n            // if this is a node view, we need to keep the reference to the current node\r\n            // otherwise the reset view includes all history, not just the current node\r\n            const node = this.$scope.model.nodeView ? this.$scope.model.filters.node : undefined;\r\n            this.$scope.model.filters = {\r\n                status: [],\r\n                node\r\n            };\r\n        };\r\n        /** */\r\n        this.select = (key) => {\r\n            const options = {\r\n                multiPicker: false,\r\n                submit: model => {\r\n                    this.$scope.model.filters[key] = model.selection[0];\r\n                    this.editorService.close();\r\n                },\r\n                close: () => this.editorService.close()\r\n            };\r\n            this.editorService[key === 'node' ? 'contentPicker' : 'userPicker'](options);\r\n        };\r\n        /** */\r\n        this.addFilter = (key) => {\r\n            this.$scope.model.filters[key].push('');\r\n        };\r\n        /**\r\n         *\r\n         * @param {any} idx\r\n         * @param {any} key\r\n         */\r\n        this.removeFilter = (idx, key) => {\r\n            this.$scope.model.filters[key].splice(idx, 1);\r\n        };\r\n        /** */\r\n        this.getFieldValues = () => {\r\n            this.statusValues = [\r\n                { key: 'Pending approval', value: 3 },\r\n                { key: 'Approved', value: 1 },\r\n                { key: 'Rejected', value: 2 },\r\n                { key: 'Resubmitted', value: 7 },\r\n                { key: 'Cancelled', value: 5 },\r\n                { key: 'Cancelled by 3rd party', value: 8 },\r\n                { key: 'Errored', value: 6 }\r\n            ];\r\n            this.typeValues = [\r\n                { key: 'Publish', value: 1 },\r\n                { key: 'Unpublish', value: 2 },\r\n                { key: 'Scheduled publish', value: 11 },\r\n                { key: 'Scheduled unpublish', value: 22 }\r\n            ];\r\n        };\r\n    }\r\n}\r\nexports.FilterPickerController = FilterPickerController;\r\nFilterPickerController.controllerName = 'Workflow.FilterPicker.Controller';\r\n\n},{\"../../js/constants\":35}],40:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.HtmlDialogController = void 0;\r\nclass HtmlDialogController {\r\n    constructor($sce, $scope) {\r\n        this.$sce = $sce;\r\n        this.$scope = $scope;\r\n    }\r\n    $onInit() {\r\n        this.content = this.$sce.trustAsHtml(this.$scope.model.description);\r\n    }\r\n}\r\nexports.HtmlDialogController = HtmlDialogController;\r\nHtmlDialogController.controllerName = 'Html.Dialog.Controller';\r\n\n},{}],41:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.UserDashboardController = void 0;\r\nconst constants_1 = require(\"../constants\");\r\nclass UserDashboardController {\r\n    constructor(plmbrWorkflowResource, authResource, plumberHub, $rootScope) {\r\n        this.authResource = authResource;\r\n        this.plumberHub = plumberHub;\r\n        this.$rootScope = $rootScope;\r\n        this.perPageApprovals = 5;\r\n        this.perPageSubmissions = 5;\r\n        this.workflowResource = plmbrWorkflowResource;\r\n    }\r\n    $onInit() {\r\n        this.authResource.getCurrentUser()\r\n            .then((user) => {\r\n            this.user = user;\r\n            this.adminUser = this.user.allowedSections.includes(constants_1.constants.workflow);\r\n            this.fetch();\r\n        });\r\n        // subscribe to signalr magick only for updating task lists - everything else\r\n        // comes from angular events. there's the outside chance of concurrent workflow changes\r\n        // but there's also the same possibility in Umbraco's save/publish, so not too concerned.\r\n        this.plumberHub.initHub(hub => {\r\n            this.hub = hub;\r\n            this.hub.on('refresh', data => {\r\n                // scope may be destroyed before this resolves, so model won't exist\r\n                if (data === null || data === void 0 ? void 0 : data.includes(this.user.id)) {\r\n                    this.fetch();\r\n                }\r\n            });\r\n            this.hub.start();\r\n        });\r\n        // hub isn't super reliable, so do it manually instead in response to any workflow task \r\n        // completed by the current user. signalr will still broadcast other users actions\r\n        this.onWorkflowActioned = this.$rootScope.$on(constants_1.constants.events.workflowActioned, (_, data) => {\r\n            this.fetch();\r\n        });\r\n    }\r\n    fetch() {\r\n        this.fetchApprovals();\r\n        this.fetchSubmissions();\r\n    }\r\n    fetchApprovals(perPage = this.perPageApprovals) {\r\n        this.approvalsModel = {\r\n            userId: this.user.id,\r\n            adminUser: this.adminUser,\r\n            perPage,\r\n            handler: this.workflowResource.getInstancesAssignedToUser\r\n        };\r\n    }\r\n    fetchSubmissions(perPage = this.perPageSubmissions) {\r\n        this.submissionsModel = {\r\n            userId: this.user.id,\r\n            adminUser: this.adminUser,\r\n            perPage,\r\n            handler: this.workflowResource.getInstancesInitiatedByUser\r\n        };\r\n    }\r\n}\r\nexports.UserDashboardController = UserDashboardController;\r\nUserDashboardController.controllerName = 'Workflow.UserDashboard.Controller';\r\n\n},{\"../constants\":35}],42:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DirectivesModule = void 0;\r\nconst impersonationbanner_directive_1 = require(\"./impersonationbanner.directive\");\r\nconst license_directive_1 = require(\"./license.directive\");\r\nconst umblistview_directive_1 = require(\"./umblistview.directive\");\r\nconst umbtablerow_directive_1 = require(\"./umbtablerow.directive\");\r\nexports.DirectivesModule = angular\r\n    .module('plumber.directives', [])\r\n    .directive(impersonationbanner_directive_1.ImpersonationBanner.directiveName, ($compile) => new impersonationbanner_directive_1.ImpersonationBanner($compile))\r\n    .directive(license_directive_1.License.directiveName, (plmbrWorkflowResource, localizationService) => new license_directive_1.License(plmbrWorkflowResource, localizationService))\r\n    .directive(umblistview_directive_1.UmbListView.directiveName, (plmbrWorkflowResource) => new umblistview_directive_1.UmbListView(plmbrWorkflowResource))\r\n    .directive(umbtablerow_directive_1.UmbTableRow.directiveName, () => new umbtablerow_directive_1.UmbTableRow())\r\n    .name;\r\n\n},{\"./impersonationbanner.directive\":43,\"./license.directive\":44,\"./umblistview.directive\":45,\"./umbtablerow.directive\":46}],43:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ImpersonationBanner = void 0;\r\nclass ImpersonationBanner {\r\n    constructor($compile) {\r\n        this.$compile = $compile;\r\n        this.restrict = 'A';\r\n    }\r\n    link(scope, element) {\r\n        const license = Umbraco.Sys.ServerVariables.Plumber.license;\r\n        if (license.isImpersonating) {\r\n            const template = ` \r\n                <div class=\"alert alert-workflow\">\r\n                    <umb-icon icon=\"icon-alert\"></umb-icon>\r\n                    <p>Plumber license impersonation is active. All features are available on non-production domains only.</p>\r\n                </div>`;\r\n            element.prepend(this.$compile(template)(scope));\r\n        }\r\n    }\r\n}\r\nexports.ImpersonationBanner = ImpersonationBanner;\r\nImpersonationBanner.directiveName = 'impersonationBanner';\r\n\n},{}],44:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.License = void 0;\r\nclass License {\r\n    constructor(plmbrWorkflowResource, localizationService) {\r\n        this.plmbrWorkflowResource = plmbrWorkflowResource;\r\n        this.localizationService = localizationService;\r\n        this.restrict = 'A';\r\n    }\r\n    link(scope, element, attrs) {\r\n        const bind = () => {\r\n            // if the value is empty or false, return\r\n            if (attrs.licensed === 'false') {\r\n                return;\r\n            }\r\n            const license = Umbraco.Sys.ServerVariables.Plumber.license;\r\n            let title, content;\r\n            this.localizationService.localizeMany(['workflow_licensedFeature', 'workflow_licensedFeatureDescription'])\r\n                .then(result => {\r\n                [title, content] = result;\r\n                document.body.style.setProperty('--plumberUnlicensed', `'${title}'`);\r\n            });\r\n            if (!license || license.isTrial && !license.isImpersonating) {\r\n                element[0].classList.add('unlicensed');\r\n                element[0].addEventListener('click', () => {\r\n                    this.plmbrWorkflowResource.htmlOverlay(title, content);\r\n                }, false);\r\n                // this is a bit hacky, but needs the timeout to ensure the property-editor is\r\n                // full rendered before looking for the deep-nested buttons\r\n                setTimeout(() => {\r\n                    const buttons = element[0].querySelectorAll('button');\r\n                    if (buttons.length) {\r\n                        for (let i = 0; i < buttons.length; i += 1) {\r\n                            buttons[i].tabIndex = -1;\r\n                        }\r\n                    }\r\n                }, 500);\r\n            }\r\n        };\r\n        scope.$on('licenseCheck', () => bind());\r\n        bind();\r\n    }\r\n}\r\nexports.License = License;\r\nLicense.directiveName = 'licensed';\r\n\n},{}],45:[function(require,module,exports){\n\"use strict\";\r\n// directives here are used to change the icon on nodes in a list view\r\n// fetches the status for all nodes in the current view\r\n// sets a class on the list view row if an active workflow exists\r\n// raises an event once that is complete\r\n// in the umbtablerow directive, the event triggers adding a class to the table row which changes the icon and title attribute\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.UmbListView = void 0;\r\nclass UmbListView {\r\n    constructor(plmbrWorkflowResource) {\r\n        this.restrict = 'C';\r\n        this.workflowResource = plmbrWorkflowResource;\r\n    }\r\n    link(scope) {\r\n        const setIcons = nodes => scope.listViewResultSet.items.forEach(v => v.activeWorkflow = nodes[v.id] && nodes[v.id] === true);\r\n        scope.$watch(() => scope.listViewResultSet.items, (a, b) => {\r\n            if (a && a.length && a !== b) {\r\n                scope.items = a;\r\n                scope.ids = scope.items.map(i => i.id);\r\n                this.workflowResource.getStatus(scope.ids.join(','))\r\n                    .then(resp => {\r\n                    setIcons(resp.nodes);\r\n                    scope.$broadcast('listViewStatus');\r\n                });\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.UmbListView = UmbListView;\r\nUmbListView.directiveName = 'umbListview';\r\n\n},{}],46:[function(require,module,exports){\n\"use strict\";\r\n// directives here are used to change the icon on nodes in a list view\r\n// fetches the status for all nodes in the current view\r\n// sets a class on the list view row if an active workflow exists\r\n// raises an event once that is complete\r\n// in the table row directive, the event triggers adding a class to the table row which changes the icon and title attribute\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.UmbTableRow = void 0;\r\nclass UmbTableRow {\r\n    constructor() {\r\n        this.restrict = 'C';\r\n    }\r\n    link(scope, element) {\r\n        scope.$on('listViewStatus', () => {\r\n            if (scope.item && scope.item.activeWorkflow) {\r\n                element[0].classList.add('active-workflow');\r\n                element[0].childNodes.forEach(c => {\r\n                    if (c.classList && c.classList.contains('umb-table-cell')) {\r\n                        c.setAttribute('title', 'Workflow active');\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.UmbTableRow = UmbTableRow;\r\nUmbTableRow.directiveName = 'umbTableRow';\r\n\n},{}],47:[function(require,module,exports){\n\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.FiltersModule = void 0;\r\nconst iconName_filter_1 = require(\"./iconName.filter\");\r\nconst permissionsByVariant_filter_1 = __importDefault(require(\"./permissionsByVariant.filter\"));\r\nexports.FiltersModule = angular\r\n    .module('plumber.filters', [])\r\n    .filter('iconName', iconName_filter_1.iconName)\r\n    .filter('permissionsByVariant', permissionsByVariant_filter_1.default)\r\n    .name;\r\n\n},{\"./iconName.filter\":48,\"./permissionsByVariant.filter\":49}],48:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.iconName = void 0;\r\n/**\r\n* Set the icon for the given task, based on the stauts\r\n* @param { } task\r\n* @returns { string }\r\n*/\r\nfunction iconName() {\r\n    return function (task) {\r\n        let response = '';\r\n        //rejected\r\n        if (task.status === 2) {\r\n            response = 'delete';\r\n        }\r\n        // resubmitted or approved\r\n        if (task.status === 7 || task.status === 1) {\r\n            response = 'check';\r\n        }\r\n        // pending\r\n        if (task.status === 3) {\r\n            response = 'record';\r\n        }\r\n        // not required\r\n        if (task.status === 4) {\r\n            response = 'next-media';\r\n        }\r\n        // error\r\n        if (task.status === 6) {\r\n            response = 'thumbs-down';\r\n        }\r\n        // not required\r\n        if (task.status === 5) {\r\n            response = 'stop';\r\n        }\r\n        return response;\r\n    };\r\n}\r\nexports.iconName = iconName;\r\n\n},{}],49:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*\r\n* Return all items matching the current variant\r\n* If none are found, return all matching the default variant *\r\n*/\r\nfunction permissionsByVariant() {\r\n    return function (items, variant) {\r\n        const response = (items || []).filter(p => p.variant === variant);\r\n        return (response ? response : items.filter(p => p.variant === '*')).sort((a, b) => a.permission > b.permission ? 1 : -1);\r\n    };\r\n}\r\nexports.default = permissionsByVariant;\r\n\n},{}],50:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WorkflowStatus = void 0;\r\nvar WorkflowStatus;\r\n(function (WorkflowStatus) {\r\n    WorkflowStatus[WorkflowStatus[\"Approved\"] = 1] = \"Approved\";\r\n    WorkflowStatus[WorkflowStatus[\"Rejected\"] = 2] = \"Rejected\";\r\n    WorkflowStatus[WorkflowStatus[\"PendingApproval\"] = 3] = \"PendingApproval\";\r\n    WorkflowStatus[WorkflowStatus[\"NotRequired\"] = 4] = \"NotRequired\";\r\n    WorkflowStatus[WorkflowStatus[\"Cancelled\"] = 5] = \"Cancelled\";\r\n    WorkflowStatus[WorkflowStatus[\"Errored\"] = 6] = \"Errored\";\r\n    WorkflowStatus[WorkflowStatus[\"Resubmitted\"] = 7] = \"Resubmitted\";\r\n    WorkflowStatus[WorkflowStatus[\"CancelledByThirdParty\"] = 8] = \"CancelledByThirdParty\";\r\n})(WorkflowStatus = exports.WorkflowStatus || (exports.WorkflowStatus = {}));\r\n\n},{}],51:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SortOptions = exports.Sorter = exports.Pagination = void 0;\r\nvar pagination_1 = require(\"./pagination\");\r\nObject.defineProperty(exports, \"Pagination\", { enumerable: true, get: function () { return pagination_1.Pagination; } });\r\nvar sorter_1 = require(\"./sorter\");\r\nObject.defineProperty(exports, \"Sorter\", { enumerable: true, get: function () { return sorter_1.Sorter; } });\r\nvar sortoptions_1 = require(\"./sortoptions\");\r\nObject.defineProperty(exports, \"SortOptions\", { enumerable: true, get: function () { return sortoptions_1.SortOptions; } });\r\n\n},{\"./pagination\":52,\"./sorter\":53,\"./sortoptions\":54}],52:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Pagination = void 0;\r\n/**\r\n* Defaults to pageNumber = 1, totalPages = 0, perPage = 10\r\n* Pass a function to the constructor to use as the goToPage callback\r\n* goToPage manages setting the page number before executing the callback\r\n* */\r\nclass Pagination {\r\n    constructor(cb, perPage = 10) {\r\n        this.pageNumber = 1;\r\n        this.totalPages = 0;\r\n        this.perPage = perPage;\r\n        this.goToPage = i => {\r\n            this.pageNumber = i;\r\n            cb();\r\n        };\r\n    }\r\n}\r\nexports.Pagination = Pagination;\r\n\n},{}],53:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SortDirection = exports.Sorter = void 0;\r\nclass Sorter {\r\n    constructor(callback, sortBy = 'id', sortDirection = SortDirection.ASC) {\r\n        this.sortDirections = {};\r\n        this.sortBy = sortBy;\r\n        this.sortDirections[this.sortBy] = sortDirection;\r\n        this.callback = callback;\r\n    }\r\n    setDirection(sortDirection) {\r\n        this.sortDirections[this.sortBy] = sortDirection;\r\n    }\r\n    update(sortBy) {\r\n        this.sortBy = sortBy;\r\n        this.sortDirections[sortBy] = this.sortDirections[sortBy] === SortDirection.ASC\r\n            ? SortDirection.DESC\r\n            : SortDirection.ASC;\r\n        this.callback();\r\n    }\r\n    get sortDirectionString() {\r\n        return this.sortDirections[this.sortBy] === SortDirection.ASC ? 'asc' : 'desc';\r\n    }\r\n}\r\nexports.Sorter = Sorter;\r\nvar SortDirection;\r\n(function (SortDirection) {\r\n    SortDirection[\"ASC\"] = \"up\";\r\n    SortDirection[\"DESC\"] = \"down\";\r\n})(SortDirection = exports.SortDirection || (exports.SortDirection = {}));\r\n\n},{}],54:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SortOptions = void 0;\r\nclass SortOptions {\r\n    constructor(stop) {\r\n        this.axis = 'y';\r\n        this.containment = 'parent';\r\n        this.distance = 10;\r\n        this.opacity = 0.7;\r\n        this.tolerance = 'pointer';\r\n        this.scroll = true;\r\n        this.zIndex = 6000;\r\n        this.stop = () => { };\r\n        this.stop = () => {\r\n            stop ? stop() : {};\r\n        };\r\n    }\r\n}\r\nexports.SortOptions = SortOptions;\r\n\n},{}],55:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TaskListBase = void 0;\r\nconst constants_1 = require(\"../constants\");\r\nclass TaskListBase {\r\n    constructor($scope, $rootScope, notificationsService, plmbrActionsService) {\r\n        this.$rootScope = $rootScope;\r\n        this.notificationsService = notificationsService;\r\n        this.plmbrActionsService = plmbrActionsService;\r\n        this.buttonStates = [];\r\n        this.notificationsService = notificationsService;\r\n        this.actionsService = plmbrActionsService;\r\n        this.onDetail = $rootScope.$on(constants_1.constants.events.workflowDetail, (_, data) => this.setButtonState(data));\r\n        this.languageCount = Umbraco.Sys.ServerVariables.Plumber.languageCount;\r\n        $scope.$on('$destroy', () => {\r\n            this.onDetail();\r\n        });\r\n    }\r\n    doFetch(query, pagination) {\r\n        this.paging = true;\r\n        this.model.handler(query)\r\n            .then(resp => {\r\n            this.items = resp.items;\r\n            pagination.totalPages = resp.totalPages;\r\n        }, error => this.notificationsService.error('Error', error.message))\r\n            .finally(() => {\r\n            this.loaded = true;\r\n            this.paging = false;\r\n        });\r\n    }\r\n    displayName(item) {\r\n        return this.languageCount > 1 ? `${item.node.name} (${item.variantName})` : item.node.name;\r\n    }\r\n    detail(item) {\r\n        this.buttonStates[item.instanceGuid] = constants_1.constants.states.busy;\r\n        this.actionsService.detail(item);\r\n    }\r\n    setButtonState(data) {\r\n        this.buttonStates[data.instanceGuid] = constants_1.constants.states.init;\r\n    }\r\n    variantCode(item) {\r\n        return item.variantCode === '*' ? Umbraco.Sys.ServerVariables.Plumber.defaultCulture : item.variantCode;\r\n    }\r\n}\r\nexports.TaskListBase = TaskListBase;\r\n\n},{\"../constants\":35}],56:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ServicesModule = void 0;\r\nconst actions_resource_1 = require(\"./actions.resource\");\r\nconst groups_resource_1 = require(\"./groups.resource\");\r\nconst hub_resource_1 = require(\"./hub.resource\");\r\nconst state_factory_1 = require(\"./state.factory\");\r\nconst licensing_resource_1 = require(\"./licensing.resource\");\r\nconst workflow_resource_1 = require(\"./workflow.resource\");\r\nexports.ServicesModule = angular\r\n    .module('plumber.services', [])\r\n    .service(actions_resource_1.ActionsService.serviceName, actions_resource_1.ActionsService)\r\n    .service(groups_resource_1.GroupsService.serviceName, groups_resource_1.GroupsService)\r\n    .service(hub_resource_1.PlumberHub.serviceName, hub_resource_1.PlumberHub)\r\n    .service(state_factory_1.StateFactory.serviceName, state_factory_1.StateFactory)\r\n    .service(licensing_resource_1.LicensingService.serviceName, licensing_resource_1.LicensingService)\r\n    .service(workflow_resource_1.WorkflowService.serviceName, workflow_resource_1.WorkflowService)\r\n    .name;\r\n\n},{\"./actions.resource\":57,\"./groups.resource\":58,\"./hub.resource\":59,\"./licensing.resource\":60,\"./state.factory\":62,\"./workflow.resource\":63}],57:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ActionsService = void 0;\r\nconst constants_1 = require(\"../constants\");\r\nconst enums_1 = require(\"../models/enums\");\r\nclass ActionsService {\r\n    constructor($rootScope, editorService, $timeout, localizationService, navigationService, $routeParams, plmbrWorkflowResource, plmbrStateFactory) {\r\n        this.$rootScope = $rootScope;\r\n        this.editorService = editorService;\r\n        this.$timeout = $timeout;\r\n        this.localizationService = localizationService;\r\n        this.navigationService = navigationService;\r\n        this.$routeParams = $routeParams;\r\n        /**\r\n         * UI feedback for button directive\r\n         * @param {any} state\r\n         * @param {any} id\r\n         */\r\n        this.buttonState = (state, id) => this.$rootScope.$emit(constants_1.constants.events.buttonStateChanged, { state: state, id: id });\r\n        /**\r\n         * display notification after actioning workflow task\r\n         * @param {any} d\r\n         * @param {any} item\r\n         * @param {any} action\r\n         */\r\n        this.notify = (d, item, action) => {\r\n            var _a;\r\n            this.buttonState(d.status === 200 ? constants_1.constants.states.success : constants_1.constants.states.error, item.node.id);\r\n            const isScheduled = typeof item.scheduledDate !== 'undefined';\r\n            const type = item.typeId === 1 ? constants_1.constants.actions.publish : item.typeId === 2 ? constants_1.constants.actions.unpublish : null;\r\n            this.$rootScope.$emit(constants_1.constants.events.workflowActioned, {\r\n                action,\r\n                nodeId: item.node.id,\r\n                variant: item.variant,\r\n                isScheduled,\r\n                type,\r\n                status: d.workflowStatus\r\n            });\r\n            // sync the content tree to ensure current node state is correct, only after a workflow is complete\r\n            // as any other state won't have modified the node state, so no need to refresh\r\n            if (this.workflowStateFactory.path && d.workflowStatus.includes(enums_1.WorkflowStatus.Approved) && ((_a = this.$routeParams) === null || _a === void 0 ? void 0 : _a.tree)) {\r\n                this.navigationService.syncTree({ tree: this.$routeParams.tree, path: this.workflowStateFactory.path.split(',').map(x => +x), forceReload: true });\r\n            }\r\n            // finally, close the overlay if this is a dashboard action\r\n            if (this.workflowOverlay.close) {\r\n                this.workflowOverlay.close();\r\n            }\r\n        };\r\n        /**\r\n         *\r\n         * @param {any} item\r\n         * @param {any} comment\r\n         * @param {any} action\r\n         * @param {any} offline\r\n         */\r\n        this.action = (item, comment, action, offline) => {\r\n            this.buttonState(constants_1.constants.states.busy, item.node.id);\r\n            this.workflowResource.actionWorkflow({\r\n                action,\r\n                instanceGuid: item.instance.guid,\r\n                comment,\r\n                offline\r\n            }).then(resp => this.notify(resp, item, action));\r\n        };\r\n        /**\r\n         *\r\n         * @param {InitiateWorkflowModel} args\r\n         */\r\n        this.initiate = (model) => {\r\n            // notify expects an object\r\n            const item = {\r\n                node: { id: model.nodeId },\r\n                typeId: model.publish ? 1 : 2,\r\n                variant: model.variant,\r\n            };\r\n            if (model.scheduledDate) {\r\n                item.scheduledDate = model.scheduledDate;\r\n            }\r\n            this.buttonState(constants_1.constants.states.busy, model.nodeId);\r\n            this.workflowResource.initiateWorkflow(model)\r\n                .then(resp => this.notify(resp, item, constants_1.constants.actions.initiate));\r\n        };\r\n        /**\r\n         *\r\n         * @param {any} instance\r\n         */\r\n        this.detail = (instance) => {\r\n            this.localizationService.localizeMany(['workflow_pendingForNode', 'workflow_historyFor'])\r\n                .then(resp => this.doDetailOverlay(instance, resp[0], resp[1]));\r\n        };\r\n        /**\r\n         *\r\n         * @param {any} instance\r\n         * @param {any} pendingForNode\r\n         * @param {any} historyFor\r\n         */\r\n        this.doDetailOverlay = (instance, pendingForNode, historyFor) => {\r\n            const viewsPath = Umbraco.Sys.ServerVariables.Plumber.viewsPath;\r\n            pendingForNode = pendingForNode.replace('%0%', instance.type.toLowerCase());\r\n            pendingForNode = pendingForNode.replace('%1%', instance.node.name);\r\n            // readonly when the workflow is non-active\r\n            const readonly = instance.completedDate != null;\r\n            this.workflowOverlay = {\r\n                view: `${viewsPath}overlays/workflow.detail.overlay.html`,\r\n                size: readonly ? constants_1.constants.sizes.m : constants_1.constants.sizes.l,\r\n                title: pendingForNode,\r\n                description: instance.typeDescription,\r\n                instance,\r\n                readonly,\r\n                close: () => this.editorService.close()\r\n            };\r\n            if (instance.node.url !== '#') {\r\n                this.workflowOverlay.description = instance.node.url;\r\n            }\r\n            if (readonly || !instance.node.exists) {\r\n                this.workflowOverlay.title = historyFor.replace('%0%', instance.node.name);\r\n                this.editorService.open(this.workflowOverlay);\r\n            }\r\n            else {\r\n                const content = {\r\n                    id: instance.node.id,\r\n                    path: instance.path,\r\n                    contentTypeId: instance.contentTypeId\r\n                };\r\n                // if not readonly, we need state to allow correct action buttons\r\n                this.workflowStateFactory.getButtonState({ content, variantCode: instance.variantCode }).then(state => {\r\n                    this.workflowOverlay.state = state;\r\n                    this.$timeout(() => {\r\n                        this.editorService.open(this.workflowOverlay);\r\n                        this.$rootScope.$emit(constants_1.constants.events.workflowDetail, { instanceGuid: instance.instanceGuid });\r\n                    });\r\n                });\r\n            }\r\n        };\r\n        /**\r\n         * Offline gets state in the controller to check the user group is permitted to action, hence the simpler method here\r\n         */\r\n        this.offlineDetail = (instance, state) => {\r\n            this.localizationService.localize('workflow_pendingForNode')\r\n                .then(pendingForNode => this.doOfflineDetail(instance, state, pendingForNode));\r\n        };\r\n        /**\r\n         *\r\n         * @param {any} instance\r\n         * @param {any} state\r\n         * @param {any} pendingForNode\r\n         */\r\n        this.doOfflineDetail = (instance, state, pendingForNode) => {\r\n            const viewsPath = Umbraco.Sys.ServerVariables.Plumber.viewsPath;\r\n            pendingForNode = pendingForNode.replace('%0%', instance.type.toLowerCase());\r\n            pendingForNode = pendingForNode.replace('%1%', instance.node.name);\r\n            this.workflowOverlay = {\r\n                view: `${viewsPath}overlays/workflow.detail.overlay.html`,\r\n                size: constants_1.constants.sizes.l,\r\n                title: pendingForNode,\r\n                instance: instance,\r\n                readonly: false,\r\n                state: state,\r\n                close: () => this.editorService.close()\r\n            };\r\n            if (instance.node.url !== '#') {\r\n                this.workflowOverlay.description = instance.node.url;\r\n            }\r\n            this.editorService.open(this.workflowOverlay);\r\n            this.$rootScope.$emit(constants_1.constants.events.workflowDetail, { instanceGuid: instance.instanceGuid });\r\n        };\r\n        this.workflowResource = plmbrWorkflowResource;\r\n        this.workflowStateFactory = plmbrStateFactory;\r\n        this.workflowOverlay = {};\r\n        $rootScope.$on(constants_1.constants.events.goToNode, () => this.workflowOverlay.close());\r\n    }\r\n}\r\nexports.ActionsService = ActionsService;\r\nActionsService.serviceName = 'plmbrActionsService';\r\n\n},{\"../constants\":35,\"../models/enums\":50}],58:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GroupsService = void 0;\r\nconst constants_1 = require(\"../constants\");\r\nclass GroupsService {\r\n    constructor($http, $rootScope, umbRequestHelper, editorService) {\r\n        this.$http = $http;\r\n        this.umbRequestHelper = umbRequestHelper;\r\n        this.editorService = editorService;\r\n        this.request = (method, url, data) => {\r\n            url = `${Umbraco.Sys.ServerVariables.Plumber.groupsApiBaseUrl}${url}`;\r\n            return this.umbRequestHelper.resourcePromise(method === 'DELETE' ? this.$http.delete(url)\r\n                : method === 'POST' ? this.$http.post(url, data)\r\n                    : method === 'PUT' ? this.$http.put(url, data)\r\n                        : this.$http.get(url), 'Something broke');\r\n        };\r\n        /**\r\n         * @returns {array} user groups\r\n         * @description Get single group by id\r\n         */\r\n        this.get = (id) => this.request('GET', `Get?id=${id}`);\r\n        /**\r\n         * @returns {array} user group pocos - userId, groupId, inherited\r\n         * @param {Array<number|string>} ids array of Umbraco group ids to query\r\n         */\r\n        this.getInheritedMembers = (ids) => this.request('GET', `GetInheritedMembers?ids=${ids.join(',')}`);\r\n        /**\r\n         * @param {number} page defaults to 0\r\n         * @param {number} count defaults to 10000\r\n         * @param {string} filter defaults to ''\r\n         * @param {boolean} slim defaults to false\r\n         */\r\n        this.getPage = (page, count, filter = '', slim = false) => this.request('GET', `GetPage?slim=${slim}&page=${page}&count=${count}&filter=${filter}`);\r\n        /**\r\n         * @returns {array} user groups\r\n         * @description Get an array of slim user groups (id, name only)\r\n         */\r\n        this.getAllSlim = () => this.request('GET', 'GetPage?slim=true&page=1&count=10000');\r\n        /**\r\n         * Get the bare minimum content info - path, id, trashed, icon, name\r\n         * @param {any} ids\r\n         */\r\n        this.getContentSlim = ids => this.request('GET', `GetContentSlim?ids=${ids.join(',')}`);\r\n        /**\r\n         * @param {object} group\r\n         * @returns {string}\r\n         * @description save updates to an existing group object\r\n         */\r\n        this.save = group => this.request('PUT', 'Save', group);\r\n        /**\r\n         * @param {number} id\r\n         * @returns {string}\r\n         * @description delete group by id\r\n         */\r\n        this.delete = (id) => this.request('DELETE', 'Delete/' + id);\r\n        /**\r\n         *\r\n         * @param group\r\n         */\r\n        this.editGroup = (groupId) => {\r\n            const model = {\r\n                view: Umbraco.Sys.ServerVariables.Plumber.pluginPath + '/approval-groups/edit.html',\r\n                size: constants_1.constants.sizes.l,\r\n                groupId: groupId,\r\n                submit: _ => {\r\n                    this.editorService.close();\r\n                },\r\n                close: () => this.editorService.close(),\r\n            };\r\n            this.editorService.open(model);\r\n        };\r\n        /**\r\n         *\r\n         * @param name\r\n         * @param index\r\n         */\r\n        this.generateNameWithStage = (name, index) => `Stage ${index + 1}: ${name}`;\r\n        $rootScope.$on(constants_1.constants.events.refreshGroups, () => this.getAllSlim());\r\n    }\r\n}\r\nexports.GroupsService = GroupsService;\r\nGroupsService.serviceName = 'plmbrGroupsResource';\r\n\n},{\"../constants\":35}],59:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.PlumberHub = void 0;\r\nclass PlumberHub {\r\n    constructor($rootScope, $q, assetsService) {\r\n        this.$rootScope = $rootScope;\r\n        this.$q = $q;\r\n        this.assetsService = assetsService;\r\n        this.scripts = [];\r\n        this.starting = false;\r\n        this.callbacks = [];\r\n        this.setupHub = callback => {\r\n            let proxy;\r\n            let hub = {};\r\n            $.connection = new signalR.HubConnectionBuilder()\r\n                .withUrl(Umbraco.Sys.ServerVariables.Plumber.signalRHub, {\r\n                skipNegotiation: true,\r\n                transport: signalR.HttpTransportType.WebSockets,\r\n            })\r\n                .withAutomaticReconnect()\r\n                .configureLogging(signalR.LogLevel.Warning)\r\n                .build();\r\n            proxy = $.connection;\r\n            if (proxy !== undefined) {\r\n                hub = {\r\n                    active: true,\r\n                    start: () => {\r\n                        try {\r\n                            proxy.start()\r\n                                .then(() => { } /*console.info('Hub started =>', $.connection.connectionId)*/)\r\n                                .catch(() => console.warn('Failed to start hub'));\r\n                        }\r\n                        catch (e) {\r\n                            console.warn('Could not setup signalR connection', e);\r\n                        }\r\n                    },\r\n                    on: (eventName, callback) => {\r\n                        proxy.on(eventName, result => {\r\n                            this.$rootScope.$apply(() => {\r\n                                if (callback) {\r\n                                    callback(result);\r\n                                }\r\n                            });\r\n                        });\r\n                    },\r\n                    /**\r\n                     * Function is common across 472 and 5.0\r\n                     * @param methodName\r\n                     * @param callback\r\n                     */\r\n                    invoke: (methodName, callback) => {\r\n                        proxy.invoke(methodName)\r\n                            .done(result => this.$rootScope.$apply(() => {\r\n                            if (callback) {\r\n                                callback(result);\r\n                            }\r\n                        }));\r\n                    }\r\n                };\r\n            }\r\n            else {\r\n                hub = {\r\n                    on: () => { },\r\n                    invoke: () => { },\r\n                    start: () => console.warn('No hub to start'),\r\n                };\r\n            }\r\n            return callback(hub);\r\n        };\r\n        const umbracoPath = Umbraco.Sys.ServerVariables.umbracoSettings.umbracoPath;\r\n        this.scripts = [umbracoPath + '/lib/signalr/signalr.min.js'];\r\n    }\r\n    /**\r\n     * Function is common across 472 and 5.0\r\n     * */\r\n    processCallbacks() {\r\n        while (this.callbacks.length) {\r\n            const cb = this.callbacks.pop();\r\n            this.setupHub(cb);\r\n        }\r\n        this.starting = false;\r\n    }\r\n    /**\r\n     * Function is common across 472 and 5.0\r\n     * @param callback\r\n     */\r\n    initHub(callback) {\r\n        this.callbacks.push(callback);\r\n        if (!this.starting) {\r\n            if ($.connection === undefined) {\r\n                this.starting = true;\r\n                const promises = [];\r\n                this.scripts.forEach(script => promises.push(this.assetsService.loadJs(script)));\r\n                this.$q.all(promises).then(() => this.processCallbacks());\r\n            }\r\n            else {\r\n                this.processCallbacks();\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.PlumberHub = PlumberHub;\r\nPlumberHub.serviceName = 'plumberHub';\r\n\n},{}],60:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LicensingService = void 0;\r\nclass LicensingService {\r\n    constructor($http, umbRequestHelper) {\r\n        this.$http = $http;\r\n        this.umbRequestHelper = umbRequestHelper;\r\n        this.request = (method, url, data) => {\r\n            url = `${Umbraco.Sys.ServerVariables.Plumber.licensingApiBaseUrl}${url}`;\r\n            return this.umbRequestHelper.resourcePromise(method === 'GET'\r\n                ? this.$http.get(url)\r\n                : this.$http.post(url, data), 'Something broke');\r\n        };\r\n        this.validate = (license, key) => this.request('POST', 'Validate', { license, key });\r\n        this.getEula = () => this.request('GET', 'GetEula');\r\n        this.getLicensingUrl = () => this.request('GET', 'GetLicensingUrl');\r\n    }\r\n}\r\nexports.LicensingService = LicensingService;\r\nLicensingService.serviceName = 'plmbrLicensingResource';\r\n\n},{}],61:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.PlumberServiceBase = void 0;\r\nclass PlumberServiceBase {\r\n    constructor($http, $routeParams, umbRequestHelper, navigationService) {\r\n        this.$http = $http;\r\n        this.$routeParams = $routeParams;\r\n        this.umbRequestHelper = umbRequestHelper;\r\n        this.navigationService = navigationService;\r\n        /**\r\n         *\r\n         * @param {any} method\r\n         * @param {any} url\r\n         * @param {any} data\r\n         */\r\n        this.request = (method, url, data) => this.umbRequestHelper.resourcePromise(method === 'DELETE' ? this.$http.delete(url)\r\n            : method === 'POST' ? this.$http.post(url, data)\r\n                : method === 'PUT' ? this.$http.put(url, data)\r\n                    : this.$http.get(url), 'Something broke');\r\n        /**\r\n         * sync the tree in the workflow section\r\n         */\r\n        this.setTreeState = () => {\r\n            if (this.$routeParams.section === 'workflow') {\r\n                this.navigationService.syncTree({ tree: this.$routeParams.tree, path: [-1], forceReload: false });\r\n            }\r\n        };\r\n        this.urls = {\r\n            settings: Umbraco.Sys.ServerVariables.Plumber.settingsApiBaseUrl,\r\n            tasks: Umbraco.Sys.ServerVariables.Plumber.tasksApiBaseUrl,\r\n            instances: Umbraco.Sys.ServerVariables.Plumber.instancesApiBaseUrl,\r\n            actions: Umbraco.Sys.ServerVariables.Plumber.actionsApiBaseUrl,\r\n            config: Umbraco.Sys.ServerVariables.Plumber.configApiBaseUrl,\r\n            scaffold: Umbraco.Sys.ServerVariables.Plumber.scaffoldApiBaseUrl\r\n        };\r\n    }\r\n}\r\nexports.PlumberServiceBase = PlumberServiceBase;\r\n\n},{}],62:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.StateFactory = void 0;\r\nconst constants_1 = require(\"../constants\");\r\nclass StateFactory {\r\n    constructor($rootScope, $location, plmbrWorkflowResource) {\r\n        this.$rootScope = $rootScope;\r\n        this.$location = $location;\r\n        this.rejected = false;\r\n        this.canAction = false;\r\n        this.canResubmit = false;\r\n        this.canEdit = true;\r\n        this.isChangeAuthor = false;\r\n        this.isAdmin = false;\r\n        ///\r\n        this.setNodeState = (currentTask) => {\r\n            var _a, _b;\r\n            this.rejected = false;\r\n            this.isChangeAuthor = false;\r\n            this.canAction = false;\r\n            this.canEdit = true;\r\n            if (currentTask) {\r\n                this.rejected = currentTask.cssStatus === constants_1.constants.states.rejected;\r\n                // if the task has been rejected and the current user requested the change, let them edit\r\n                this.isChangeAuthor = currentTask.requestedById === this.user.id;\r\n                // if the current user is a member of the group and task is pending, they can action, UNLESS...\r\n                // if the user requested the change, is a member of the current group, and flow type is exclude, they cannot action\r\n                this.canAction = ((_b = (_a = currentTask.userGroup) === null || _a === void 0 ? void 0 : _a.usersSummary) === null || _b === void 0 ? void 0 : _b.indexOf(`|${this.user.id}|`)) !== -1 && !this.rejected;\r\n                if (this.settings.flowType === 2 && this.isChangeAuthor && this.canAction) {\r\n                    this.canAction = false;\r\n                }\r\n                this.canResubmit = this.rejected && this.isChangeAuthor;\r\n                this.canEdit = this.rejected && this.isChangeAuthor || this.isAdmin;\r\n            }\r\n        };\r\n        /**\r\n         * Trial license must have node or inherited config and !excluded for config to be valid\r\n         * Other license types can have any of node, contentType or inherited, and !excluded\r\n         */\r\n        this.hasValidConfig = () => {\r\n            if (this.config.excluded) {\r\n                return false;\r\n            }\r\n            if (Umbraco.Sys.ServerVariables.Plumber.license.isTrial) {\r\n                return this.config.node.length\r\n                    || this.config.inherited.length\r\n                    || this.config.new.length;\r\n            }\r\n            return this.config.node.length\r\n                || this.config.contentType.length\r\n                || this.config.new.length\r\n                || this.config.inherited.length;\r\n        };\r\n        /**\r\n         * Remove buttons by alias from the provided button set\r\n         * @param buttons\r\n         * @param keys\r\n         */\r\n        this.removeButtons = (buttons, keys) => {\r\n            keys.forEach(key => {\r\n                const idx = buttons.findIndex(x => x.alias === key);\r\n                if (idx === -1)\r\n                    return;\r\n                buttons.splice(idx, 1);\r\n            });\r\n        };\r\n        this.workflowResource = plmbrWorkflowResource;\r\n        this.nodeId;\r\n        this.buttons = {\r\n            detail: {\r\n                labelKey: 'workflow_detailButton',\r\n                buttonStyle: constants_1.constants.states.detail,\r\n                addEllipsis: true,\r\n                handler: () => this.showApp(),\r\n                shortcut: 'ctrl+d'\r\n            },\r\n            publish: {\r\n                labelKey: 'workflow_publishButton',\r\n                buttonStyle: constants_1.constants.states.success,\r\n                addEllipsis: true,\r\n                handler: () => this.showApp(constants_1.constants.actions.publish),\r\n                shortcut: 'ctrl+p'\r\n            },\r\n            unpublish: {\r\n                labelKey: 'workflow_unpublishButton',\r\n                addEllipsis: true,\r\n                handler: () => this.showApp(constants_1.constants.actions.unpublish),\r\n                shortcut: 'ctrl+u'\r\n            }\r\n        };\r\n        $rootScope.$on('$routeChangeStart', () => {\r\n            this.originalDefaultButton = null;\r\n            this.originalSubButtons = null;\r\n        });\r\n    }\r\n    showApp(action) {\r\n        // will have multiple apps when multiple infinite editors are open\r\n        const apps = document.querySelectorAll('[data-element=\"sub-view-workflow\"]');\r\n        const tabScope = angular.element(apps[apps.length - 1]);\r\n        if (tabScope) {\r\n            if (action && this.nodeId !== 0) {\r\n                this.$rootScope.$emit(constants_1.constants.events.workflowAppActive, { action, id: this.nodeId });\r\n            }\r\n            // this is a bit naive, but avoids scope lookup on DOM elements...\r\n            tabScope['click']();\r\n        }\r\n    }\r\n    /**\r\n     * This isn't foolproof - if a node is loaded in an unpublished state, then published\r\n     * the unpublish button won't display as it didn't exist in the original buttons when the\r\n     * node first loaded. This appears to be the same behaviour in Umbraco without Plumber\r\n     * @param subButtons\r\n     * @param activeVariantState\r\n     * @param currentTask\r\n     */\r\n    setUnpublishButtons(subButtons, activeVariantState, currentTask) {\r\n        // check for wf unpublish before adding - it may have been cached as part of the set already\r\n        const unpublishIndex = subButtons.findIndex(x => x.alias === constants_1.constants.actions.unpublish);\r\n        const workflowUnpublishBtnIndex = subButtons.findIndex(x => x.alias === this.buttons.unpublish.alias);\r\n        // only add unpublish if the node is unpublishable aka is published\r\n        // this is variant-specific as each can be in a different state\r\n        if (activeVariantState.toLowerCase().startsWith(constants_1.constants.states.published)) {\r\n            // add buttons when unpublish exists (user has permission) and no workflow button added\r\n            if (unpublishIndex !== -1 && workflowUnpublishBtnIndex === -1) {\r\n                if (this.settings.requireUnpublish || this.hasUnpublishPermissions) {\r\n                    // if unpublish is required, either add the button or replace the \r\n                    // umbraco unpublish, if the user has permission to unpublish\r\n                    if (!this.isAdmin && !this.settings.extendPermissions) {\r\n                        subButtons[unpublishIndex] = this.buttons.unpublish;\r\n                    }\r\n                    else {\r\n                        subButtons.splice(unpublishIndex, 0, this.buttons.unpublish);\r\n                    }\r\n                }\r\n            }\r\n            else if (!currentTask) {\r\n                // add the workflow unpublish button if settings dictate and it isn't already in the set\r\n                if ((this.settings.requireUnpublish || this.hasUnpublishPermissions) && workflowUnpublishBtnIndex === -1) {\r\n                    subButtons.push(this.buttons.unpublish);\r\n                }\r\n                // then add the original Umbraco unpublish if it exists in the original button set and not in the updated buttons\r\n                const originalUnpublishIndex = this.originalSubButtons.findIndex(x => x.alias === constants_1.constants.actions.unpublish);\r\n                if (originalUnpublishIndex > -1 && unpublishIndex === -1) {\r\n                    subButtons.splice(originalUnpublishIndex, 0, this.originalSubButtons[originalUnpublishIndex]);\r\n                }\r\n            }\r\n        }\r\n        else if (activeVariantState.toLowerCase() === constants_1.constants.states.draft) {\r\n            // if not published, no need for unpublish buttons\r\n            if (unpublishIndex !== -1) {\r\n                subButtons.splice(unpublishIndex, 1);\r\n            }\r\n            if (workflowUnpublishBtnIndex !== -1) {\r\n                subButtons.splice(workflowUnpublishBtnIndex, 1);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Offline state is simpler as it doesn't need to set buttons\r\n     * as we can assume plenty about the state purely by being offline\r\n     * @param {any} arg\r\n     */\r\n    getOfflineState(arg) {\r\n        this.nodeId = arg.content.id;\r\n        let variant;\r\n        // offline approvale must get variant directly from path \r\n        if (window.location.pathname.startsWith('/workflow-offline')) {\r\n            let pathArray = window.location.pathname.split('/');\r\n            variant = pathArray[3]; // /workflow-offline/nodeId/variant/etc/etc/etc\r\n            variant = variant === '0' ? '*' : variant; // can't pass * in the url, so is set to 0\r\n        }\r\n        const scaffoldQueryModel = {\r\n            nodeId: this.nodeId,\r\n            contentTypeId: arg.content.contentTypeId,\r\n            path: arg.content.path,\r\n            variant,\r\n            includeServerVariables: true,\r\n        };\r\n        return this.workflowResource.scaffold(scaffoldQueryModel)\r\n            .then(resp => {\r\n            this.user = resp.user;\r\n            this.pending = resp.tasks;\r\n            this.config = resp.config;\r\n            this.settings = resp.settings;\r\n            const currentTask = this.pending.task;\r\n            const variantTasks = this.pending.variantTasks;\r\n            let hasConfig;\r\n            this.isAdmin = this.user.allowedSections.includes('workflow');\r\n            if (this.hasValidConfig()) {\r\n                hasConfig = true;\r\n                this.setNodeState(currentTask);\r\n                let config = this.configObject({ hasConfig, currentTask, variantTasks });\r\n                config['offline'] = true;\r\n                return config;\r\n            }\r\n            else {\r\n                // should never be here for offline approval, since config must exist for the offline approval\r\n                // request to have ever been generated\r\n                return this.noConfigObject();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     *\r\n     * @param {any} arg\r\n     */\r\n    getButtonState(arg) {\r\n        var _a;\r\n        // remove the Umbraco buttons to avoid flashing the default while the updated versions are calculated\r\n        // caches in the factory using the current node id, and only sets on first request for button state\r\n        // to avoid overwriting with the workflow buttons when a workflow is completed/cancelled\r\n        this.originalSubButtons = arg.content.id != this.nodeId ? arg.subButtons : this.originalSubButtons || arg.subButtons;\r\n        this.originalDefaultButton = arg.content.id != this.nodeId ? arg.defaultButton : this.originalDefaultButton || arg.defaultButton;\r\n        this.nodeId = arg.isNew === 'true' ? Umbraco.Sys.ServerVariables.Plumber.newNodeFlowId : arg.content.id;\r\n        this.path = (_a = arg.content) === null || _a === void 0 ? void 0 : _a.path;\r\n        let variant;\r\n        // get variant from URL, or from default culture if only a single variant, else from the active variant language object\r\n        variant = arg.variantCode || this.$location.search().cculture || this.$location.search().mculture ||\r\n            (arg.content.variants.length === 1 ? Umbraco.Sys.ServerVariables.Plumber.defaultCulture : arg.content.variants.filter(v => v.active)[0].language.culture);\r\n        arg.subButtons = [];\r\n        arg.defaultButton = undefined;\r\n        const scaffoldQueryModel = {\r\n            nodeId: this.nodeId,\r\n            contentTypeId: arg.content.contentTypeId,\r\n            path: arg.content.path,\r\n            variant,\r\n        };\r\n        return this.workflowResource.scaffold(scaffoldQueryModel)\r\n            .then(resp => {\r\n            this.user = resp.user;\r\n            this.pending = resp.tasks;\r\n            this.config = resp.config;\r\n            this.settings = resp.settings;\r\n            const currentTask = this.pending.task;\r\n            const variantTasks = this.pending.variantTasks;\r\n            let subButtons;\r\n            this.isAdmin = this.user.allowedSections.includes('workflow');\r\n            if (this.hasValidConfig()) {\r\n                this.setNodeState(currentTask);\r\n                // set sub-buttons, and push default button into this set\r\n                subButtons = this.originalSubButtons || [];\r\n                // only modify buttons when contentForm property exists \r\n                // when no content form, it's a dashboard, so no buttons\r\n                if (arg.contentForm) {\r\n                    if (this.pending.task || this.pending.variantTasks && !this.isAdmin) {\r\n                        subButtons = [];\r\n                    }\r\n                    else if (this.originalDefaultButton && !subButtons.find(x => x.alias === constants_1.constants.actions.saveAndPublish)) {\r\n                        subButtons.splice(0, 0, this.originalDefaultButton);\r\n                    }\r\n                    // always remove send to publish, as this causes confusion since workflow\r\n                    // is doing much the same thing, but better :)\r\n                    this.removeButtons(subButtons, [constants_1.constants.actions.sendToPublish]);\r\n                }\r\n                // if lockIfActive remove save, save+publish\r\n                if (this.settings.lockIfActive && (this.pending.task || this.pending.variantTasks)) {\r\n                    if (arg.contentForm) {\r\n                        this.removeButtons(subButtons, [constants_1.constants.actions.save, constants_1.constants.actions.saveAndPublish]);\r\n                    }\r\n                    // if locked, no one can edit, admin or otherwise, unless they have canResubmit permission\r\n                    // because rejecting but not allowing edits is pointless\r\n                    this.canEdit = this.canResubmit || false;\r\n                }\r\n                // if unpublish workflow config exists, we can include the request unpublish button even if unpublish is not required\r\n                // this has to happen here becuase the guard below will prevent the value updating when resetting state\r\n                // after saving config changes, because that happens in the workflow app\r\n                this.hasUnpublishPermissions = this.config.node.length && this.config.node[0].type === 0\r\n                    || this.config.contentType.length && this.config.contentType[0].type === 0\r\n                    || this.config.inherited.length && this.config.inherited[0].type === 0;\r\n                // if sub-buttons contains unpublish, add the request unpublish button\r\n                // if user is admin, add the button, if not, replace existing unpublish\r\n                // unpublish does not exist, add it - all workflow users should be able to request unpublish\r\n                // finally, none of this needs to happen if requireUnpublish is not true\r\n                if (arg.contentForm) {\r\n                    const activeVariant = arg.content.variants.find(v => v.active);\r\n                    this.setUnpublishButtons(subButtons, activeVariant.state, currentTask);\r\n                    // if user is not admin, remove the save+publish, schedule and publishDescendants button\r\n                    if (!this.isAdmin && !this.settings.extendPermissions) {\r\n                        this.removeButtons(subButtons, [\r\n                            constants_1.constants.actions.saveAndPublish,\r\n                            constants_1.constants.actions.schedulePublish,\r\n                            constants_1.constants.actions.publishDescendant\r\n                        ]);\r\n                    }\r\n                }\r\n                arg.defaultButton = currentTask ? this.buttons.detail : this.buttons.publish;\r\n                arg.subButtons = subButtons;\r\n                return this.configObject({\r\n                    currentTask,\r\n                    variantTasks,\r\n                    defaultButton: arg.defaultButton,\r\n                    subButtons,\r\n                });\r\n            }\r\n            else {\r\n                arg.defaultButton = this.originalDefaultButton;\r\n                arg.subButtons = this.originalSubButtons;\r\n                return this.noConfigObject({ defaultButton: arg.defaultButton, subButtons: arg.subButtons });\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     *\r\n     * @param {any} arg an object containing lots of stuff\r\n     */\r\n    configObject(arg) {\r\n        return {\r\n            nodeId: this.nodeId,\r\n            hasConfig: true,\r\n            exclude: this.config.excluded,\r\n            permissions: {\r\n                node: this.config.node,\r\n                contentType: this.config.contentType,\r\n                inherited: this.config.inherited,\r\n                new: this.config.new,\r\n                active: this.config.node.length ? 'node'\r\n                    : this.config.contentType.length ? 'contentType'\r\n                        : this.config.inherited.length ? 'inherited' : ''\r\n            },\r\n            allowAttachments: this.settings.allowAttachments,\r\n            requireUnpublish: this.settings.requireUnpublish,\r\n            hasUnpublishPermissions: this.hasUnpublishPermissions,\r\n            isActive: !!arg.currentTask,\r\n            isAdmin: this.isAdmin,\r\n            canEdit: this.canEdit,\r\n            currentTask: arg.currentTask,\r\n            variantTasks: arg.variantTasks,\r\n            canAction: this.canAction,\r\n            rejected: this.rejected,\r\n            canResubmit: this.canResubmit,\r\n            isChangeAuthor: this.isChangeAuthor,\r\n            userId: this.user.id,\r\n            buttons: {\r\n                defaultButton: arg.defaultButton,\r\n                subButtons: arg.subButtons\r\n            }\r\n        };\r\n    }\r\n    noConfigObject(arg) {\r\n        return {\r\n            nodeId: this.nodeId,\r\n            hasConfig: false,\r\n            isAdmin: this.isAdmin,\r\n            exclude: this.config.excluded,\r\n            permissions: {\r\n                node: [],\r\n                contentType: [],\r\n                inherited: [],\r\n                new: this.config.new,\r\n                active: this.config.new.length ? 'node' : '',\r\n            },\r\n            buttons: {\r\n                defaultButton: arg.defaultButton,\r\n                subButtons: arg.subButtons\r\n            },\r\n        };\r\n    }\r\n}\r\nexports.StateFactory = StateFactory;\r\nStateFactory.serviceName = 'plmbrStateFactory';\r\n\n},{\"../constants\":35}],63:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WorkflowService = void 0;\r\nconst filterpicker_1 = require(\"../../components/filterpicker/filterpicker\");\r\nconst service_base_1 = require(\"./service-base\");\r\nclass WorkflowService extends service_base_1.PlumberServiceBase {\r\n    constructor($http, $routeParams, umbRequestHelper, navigationService, dateHelper, overlayService) {\r\n        super($http, $routeParams, umbRequestHelper, navigationService);\r\n        this.dateHelper = dateHelper;\r\n        this.overlayService = overlayService;\r\n        this.activityFilter = {};\r\n        this.htmlOverlay = (title, content) => {\r\n            const overlayModel = {\r\n                view: `${Umbraco.Sys.ServerVariables.Plumber.viewsPath}overlays/html.overlay.html`,\r\n                hideSubmitButton: true,\r\n                title,\r\n                content,\r\n                submit: () => this.overlayService.close(),\r\n                close: () => this.overlayService.close()\r\n            };\r\n            this.overlayService.open(overlayModel);\r\n        };\r\n        this.scaffold = (params) => {\r\n            params.variant = this.safeVariant(params.variant);\r\n            const result = this.request('GET', this.urls.scaffold + 'Get?' + this.generateQuery(params));\r\n            this.nodeConfig = result.nodeConfig;\r\n            this.configVariant = params.variant;\r\n            return result;\r\n        };\r\n        this.generateQuery = (params) => Object.entries(params).map((e) => e[0] + '=' + e[1]).join('&');\r\n        /*\r\n         * Don't send * as a param - api endpoints default to *\r\n         */\r\n        this.safeVariant = (variant) => variant === '*' ? '' : variant;\r\n        /* TASKS */\r\n        this.getAllTasksForGroup = (query) => this.request('GET', this.urls.tasks + 'Group?' + this.generateQuery(query));\r\n        this.getAllTasksForGroupForRange = (groupId, days) => this.request('GET', this.urls.tasks + `GetForGroupAndRange?groupId=${groupId}&days=${days}`);\r\n        this.getAllTasksByGuid = (guid) => this.request('GET', `${this.urls.tasks}TasksByInstanceGuid?guid=${guid}`);\r\n        /* INSTANCES */\r\n        this.getAllInstances = (query) => this.request('GET', this.urls.instances + 'GetAll?' + this.generateQuery(query));\r\n        this.getInstancesInitiatedByUser = (query) => this.request('GET', `${this.urls.instances}GetInitiatedBy?` + this.generateQuery(query));\r\n        this.getInstancesAssignedToUser = (query) => this.request('GET', `${this.urls.instances}GetAssignedTo?` + this.generateQuery(query));\r\n        this.getActiveInstances = (query) => this.request('GET', `${this.urls.instances}GetActive?` + this.generateQuery(query));\r\n        this.getAllInstancesForRange = (days) => this.request('GET', `${this.urls.instances}GetRange?days=${days}`);\r\n        this.getStatus = (ids) => this.request('GET', this.urls.instances + 'GetStatus?ids=' + ids);\r\n        this.getDiff = (id) => this.request('GET', this.urls.instances + 'GetDiff?guid=' + id);\r\n        /* workflow actions */\r\n        this.initiateWorkflow = (model) => this.request('POST', this.urls.actions + 'Initiate', model);\r\n        this.actionWorkflow = (model) => this.request('POST', this.urls.actions + model.action, model);\r\n        /* SAVE PERMISSIONS */\r\n        this.saveNodeConfig = (nodeId, permissions, variant, appliesTo) => {\r\n            this.nodeConfig = null;\r\n            this.configVariant = null;\r\n            return this.request('POST', this.urls.config + 'SaveNodeConfig', {\r\n                id: nodeId,\r\n                permissions: permissions,\r\n                variant: variant,\r\n                type: appliesTo,\r\n            });\r\n        };\r\n        this.saveDocTypeConfig = (syncModel) => this.request('POST', this.urls.config + 'SaveContentTypeConfig', syncModel);\r\n        this.getNewNodeConfig = () => this.request('GET', this.urls.config + 'GetNewNodeConfig');\r\n        this.getPathAndType = (nodeId) => this.request('GET', this.urls.config + 'GetPathAndType?id=' + nodeId);\r\n        // pass the activity filter between the admin and history views \r\n        this.setActivityFilter = (filter) => {\r\n            if (filter != null) {\r\n                filterpicker_1.generateFilters(filter, false, this.dateHelper);\r\n            }\r\n            this.activityFilter = filter;\r\n        };\r\n        this.getActivityFilter = () => this.activityFilter;\r\n    }\r\n}\r\nexports.WorkflowService = WorkflowService;\r\nWorkflowService.serviceName = 'plmbrWorkflowResource';\r\n\n},{\"../../components/filterpicker/filterpicker\":20,\"./service-base\":61}],64:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LicensingModule = void 0;\r\nconst licensing_overview_controller_1 = require(\"./licensing.overview.controller\");\r\nexports.LicensingModule = angular\r\n    .module('plumber.licensing', [])\r\n    .controller(licensing_overview_controller_1.LicensingController.controllerName, licensing_overview_controller_1.LicensingController).name;\r\n\n},{\"./licensing.overview.controller\":65}],65:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LicensingController = void 0;\r\nclass LicensingController {\r\n    constructor(editorService, localizationService, plmbrWorkflowResource, plmbrLicensingResource) {\r\n        this.editorService = editorService;\r\n        this.getEula = () => {\r\n            this.licensingResource.getEula()\r\n                .then(data => {\r\n                const eulaOverlay = {\r\n                    view: `${Umbraco.Sys.ServerVariables.Plumber.viewsPath}overlays/subscription.eula.overlay.html`,\r\n                    eula: data,\r\n                    size: 'medium',\r\n                    hideDescription: true,\r\n                    title: this.eulaTitle,\r\n                    close: () => this.editorService.close()\r\n                };\r\n                this.editorService.open(eulaOverlay);\r\n            });\r\n        };\r\n        this.validate = () => {\r\n            this.licensingResource.validate(this.licenseString, this.keyString)\r\n                .then(resp => this.license = resp.license);\r\n        };\r\n        this.licensingResource = plmbrLicensingResource;\r\n        this.license = Umbraco.Sys.ServerVariables.Plumber.license;\r\n        localizationService.localizeMany(['workflow_licensing', 'workflow_eulaTitle', 'workflow_license', 'workflow_key'])\r\n            .then(resp => [this.sectionName, this.eulaTitle, this.licenseStr, this.keyStr] = resp);\r\n        plmbrWorkflowResource.setTreeState();\r\n        this.licensingResource.getLicensingUrl()\r\n            .then(url => this.licensingUrl = url);\r\n    }\r\n}\r\nexports.LicensingController = LicensingController;\r\nLicensingController.controllerName = 'Workflow.Licensing.Controller';\r\n\n},{}],66:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SettingsModule = void 0;\r\nconst settings_overview_controller_1 = require(\"./settings.overview.controller\");\r\nconst settings_edittemplate_controller_1 = require(\"./settings.edittemplate.controller\");\r\nconst settings_service_1 = require(\"./settings.service\");\r\nexports.SettingsModule = angular\r\n    .module('plumber.settings', [])\r\n    .service(settings_service_1.SettingsService.serviceName, settings_service_1.SettingsService)\r\n    .controller(settings_overview_controller_1.SettingsController.controllerName, settings_overview_controller_1.SettingsController)\r\n    .controller(settings_edittemplate_controller_1.EditTemplateController.controllerName, settings_edittemplate_controller_1.EditTemplateController)\r\n    .name;\r\n\n},{\"./settings.edittemplate.controller\":67,\"./settings.overview.controller\":68,\"./settings.service\":69}],67:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.EditTemplateController = void 0;\r\nclass EditTemplateController {\r\n    constructor($scope, $timeout, codefileResource, assetsService, contentEditingHelper, localizationService) {\r\n        this.$scope = $scope;\r\n        this.$timeout = $timeout;\r\n        this.codefileResource = codefileResource;\r\n        this.contentEditingHelper = contentEditingHelper;\r\n        this.$onInit = () => {\r\n            this.codefileResource.getByPath('partialViews', `workflowemails/${this.$scope.model.config.template}`)\r\n                .then(partialView => {\r\n                this.renderAceEditor(partialView);\r\n            });\r\n        };\r\n        this.save = () => {\r\n            this.saveButtonState = 'busy';\r\n            this.partialView.content = this.aceEditor.getValue();\r\n            this.contentEditingHelper.contentEditorPerformSave({\r\n                saveMethod: this.codefileResource.save,\r\n                scope: this.$scope,\r\n                content: this.partialView,\r\n                rebindCallback: (orignal, saved) => { }\r\n            }).then(saved => {\r\n                this.saveButtonState = 'success';\r\n                this.partialView = saved;\r\n                this.setFormState('pristine');\r\n                this.$scope.model.submit(this.$scope.model.config);\r\n            });\r\n        };\r\n        this.renderAceEditor = partialView => {\r\n            this.partialView = partialView;\r\n            this.aceOption = {\r\n                mode: \"razor\",\r\n                theme: \"chrome\",\r\n                showPrintMargin: false,\r\n                advanced: {\r\n                    fontSize: '14px'\r\n                },\r\n                onLoad: aceEditor => {\r\n                    this.aceEditor = aceEditor;\r\n                    this.$timeout(() => {\r\n                        this.aceEditor.navigateFileEnd();\r\n                        this.aceEditor.focus();\r\n                        this.aceEditor.on('change', () => this.setFormState('dirty'));\r\n                    });\r\n                }\r\n            };\r\n            this.loading = false;\r\n        };\r\n        this.setFormState = (state) => {\r\n            if (state === 'dirty') {\r\n                this.$scope.emailTemplateForm.$setDirty();\r\n            }\r\n            else if (state === 'pristine') {\r\n                this.$scope.emailTemplateForm.$setPristine();\r\n            }\r\n        };\r\n        this.loading = true;\r\n        // to is saved as an array of int, to allow updating the enum later if needed\r\n        // that means having to map from the int back to the string value\r\n        let sortOrder = 1;\r\n        let emailToOptions = {};\r\n        for (const [key, value] of Object.entries(this.$scope.model.emailToOptions)) {\r\n            emailToOptions[value] = {\r\n                value: `${key[0].toUpperCase()}${key.substring(1)}`,\r\n                sortOrder: sortOrder++\r\n            };\r\n        }\r\n        this.$scope.model.config._to = this.$scope.model.config.to.map(x => emailToOptions[x].value);\r\n        this.emailToOptionsModel = {\r\n            label: 'Send to',\r\n            view: 'checkboxlist',\r\n            editor: 'Umbraco.CheckBoxList',\r\n            alias: 'emailToOptionsCheckboxList',\r\n            config: {\r\n                items: emailToOptions\r\n            },\r\n            value: this.$scope.model.config._to\r\n        };\r\n        // localize the send-to keys and email types\r\n        localizationService.localize('workflow_emailTemplate')\r\n            .then(emailTemplateStr => {\r\n            this.sectionName = `${emailTemplateStr}: ${this.$scope.model.config._name}`;\r\n        });\r\n        assetsService.loadCss(\"lib/ace-razor-mode/theme/razor_chrome.css\", this.$scope);\r\n    }\r\n}\r\nexports.EditTemplateController = EditTemplateController;\r\nEditTemplateController.controllerName = 'Workflow.Settings.EditTemplate.Controller';\r\n\n},{}],68:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SettingsController = void 0;\r\nconst constants_1 = require(\"../js/constants\");\r\nconst sortoptions_1 = require(\"../js/models/sortoptions\");\r\nclass SettingsController {\r\n    constructor($q, $scope, $compile, plmbrSettingsResource, plmbrGroupsResource, editorService, localizationService, formHelper, plmbrWorkflowResource) {\r\n        this.$scope = $scope;\r\n        this.$compile = $compile;\r\n        this.editorService = editorService;\r\n        this.formHelper = formHelper;\r\n        this.loaded = true;\r\n        this.sortOptions = new sortoptions_1.SortOptions();\r\n        /**\r\n         * */\r\n        this.save = () => {\r\n            if (!this.formHelper.submitForm({\r\n                scope: this.$scope,\r\n            }))\r\n                return;\r\n            // sync the new node flow back to the settings object\r\n            if (this.newNodeFlow.value) {\r\n                const variant = Umbraco.Sys.ServerVariables.Plumber.defaultCulture;\r\n                this.newNodeFlow.value.forEach((v, i) => {\r\n                    v.variant = variant;\r\n                    v.permission = i;\r\n                });\r\n                this.settings.general.newNodeApprovalFlow.value = this.newNodeFlow.value;\r\n            }\r\n            else {\r\n                this.settings.general.newNodeApprovalFlow.value = [];\r\n            }\r\n            let syncModel = [];\r\n            this.contentTypePermissionsSyncModel.forEach(x => {\r\n                syncModel.push({\r\n                    id: x.id,\r\n                    permissions: x.permissions.map((p) => {\r\n                        if (!p.condition || typeof p.condition === 'string')\r\n                            return p;\r\n                        p.condition = p.condition.join(',');\r\n                        return p;\r\n                    }),\r\n                });\r\n            });\r\n            // syncModel is an array of ConfigModel items. \r\n            this.settings.general.documentTypeApprovalFlows.value = syncModel;\r\n            this.workflowSettingsResource.saveSettings(this.settings)\r\n                .then(() => this.updateFormState(false));\r\n        };\r\n        /**\r\n         *\r\n         */\r\n        this.hasPermissions = dt => dt.permissions.length;\r\n        /**\r\n         * Removes the document type permissions, then save the change\r\n         * @param {any} type ...\r\n         */\r\n        this.removeDocTypeFlow = type => {\r\n            if (this.license.isTrial) {\r\n                return;\r\n            }\r\n            this.contentTypePermissionsSyncModel.find(x => x.alias === type.alias).permissions = [];\r\n            this.docTypes.find(x => x.alias === type.alias).permissions = [];\r\n            this.updateFormState();\r\n        };\r\n        /**\r\n         * @param {any} type ...\r\n         */\r\n        this.editDocTypeFlow = type => {\r\n            if (this.license.isTrial) {\r\n                return;\r\n            }\r\n            const overlayModel = {\r\n                view: `${this.viewsPath}overlays/workflow.contenttypeflow.overlay.html`,\r\n                type: type,\r\n                size: constants_1.constants.sizes.m,\r\n                groups: this.groups,\r\n                types: this.docTypes.filter(v => !v.permissions.length),\r\n                title: `${type ? this.editStr : this.addStr} ${this.docTypeFlowStr}`,\r\n                requireUnpublish: this.settings.requireUnpublish,\r\n                description: type ? `${this.docTypeStr}: ${type.name}` : '',\r\n                submit: model => {\r\n                    // map the appliesTo value onto each permission\r\n                    model.type.permissions.forEach(p => p.type = model.appliesTo);\r\n                    const existing = this.contentTypePermissionsSyncModel.find(x => x.alias === model.type.alias);\r\n                    if (existing) {\r\n                        existing.permissions = model.type.permissions;\r\n                        existing.condition = model.type.condition;\r\n                    }\r\n                    else {\r\n                        this.contentTypePermissionsSyncModel.push(this.getPermissionObject(model.type));\r\n                    }\r\n                    this.updateFormState();\r\n                    this.editorService.close();\r\n                },\r\n                close: () => this.editorService.close(),\r\n            };\r\n            this.editorService.open(overlayModel);\r\n        };\r\n        /**\r\n         *\r\n         * @param {any} d\r\n         */\r\n        this.getPermissionObject = d => ({\r\n            id: d.id,\r\n            permissions: d.permissions,\r\n            condition: d.condition,\r\n            alias: d.alias,\r\n            name: d.name,\r\n            icon: d.icon,\r\n            properties: d.properties,\r\n            type: d.type,\r\n        });\r\n        /**\r\n         *\r\n         * @param {any} c\r\n         */\r\n        this.setSendTo = c => {\r\n            let emailTo = [];\r\n            for (const [k, v] of Object.entries(this.settings.notifications.emailToOptions)) {\r\n                if (c.to.includes(v)) {\r\n                    emailTo.push(`${k[0].toUpperCase()}${k.substring(1)}`);\r\n                }\r\n            }\r\n            c._sendTo = `${this.sendToStr}: ${emailTo.join(', ')}`;\r\n        };\r\n        /**\r\n         *\r\n         * @param {any} config\r\n         */\r\n        this.editTemplate = config => {\r\n            const overlayModel = {\r\n                view: `${this.viewsPath}overlays/workflow.emailtemplate.overlay.html`,\r\n                config,\r\n                emailToOptions: this.settings.notifications.emailToOptions,\r\n                submit: updatedConfig => {\r\n                    // map to array back to int - _to is the modified value\r\n                    config.to = updatedConfig._to.map(t => this.settings.notifications.emailToOptions[t.toLowerCase()]);\r\n                    // update the display value for send to\r\n                    this.setSendTo(config);\r\n                    this.editorService.close();\r\n                    // save the updated emailto settings - template was saved in the overlay\r\n                    this.save();\r\n                },\r\n                close: () => this.editorService.close()\r\n            };\r\n            this.editorService.open(overlayModel);\r\n        };\r\n        this.workflowSettingsResource = plmbrSettingsResource;\r\n        this.workflowGroupsResource = plmbrGroupsResource;\r\n        this.workflowResource = plmbrWorkflowResource;\r\n        this.viewsPath = Umbraco.Sys.ServerVariables.Plumber.viewsPath;\r\n        this.license = Umbraco.Sys.ServerVariables.Plumber.license;\r\n        const pluginPath = Umbraco.Sys.ServerVariables.Plumber.pluginPath;\r\n        this.contentTypePermissionsSyncModel = [];\r\n        this.navigation = [\r\n            {\r\n                name: 'General',\r\n                alias: 'general',\r\n                icon: 'icon-umb-settings',\r\n                view: `${pluginPath}/settings/partials/general.html`,\r\n                active: true\r\n            }, {\r\n                name: 'Notifications',\r\n                alias: 'notifications',\r\n                icon: 'icon-inbox',\r\n                view: `${pluginPath}/settings/partials/notifications.html`\r\n            }\r\n        ];\r\n        const promises = [\r\n            this.workflowSettingsResource.getSettingsForDisplay(),\r\n            this.workflowSettingsResource.getContentTypes(),\r\n            this.workflowGroupsResource.getAllSlim(),\r\n        ];\r\n        localizationService.localizeMany([\r\n            'workflow_settings',\r\n            'general_edit',\r\n            'general_add',\r\n            'workflow_flowType',\r\n            'workflow_docTypeApprovalFlow',\r\n            'workflow_flowTypeDescription',\r\n            'content_documentType',\r\n            'workflow_sendTo'\r\n        ])\r\n            .then(resp => [this.sectionName, this.editStr, this.addStr, this.flowTypeStr, this.docTypeFlowStr,\r\n            this.flowTypeDescriptionStr, this.docTypeStr, this.sendToStr] = resp);\r\n        $q.all(promises)\r\n            .then(resp => {\r\n            [this.settings, this.docTypes, this.groups, this.newNodeFlow] = [resp[0], resp[1], resp[2].items, resp[0].general.newNodeApprovalFlow];\r\n            this.settings.notifications.emailConfig.forEach(c => {\r\n                this.setSendTo(c);\r\n                // store on a private field since we don't want to persist the translated string\r\n                localizationService.localize(`workflow_${c.key[0].toLowerCase()}${c.key.substring(1)}`)\r\n                    .then(k => c._name = k);\r\n            });\r\n            this.getContentTypePermissionSyncModel();\r\n            setTimeout(() => this.injectFlowTypeHelper());\r\n            this.loaded = true;\r\n            this.workflowSettingsResource.licenseCheck();\r\n        });\r\n        this.workflowSettingsResource.setTreeState();\r\n    }\r\n    groupName(name, idx) {\r\n        return this.workflowGroupsResource.generateNameWithStage(name, idx);\r\n    }\r\n    editGroup(group) {\r\n        this.workflowGroupsResource.editGroup(group.groupId);\r\n    }\r\n    /**\r\n     * */\r\n    openGroupOverlay() {\r\n        const model = {\r\n            view: Umbraco.Sys.ServerVariables.Plumber.viewsPath + '/overlays/grouppicker.overlay.html',\r\n            size: constants_1.constants.sizes.s,\r\n            title: 'Add workflow approval group/s',\r\n            approvalPath: this.newNodeFlow.value,\r\n            submit: (result) => {\r\n                result.selection.forEach(group => {\r\n                    this.addNewNodeFlowGroup(group);\r\n                });\r\n                this.editorService.close();\r\n            },\r\n            close: () => this.editorService.close(),\r\n        };\r\n        this.editorService.open(model);\r\n    }\r\n    /**\r\n     *\r\n     * @param {any} isDirty\r\n     */\r\n    updateFormState(isDirty = true) {\r\n        if (isDirty) {\r\n            this.$scope.workflowSettingsForm.$setDirty();\r\n        }\r\n        else {\r\n            this.$scope.workflowSettingsForm.$setPristine();\r\n        }\r\n    }\r\n    /**\r\n     * */\r\n    addNewNodeFlowGroup(group) {\r\n        if (!this.newNodeFlow.value) {\r\n            this.newNodeFlow.value = [];\r\n        }\r\n        this.newNodeFlow.value.push({\r\n            nodeId: Umbraco.Sys.ServerVariables.Plumber.newNodeFlowId,\r\n            permission: this.newNodeFlow.value.length,\r\n            groupId: group.groupId,\r\n            groupName: group.name,\r\n        });\r\n        this.updateFormState();\r\n    }\r\n    /**\r\n     *\r\n     * @param {any} item\r\n     */\r\n    removeNewNodeFlowGroup(item) {\r\n        const idx = this.newNodeFlow.value.indexOf(item);\r\n        this.newNodeFlow.value.splice(idx, 1);\r\n        this.newNodeFlow.value.forEach((v, i) => v.permission = i);\r\n        this.updateFormState();\r\n    }\r\n    /**\r\n     * */\r\n    getContentTypePermissionSyncModel() {\r\n        if (this.license.isTrial)\r\n            return;\r\n        // map contentTypes with permissions to sync model   \r\n        this.docTypes\r\n            .forEach(d => {\r\n            if (!d.permissions.length)\r\n                return;\r\n            this.contentTypePermissionsSyncModel.push(this.getPermissionObject(d));\r\n        });\r\n    }\r\n    /**\r\n     * Adds help button for flow type, to show description in an overlay\r\n     * */\r\n    injectFlowTypeHelper() {\r\n        const button = `\r\n            <umb-button type=\"button\" id=\"flowTypeBtn\" button-style=\"link\" icon=\"icon-help-alt\" action=\"vm.showFlowTypeDescription()\">\r\n            </umb-button>`;\r\n        const property = document.querySelector('umb-property[alias*=\"flowType\"]');\r\n        const header = property === null || property === void 0 ? void 0 : property.querySelector('.control-header');\r\n        if (header) {\r\n            angular.element(header).prepend(this.$compile(button)(this.$scope));\r\n        }\r\n    }\r\n    showFlowTypeDescription() {\r\n        this.workflowResource.htmlOverlay(this.flowTypeStr, this.flowTypeDescriptionStr);\r\n    }\r\n}\r\nexports.SettingsController = SettingsController;\r\nSettingsController.controllerName = 'Workflow.Settings.Overview.Controller';\r\n\n},{\"../js/constants\":35,\"../js/models/sortoptions\":54}],69:[function(require,module,exports){\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SettingsService = void 0;\r\nconst service_base_1 = require(\"../js/services/service-base\");\r\nclass SettingsService extends service_base_1.PlumberServiceBase {\r\n    constructor($http, $rootScope, $routeParams, umbRequestHelper, navigationService) {\r\n        super($http, $routeParams, umbRequestHelper, navigationService);\r\n        this.$rootScope = $rootScope;\r\n        this.getSettingsForDisplay = () => this.request('GET', this.urls.settings + 'Get');\r\n        this.saveSettings = (settings) => this.request('POST', this.urls.settings + 'Save', settings);\r\n        this.getContentTypes = () => this.request('GET', this.urls.settings + 'GetContentTypes');\r\n        this.getVersion = () => this.request('GET', this.urls.settings + 'GetVersion');\r\n        this.getDocs = () => this.request('GET', this.urls.settings + 'GetDocs');\r\n        this.licenseCheck = () => this.$rootScope.$emit('licenseCheck');\r\n    }\r\n}\r\nexports.SettingsService = SettingsService;\r\nSettingsService.serviceName = 'plmbrSettingsResource';\r\n\n},{\"../js/services/service-base\":61}]},{},[3,2,1,5,6,7,8,4,9,32,31,34,33,35,65,64,67,68,69,66,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,37,38,39,40,41,36,43,44,45,46,42,48,49,47,50,51,52,53,54,55,57,58,59,60,61,62,63,56]);\n"],"file":"plumber.js"}